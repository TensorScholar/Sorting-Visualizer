{"ast":null,"code":"var _jsxFileName = \"/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/visualization/components/distribution-visualizer.js\";\n// src/visualization/components/distribution-visualizer.js\n\n/**\n * @file Distribution Sort Visualizer Component\n * @author Algorithm Visualization Platform Team\n * @version 1.0.0\n * \n * @description\n * A specialized visualization component for distribution-based sorting algorithms\n * (Counting Sort, Radix Sort, Bucket Sort, Pigeonhole Sort).\n * \n * This component provides visualizations specific to the unique characteristics\n * of distribution sorts, including:\n * 1. Auxiliary data structures visualization (count arrays, buckets, digit groups)\n * 2. Distribution and collection phase animations\n * 3. Digit-by-digit processing for radix sorts\n * 4. Distribution range visualization\n * \n * The implementation follows principles of information visualization theory,\n * focusing on clear representation of algorithm-specific operations while\n * maintaining a cohesive and intuitive visual language.\n */\n\nimport React, { useRef, useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { WebGLRenderer } from '../renderers/webgl-renderer';\n\n/**\n * Color schemes specifically optimized for distribution algorithm visualization\n * @constant\n * @type {Object}\n * @private\n */\nconst DISTRIBUTION_COLOR_SCHEMES = {\n  // Color scheme for buckets - perceptually distinct colors\n  BUCKETS: ['#4285F4',\n  // Blue\n  '#EA4335',\n  // Red\n  '#FBBC05',\n  // Yellow\n  '#34A853',\n  // Green\n  '#8B43EE',\n  // Purple\n  '#F57C00',\n  // Orange\n  '#0097A7',\n  // Teal\n  '#757575',\n  // Gray\n  '#9C27B0',\n  // Magenta\n  '#3949AB',\n  // Indigo\n  '#039BE5',\n  // Light Blue\n  '#7CB342',\n  // Light Green\n  '#C2185B',\n  // Pink\n  '#FF5722',\n  // Deep Orange\n  '#00BCD4',\n  // Cyan\n  '#FFA000' // Amber\n  ],\n  // Scientifically designed color scheme for count arrays - sequential blue\n  COUNTS: ['#E3F2FD', '#BBDEFB', '#90CAF9', '#64B5F6', '#42A5F5', '#2196F3', '#1E88E5', '#1976D2', '#1565C0', '#0D47A1'],\n  // Color scheme for digit positions in radix sort - categorical\n  DIGITS: ['#C8E6C9',\n  // Light Green\n  '#B3E5FC',\n  // Light Blue\n  '#FFCCBC',\n  // Light Orange\n  '#D1C4E9',\n  // Light Purple\n  '#F8BBD0' // Light Pink\n  ],\n  // Grayscale for the original array visualization\n  GRAYSCALE: ['#F5F5F5', '#E0E0E0', '#BDBDBD', '#9E9E9E', '#757575', '#616161', '#424242', '#212121']\n};\n\n/**\n * Utility functions for distribution algorithm visualization\n * @namespace\n * @private\n */\nconst DistributionVisualizationUtils = {\n  /**\n   * Get a color for a bucket index using a consistent mapping\n   * @param {number} index - Bucket index\n   * @param {number} total - Total number of buckets\n   * @returns {string} Color in hex format\n   */\n  getBucketColor(index, total) {\n    const colors = DISTRIBUTION_COLOR_SCHEMES.BUCKETS;\n    // Use modulo to handle more buckets than colors\n    return colors[index % colors.length];\n  },\n  /**\n   * Get a color for a count value\n   * @param {number} count - Count value\n   * @param {number} maxCount - Maximum count for normalization\n   * @returns {string} Color in hex format\n   */\n  getCountColor(count, maxCount) {\n    const normalizedValue = Math.min(Math.max(count / maxCount, 0), 1);\n    const index = Math.floor(normalizedValue * (DISTRIBUTION_COLOR_SCHEMES.COUNTS.length - 1));\n    return DISTRIBUTION_COLOR_SCHEMES.COUNTS[index];\n  },\n  /**\n   * Get a color for a digit position in radix sort\n   * @param {number} position - Digit position\n   * @returns {string} Color in hex format\n   */\n  getDigitPositionColor(position) {\n    const colors = DISTRIBUTION_COLOR_SCHEMES.DIGITS;\n    return colors[position % colors.length];\n  },\n  /**\n   * Convert a hex color to RGBA\n   * @param {string} hex - Hex color string\n   * @param {number} alpha - Alpha value\n   * @returns {Array<number>} RGBA array [r, g, b, a] with values in 0-1 range\n   */\n  hexToRgba(hex, alpha = 1) {\n    const r = parseInt(hex.slice(1, 3), 16) / 255;\n    const g = parseInt(hex.slice(3, 5), 16) / 255;\n    const b = parseInt(hex.slice(5, 7), 16) / 255;\n    return [r, g, b, alpha];\n  },\n  /**\n   * Generate bucket labels based on range and count\n   * @param {number} min - Minimum value in range\n   * @param {number} max - Maximum value in range\n   * @param {number} count - Number of buckets\n   * @returns {Array<string>} Array of bucket labels\n   */\n  generateBucketLabels(min, max, count) {\n    const range = max - min;\n    const step = range / count;\n    return Array.from({\n      length: count\n    }, (_, i) => {\n      const lowerBound = min + i * step;\n      const upperBound = min + (i + 1) * step;\n      return `${Math.floor(lowerBound)}–${Math.ceil(upperBound) - 1}`;\n    });\n  },\n  /**\n   * Create a distribution mapping function for a specific algorithm\n   * @param {string} algorithm - Algorithm type ('counting', 'radix', 'bucket', 'pigeonhole')\n   * @param {Object} options - Algorithm-specific options\n   * @returns {Function} Mapping function from value to bucket index\n   */\n  createDistributionMapper(algorithm, options) {\n    const {\n      min = 0,\n      max = 100,\n      bucketCount = 10,\n      digitPosition = 0,\n      radix = 10\n    } = options;\n    switch (algorithm) {\n      case 'counting':\n      case 'pigeonhole':\n        // Direct mapping based on value\n        return value => value - min;\n      case 'bucket':\n        // Map to bucket based on range subdivision\n        const range = max - min;\n        return value => Math.min(bucketCount - 1, Math.floor((value - min) / range * bucketCount));\n      case 'radix':\n        // Map based on digit at specified position\n        return value => {\n          // Extract the digit at the specified position\n          const positiveValue = Math.abs(value);\n          let digit;\n          if (digitPosition === 0) {\n            // Least significant digit\n            digit = positiveValue % radix;\n          } else {\n            // Higher position digits\n            digit = Math.floor(positiveValue / Math.pow(radix, digitPosition)) % radix;\n          }\n          return digit;\n        };\n      default:\n        // Default identity mapping\n        return value => value;\n    }\n  }\n};\n\n/**\n * DistributionVisualizer Component\n * \n * A specialized React component for visualizing distribution-based sorting algorithms.\n * Renders both the array being sorted and the auxiliary data structures used in the sorting process.\n * \n * @component\n */\nconst DistributionVisualizer = ({\n  // Algorithm data\n  algorithm,\n  data,\n  auxiliaryData,\n  step,\n  // Canvas dimensions\n  width = 800,\n  height = 500,\n  // Visualization options\n  options = {}\n}) => {\n  // Merge default options\n  const visualizationOptions = {\n    barWidth: 4,\n    spacing: 1,\n    bucketSpacing: 20,\n    bucketLabelHeight: 20,\n    countBarWidth: 30,\n    countBarSpacing: 5,\n    animationDuration: 300,\n    showLabels: true,\n    colorScheme: 'spectrum',\n    backgroundColor: [0.1, 0.1, 0.15, 1.0],\n    ...options\n  };\n\n  // Canvas references\n  const mainCanvasRef = useRef(null);\n  const auxiliaryCanvasRef = useRef(null);\n\n  // State for rendering\n  const [mainRenderer, setMainRenderer] = useState(null);\n  const [auxRenderer, setAuxRenderer] = useState(null);\n  const [animatedData, setAnimatedData] = useState([]);\n  const [bucketData, setBucketData] = useState([]);\n  const [countData, setCountData] = useState([]);\n  const [currentDigit, setCurrentDigit] = useState(0);\n\n  // Determine algorithm-specific properties\n  const isRadixSort = algorithm === 'radix-sort';\n  const isCountingSort = algorithm === 'counting-sort' || algorithm === 'pigeonhole-sort';\n  const isBucketSort = algorithm === 'bucket-sort';\n\n  // Initialize renderers on mount\n  useEffect(() => {\n    // Initialize main array renderer\n    if (mainCanvasRef.current) {\n      const renderer = new WebGLRenderer(mainCanvasRef.current, {\n        barWidth: visualizationOptions.barWidth,\n        spacing: visualizationOptions.spacing,\n        colorScheme: visualizationOptions.colorScheme,\n        background: visualizationOptions.backgroundColor,\n        animationDuration: visualizationOptions.animationDuration\n      });\n      setMainRenderer(renderer);\n      if (data && data.length > 0) {\n        renderer.setData(data);\n      }\n    }\n\n    // Initialize auxiliary visualization renderer\n    if (auxiliaryCanvasRef.current) {\n      // For auxiliary structures, we use a 2D canvas for more flexibility\n      const canvas = auxiliaryCanvasRef.current;\n      const ctx = canvas.getContext('2d');\n\n      // Store the context in a renderer-like object for consistency\n      setAuxRenderer({\n        ctx,\n        canvas\n      });\n    }\n\n    // Cleanup function\n    return () => {\n      if (mainRenderer) {\n        mainRenderer.dispose();\n      }\n    };\n  }, []);\n\n  // Update data when it changes\n  useEffect(() => {\n    if (mainRenderer && data && data.length > 0) {\n      mainRenderer.setData(data);\n      setAnimatedData([...data]);\n    }\n  }, [data]);\n\n  // Update auxiliary data visualization when it changes\n  useEffect(() => {\n    if (!auxiliaryData) return;\n    if (isCountingSort && auxiliaryData.counts) {\n      setCountData(auxiliaryData.counts);\n    } else if (isBucketSort && auxiliaryData.buckets) {\n      setBucketData(auxiliaryData.buckets);\n    } else if (isRadixSort) {\n      if (auxiliaryData.currentDigit !== undefined) {\n        setCurrentDigit(auxiliaryData.currentDigit);\n      }\n      if (auxiliaryData.buckets) {\n        setBucketData(auxiliaryData.buckets);\n      }\n    }\n\n    // Render the auxiliary data\n    renderAuxiliaryData();\n  }, [auxiliaryData, auxRenderer]);\n\n  // Update visualization based on the current step\n  useEffect(() => {\n    if (!step || !mainRenderer) return;\n\n    // Apply step-specific visualization\n    if (step.type === 'distribution') {\n      // Highlight elements being distributed\n      mainRenderer.highlight(step.indices || []);\n\n      // Update bucket or count visualization\n      renderAuxiliaryData();\n    } else if (step.type === 'collection') {\n      // Highlight elements being collected back\n      mainRenderer.highlight(step.indices || []);\n\n      // Update main array with collected elements\n      if (step.array) {\n        mainRenderer.setData(step.array, false);\n      }\n    } else if (step.type === 'counting') {\n      // Highlight the element being counted\n      mainRenderer.highlight([step.index]);\n\n      // Highlight the corresponding count\n      renderAuxiliaryData(step.countIndex);\n    } else if (step.type === 'digit-extraction') {\n      // For radix sort, highlight the element and its current digit\n      mainRenderer.highlight([step.index]);\n      setCurrentDigit(step.digitPosition);\n    }\n  }, [step, mainRenderer]);\n\n  /**\n   * Render auxiliary data structures (buckets, counts, etc.)\n   * @param {number} [highlightIndex] - Optional index to highlight\n   */\n  const renderAuxiliaryData = highlightIndex => {\n    if (!auxRenderer || !auxRenderer.ctx) return;\n    const {\n      ctx,\n      canvas\n    } = auxRenderer;\n    const width = canvas.width;\n    const height = canvas.height;\n\n    // Clear the canvas\n    ctx.clearRect(0, 0, width, height);\n    ctx.fillStyle = 'rgb(24, 24, 36)'; // Dark background\n    ctx.fillRect(0, 0, width, height);\n\n    // Render based on algorithm type\n    if (isCountingSort && countData && countData.length > 0) {\n      renderCountArray(ctx, countData, width, height, highlightIndex);\n    } else if ((isBucketSort || isRadixSort) && bucketData && bucketData.length > 0) {\n      renderBuckets(ctx, bucketData, width, height, highlightIndex);\n    }\n  };\n\n  /**\n   * Render the count array for Counting Sort or Pigeonhole Sort\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\n   * @param {Array<number>} counts - Count array\n   * @param {number} width - Canvas width\n   * @param {number} height - Canvas height\n   * @param {number} [highlightIndex] - Optional index to highlight\n   * @private\n   */\n  const renderCountArray = (ctx, counts, width, height, highlightIndex) => {\n    const {\n      countBarWidth,\n      countBarSpacing,\n      showLabels\n    } = visualizationOptions;\n\n    // Calculate dimensions\n    const maxCount = Math.max(...counts, 1);\n    const totalBars = counts.length;\n    const availableWidth = width - 40; // Padding\n    const barWidth = Math.min(countBarWidth, availableWidth / totalBars - countBarSpacing);\n    const startX = (width - (barWidth + countBarSpacing) * totalBars) / 2;\n    const maxBarHeight = height - 60; // Leave room for labels\n\n    // Title\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 16px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('Count Array', width / 2, 25);\n\n    // Draw count bars\n    counts.forEach((count, i) => {\n      const x = startX + i * (barWidth + countBarSpacing);\n      const barHeight = count / maxCount * maxBarHeight;\n      const y = height - 30 - barHeight; // Bottom-aligned\n\n      // Determine color\n      let fillColor = DistributionVisualizationUtils.getCountColor(count, maxCount);\n\n      // Highlight specific count if requested\n      if (highlightIndex !== undefined && i === highlightIndex) {\n        fillColor = '#FFEB3B'; // Yellow highlight\n\n        // Draw highlight effect\n        ctx.fillStyle = 'rgba(255, 235, 59, 0.3)';\n        ctx.fillRect(x - 5, y - 5, barWidth + 10, barHeight + 10);\n      }\n\n      // Draw bar\n      ctx.fillStyle = fillColor;\n      ctx.fillRect(x, y, barWidth, barHeight);\n\n      // Draw border\n      ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(x, y, barWidth, barHeight);\n\n      // Draw count value\n      ctx.fillStyle = 'black';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(count.toString(), x + barWidth / 2, y - 5);\n\n      // Draw index labels\n      if (showLabels) {\n        ctx.fillStyle = 'white';\n        ctx.fillText(i.toString(), x + barWidth / 2, height - 10);\n      }\n    });\n  };\n\n  /**\n   * Render buckets for Bucket Sort or Radix Sort\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\n   * @param {Array<Array>} buckets - Array of bucket contents\n   * @param {number} width - Canvas width\n   * @param {number} height - Canvas height\n   * @param {number} [highlightIndex] - Optional bucket index to highlight\n   * @private\n   */\n  const renderBuckets = (ctx, buckets, width, height, highlightIndex) => {\n    const {\n      barWidth,\n      spacing,\n      bucketSpacing,\n      bucketLabelHeight,\n      showLabels\n    } = visualizationOptions;\n\n    // Calculate dimensions\n    const totalBuckets = buckets.length;\n    const maxBucketSize = Math.max(...buckets.map(bucket => bucket.length), 1);\n    const availableWidth = width - 40; // Padding\n    const bucketWidth = availableWidth / totalBuckets - bucketSpacing;\n\n    // Calculate maximum bar height\n    const maxBarHeight = (height - 60 - bucketLabelHeight) / maxBucketSize;\n    const effectiveBarHeight = Math.min(25, maxBarHeight);\n\n    // Title\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 16px Arial';\n    ctx.textAlign = 'center';\n    const title = isRadixSort ? `Radix Sort - Digit Position: ${currentDigit}` : 'Bucket Distribution';\n    ctx.fillText(title, width / 2, 25);\n\n    // Draw buckets\n    buckets.forEach((bucket, bucketIndex) => {\n      const bucketX = 20 + bucketIndex * (bucketWidth + bucketSpacing);\n      const bucketY = 40;\n      const bucketHeight = height - bucketY - 20;\n\n      // Determine bucket color\n      const bucketColor = DistributionVisualizationUtils.getBucketColor(bucketIndex, totalBuckets);\n\n      // Highlight specific bucket if requested\n      if (highlightIndex !== undefined && bucketIndex === highlightIndex) {\n        // Draw highlight effect around bucket\n        ctx.fillStyle = 'rgba(255, 235, 59, 0.2)';\n        ctx.fillRect(bucketX - 5, bucketY - 5, bucketWidth + 10, bucketHeight + 10);\n      }\n\n      // Draw bucket container\n      ctx.fillStyle = 'rgba(30, 30, 45, 0.8)';\n      ctx.fillRect(bucketX, bucketY, bucketWidth, bucketHeight);\n\n      // Draw bucket border\n      ctx.strokeStyle = bucketColor;\n      ctx.lineWidth = 2;\n      ctx.strokeRect(bucketX, bucketY, bucketWidth, bucketHeight);\n\n      // Draw bucket label\n      if (showLabels) {\n        ctx.fillStyle = bucketColor;\n        ctx.font = '14px Arial';\n        ctx.textAlign = 'center';\n        let label;\n        if (isRadixSort) {\n          label = `Digit: ${bucketIndex}`;\n        } else {\n          label = `Bucket ${bucketIndex}`;\n        }\n        ctx.fillText(label, bucketX + bucketWidth / 2, bucketY + 20);\n      }\n\n      // Draw bucket elements\n      bucket.forEach((value, elementIndex) => {\n        const elementY = bucketY + 30 + elementIndex * (effectiveBarHeight + 2);\n        const elementHeight = effectiveBarHeight;\n\n        // Draw element bar\n        ctx.fillStyle = bucketColor;\n        ctx.fillRect(bucketX + 10, elementY, bucketWidth - 20, elementHeight);\n\n        // Draw element value\n        ctx.fillStyle = 'white';\n        ctx.font = '12px Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText(value.toString(), bucketX + bucketWidth / 2, elementY + elementHeight / 2 + 4);\n      });\n\n      // Draw bucket size\n      ctx.fillStyle = 'white';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'right';\n      ctx.fillText(`Size: ${bucket.length}`, bucketX + bucketWidth - 10, bucketY + bucketHeight - 10);\n    });\n  };\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"distribution-visualizer\",\n    style: {\n      width,\n      height: height + 50\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 532,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"visualization-container\",\n    style: {\n      display: 'flex',\n      flexDirection: 'column'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 533,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"main-array-container\",\n    style: {\n      marginBottom: '20px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 534,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"h3\", {\n    className: \"visualization-title\",\n    style: {\n      margin: '0 0 10px 0',\n      fontSize: '16px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 535,\n      columnNumber: 11\n    }\n  }, \"Main Array\"), /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: mainCanvasRef,\n    width: width,\n    height: height / 2 - 30,\n    className: \"main-canvas\",\n    style: {\n      border: '1px solid #2d3748',\n      borderRadius: '4px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 538,\n      columnNumber: 11\n    }\n  })), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"auxiliary-container\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 547,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"h3\", {\n    className: \"visualization-title\",\n    style: {\n      margin: '0 0 10px 0',\n      fontSize: '16px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 548,\n      columnNumber: 11\n    }\n  }, isCountingSort ? 'Count Array' : isRadixSort ? `Digit Buckets (Position: ${currentDigit})` : 'Buckets'), /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: auxiliaryCanvasRef,\n    width: width,\n    height: height / 2 - 30,\n    className: \"auxiliary-canvas\",\n    style: {\n      border: '1px solid #2d3748',\n      borderRadius: '4px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 555,\n      columnNumber: 11\n    }\n  }))), step && /*#__PURE__*/React.createElement(\"div\", {\n    className: \"step-description\",\n    style: {\n      padding: '10px',\n      background: '#f8fafc',\n      borderRadius: '4px',\n      marginTop: '10px',\n      fontSize: '14px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 566,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 573,\n      columnNumber: 11\n    }\n  }, \"Current Operation:\"), \" \", step.message || 'No description available'));\n};\n\n// PropTypes for documentation and runtime type checking\nDistributionVisualizer.propTypes = {\n  /** The distribution algorithm being visualized ('counting-sort', 'radix-sort', 'bucket-sort', 'pigeonhole-sort') */\n  algorithm: PropTypes.string.isRequired,\n  /** The current array data being sorted */\n  data: PropTypes.arrayOf(PropTypes.number).isRequired,\n  /** Auxiliary data structures used by the algorithm */\n  auxiliaryData: PropTypes.shape({\n    /** Count array for counting sort */\n    counts: PropTypes.arrayOf(PropTypes.number),\n    /** Buckets for bucket sort or radix sort */\n    buckets: PropTypes.arrayOf(PropTypes.array),\n    /** Current digit position for radix sort */\n    currentDigit: PropTypes.number,\n    /** Range information */\n    min: PropTypes.number,\n    max: PropTypes.number\n  }),\n  /** Current algorithm step information */\n  step: PropTypes.shape({\n    /** Type of operation ('distribution', 'collection', 'counting', 'digit-extraction') */\n    type: PropTypes.string,\n    /** Array indices involved in current operation */\n    indices: PropTypes.arrayOf(PropTypes.number),\n    /** Description message */\n    message: PropTypes.string,\n    /** Current array state if applicable */\n    array: PropTypes.arrayOf(PropTypes.number),\n    /** Index being processed */\n    index: PropTypes.number,\n    /** Count array index if applicable */\n    countIndex: PropTypes.number,\n    /** Digit position for radix sort */\n    digitPosition: PropTypes.number\n  }),\n  /** Canvas width in pixels */\n  width: PropTypes.number,\n  /** Canvas height in pixels */\n  height: PropTypes.number,\n  /** Visualization options */\n  options: PropTypes.object\n};\nexport default DistributionVisualizer;","map":{"version":3,"names":["React","useRef","useState","useEffect","PropTypes","WebGLRenderer","DISTRIBUTION_COLOR_SCHEMES","BUCKETS","COUNTS","DIGITS","GRAYSCALE","DistributionVisualizationUtils","getBucketColor","index","total","colors","length","getCountColor","count","maxCount","normalizedValue","Math","min","max","floor","getDigitPositionColor","position","hexToRgba","hex","alpha","r","parseInt","slice","g","b","generateBucketLabels","range","step","Array","from","_","i","lowerBound","upperBound","ceil","createDistributionMapper","algorithm","options","bucketCount","digitPosition","radix","value","positiveValue","abs","digit","pow","DistributionVisualizer","data","auxiliaryData","width","height","visualizationOptions","barWidth","spacing","bucketSpacing","bucketLabelHeight","countBarWidth","countBarSpacing","animationDuration","showLabels","colorScheme","backgroundColor","mainCanvasRef","auxiliaryCanvasRef","mainRenderer","setMainRenderer","auxRenderer","setAuxRenderer","animatedData","setAnimatedData","bucketData","setBucketData","countData","setCountData","currentDigit","setCurrentDigit","isRadixSort","isCountingSort","isBucketSort","current","renderer","background","setData","canvas","ctx","getContext","dispose","counts","buckets","undefined","renderAuxiliaryData","type","highlight","indices","array","countIndex","highlightIndex","clearRect","fillStyle","fillRect","renderCountArray","renderBuckets","totalBars","availableWidth","startX","maxBarHeight","font","textAlign","fillText","forEach","x","barHeight","y","fillColor","strokeStyle","lineWidth","strokeRect","toString","totalBuckets","maxBucketSize","map","bucket","bucketWidth","effectiveBarHeight","title","bucketIndex","bucketX","bucketY","bucketHeight","bucketColor","label","elementIndex","elementY","elementHeight","createElement","className","style","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","display","flexDirection","marginBottom","margin","fontSize","ref","border","borderRadius","padding","marginTop","message","propTypes","string","isRequired","arrayOf","number","shape","object"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/visualization/components/distribution-visualizer.js"],"sourcesContent":["// src/visualization/components/distribution-visualizer.js\n\n/**\n * @file Distribution Sort Visualizer Component\n * @author Algorithm Visualization Platform Team\n * @version 1.0.0\n * \n * @description\n * A specialized visualization component for distribution-based sorting algorithms\n * (Counting Sort, Radix Sort, Bucket Sort, Pigeonhole Sort).\n * \n * This component provides visualizations specific to the unique characteristics\n * of distribution sorts, including:\n * 1. Auxiliary data structures visualization (count arrays, buckets, digit groups)\n * 2. Distribution and collection phase animations\n * 3. Digit-by-digit processing for radix sorts\n * 4. Distribution range visualization\n * \n * The implementation follows principles of information visualization theory,\n * focusing on clear representation of algorithm-specific operations while\n * maintaining a cohesive and intuitive visual language.\n */\n\nimport React, { useRef, useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { WebGLRenderer } from '../renderers/webgl-renderer';\n\n/**\n * Color schemes specifically optimized for distribution algorithm visualization\n * @constant\n * @type {Object}\n * @private\n */\nconst DISTRIBUTION_COLOR_SCHEMES = {\n  // Color scheme for buckets - perceptually distinct colors\n  BUCKETS: [\n    '#4285F4', // Blue\n    '#EA4335', // Red\n    '#FBBC05', // Yellow\n    '#34A853', // Green\n    '#8B43EE', // Purple\n    '#F57C00', // Orange\n    '#0097A7', // Teal\n    '#757575', // Gray\n    '#9C27B0', // Magenta\n    '#3949AB', // Indigo\n    '#039BE5', // Light Blue\n    '#7CB342', // Light Green\n    '#C2185B', // Pink\n    '#FF5722', // Deep Orange\n    '#00BCD4', // Cyan\n    '#FFA000', // Amber\n  ],\n  \n  // Scientifically designed color scheme for count arrays - sequential blue\n  COUNTS: [\n    '#E3F2FD', '#BBDEFB', '#90CAF9', '#64B5F6', \n    '#42A5F5', '#2196F3', '#1E88E5', '#1976D2', \n    '#1565C0', '#0D47A1'\n  ],\n  \n  // Color scheme for digit positions in radix sort - categorical\n  DIGITS: [\n    '#C8E6C9', // Light Green\n    '#B3E5FC', // Light Blue\n    '#FFCCBC', // Light Orange\n    '#D1C4E9', // Light Purple\n    '#F8BBD0', // Light Pink\n  ],\n  \n  // Grayscale for the original array visualization\n  GRAYSCALE: ['#F5F5F5', '#E0E0E0', '#BDBDBD', '#9E9E9E', '#757575', '#616161', '#424242', '#212121'],\n};\n\n/**\n * Utility functions for distribution algorithm visualization\n * @namespace\n * @private\n */\nconst DistributionVisualizationUtils = {\n  /**\n   * Get a color for a bucket index using a consistent mapping\n   * @param {number} index - Bucket index\n   * @param {number} total - Total number of buckets\n   * @returns {string} Color in hex format\n   */\n  getBucketColor(index, total) {\n    const colors = DISTRIBUTION_COLOR_SCHEMES.BUCKETS;\n    // Use modulo to handle more buckets than colors\n    return colors[index % colors.length];\n  },\n  \n  /**\n   * Get a color for a count value\n   * @param {number} count - Count value\n   * @param {number} maxCount - Maximum count for normalization\n   * @returns {string} Color in hex format\n   */\n  getCountColor(count, maxCount) {\n    const normalizedValue = Math.min(Math.max(count / maxCount, 0), 1);\n    const index = Math.floor(normalizedValue * (DISTRIBUTION_COLOR_SCHEMES.COUNTS.length - 1));\n    return DISTRIBUTION_COLOR_SCHEMES.COUNTS[index];\n  },\n  \n  /**\n   * Get a color for a digit position in radix sort\n   * @param {number} position - Digit position\n   * @returns {string} Color in hex format\n   */\n  getDigitPositionColor(position) {\n    const colors = DISTRIBUTION_COLOR_SCHEMES.DIGITS;\n    return colors[position % colors.length];\n  },\n  \n  /**\n   * Convert a hex color to RGBA\n   * @param {string} hex - Hex color string\n   * @param {number} alpha - Alpha value\n   * @returns {Array<number>} RGBA array [r, g, b, a] with values in 0-1 range\n   */\n  hexToRgba(hex, alpha = 1) {\n    const r = parseInt(hex.slice(1, 3), 16) / 255;\n    const g = parseInt(hex.slice(3, 5), 16) / 255;\n    const b = parseInt(hex.slice(5, 7), 16) / 255;\n    return [r, g, b, alpha];\n  },\n  \n  /**\n   * Generate bucket labels based on range and count\n   * @param {number} min - Minimum value in range\n   * @param {number} max - Maximum value in range\n   * @param {number} count - Number of buckets\n   * @returns {Array<string>} Array of bucket labels\n   */\n  generateBucketLabels(min, max, count) {\n    const range = max - min;\n    const step = range / count;\n    \n    return Array.from({ length: count }, (_, i) => {\n      const lowerBound = min + i * step;\n      const upperBound = min + (i + 1) * step;\n      return `${Math.floor(lowerBound)}–${Math.ceil(upperBound) - 1}`;\n    });\n  },\n  \n  /**\n   * Create a distribution mapping function for a specific algorithm\n   * @param {string} algorithm - Algorithm type ('counting', 'radix', 'bucket', 'pigeonhole')\n   * @param {Object} options - Algorithm-specific options\n   * @returns {Function} Mapping function from value to bucket index\n   */\n  createDistributionMapper(algorithm, options) {\n    const { min = 0, max = 100, bucketCount = 10, digitPosition = 0, radix = 10 } = options;\n    \n    switch (algorithm) {\n      case 'counting':\n      case 'pigeonhole':\n        // Direct mapping based on value\n        return (value) => value - min;\n        \n      case 'bucket':\n        // Map to bucket based on range subdivision\n        const range = max - min;\n        return (value) => Math.min(bucketCount - 1, Math.floor(((value - min) / range) * bucketCount));\n        \n      case 'radix':\n        // Map based on digit at specified position\n        return (value) => {\n          // Extract the digit at the specified position\n          const positiveValue = Math.abs(value);\n          let digit;\n          \n          if (digitPosition === 0) {\n            // Least significant digit\n            digit = positiveValue % radix;\n          } else {\n            // Higher position digits\n            digit = Math.floor(positiveValue / Math.pow(radix, digitPosition)) % radix;\n          }\n          \n          return digit;\n        };\n        \n      default:\n        // Default identity mapping\n        return (value) => value;\n    }\n  }\n};\n\n/**\n * DistributionVisualizer Component\n * \n * A specialized React component for visualizing distribution-based sorting algorithms.\n * Renders both the array being sorted and the auxiliary data structures used in the sorting process.\n * \n * @component\n */\nconst DistributionVisualizer = ({\n  // Algorithm data\n  algorithm,\n  data,\n  auxiliaryData,\n  step,\n  \n  // Canvas dimensions\n  width = 800,\n  height = 500,\n  \n  // Visualization options\n  options = {}\n}) => {\n  // Merge default options\n  const visualizationOptions = {\n    barWidth: 4,\n    spacing: 1,\n    bucketSpacing: 20,\n    bucketLabelHeight: 20,\n    countBarWidth: 30,\n    countBarSpacing: 5,\n    animationDuration: 300,\n    showLabels: true,\n    colorScheme: 'spectrum',\n    backgroundColor: [0.1, 0.1, 0.15, 1.0],\n    ...options\n  };\n  \n  // Canvas references\n  const mainCanvasRef = useRef(null);\n  const auxiliaryCanvasRef = useRef(null);\n  \n  // State for rendering\n  const [mainRenderer, setMainRenderer] = useState(null);\n  const [auxRenderer, setAuxRenderer] = useState(null);\n  const [animatedData, setAnimatedData] = useState([]);\n  const [bucketData, setBucketData] = useState([]);\n  const [countData, setCountData] = useState([]);\n  const [currentDigit, setCurrentDigit] = useState(0);\n  \n  // Determine algorithm-specific properties\n  const isRadixSort = algorithm === 'radix-sort';\n  const isCountingSort = algorithm === 'counting-sort' || algorithm === 'pigeonhole-sort';\n  const isBucketSort = algorithm === 'bucket-sort';\n  \n  // Initialize renderers on mount\n  useEffect(() => {\n    // Initialize main array renderer\n    if (mainCanvasRef.current) {\n      const renderer = new WebGLRenderer(mainCanvasRef.current, {\n        barWidth: visualizationOptions.barWidth,\n        spacing: visualizationOptions.spacing,\n        colorScheme: visualizationOptions.colorScheme,\n        background: visualizationOptions.backgroundColor,\n        animationDuration: visualizationOptions.animationDuration\n      });\n      \n      setMainRenderer(renderer);\n      \n      if (data && data.length > 0) {\n        renderer.setData(data);\n      }\n    }\n    \n    // Initialize auxiliary visualization renderer\n    if (auxiliaryCanvasRef.current) {\n      // For auxiliary structures, we use a 2D canvas for more flexibility\n      const canvas = auxiliaryCanvasRef.current;\n      const ctx = canvas.getContext('2d');\n      \n      // Store the context in a renderer-like object for consistency\n      setAuxRenderer({ ctx, canvas });\n    }\n    \n    // Cleanup function\n    return () => {\n      if (mainRenderer) {\n        mainRenderer.dispose();\n      }\n    };\n  }, []);\n  \n  // Update data when it changes\n  useEffect(() => {\n    if (mainRenderer && data && data.length > 0) {\n      mainRenderer.setData(data);\n      setAnimatedData([...data]);\n    }\n  }, [data]);\n  \n  // Update auxiliary data visualization when it changes\n  useEffect(() => {\n    if (!auxiliaryData) return;\n    \n    if (isCountingSort && auxiliaryData.counts) {\n      setCountData(auxiliaryData.counts);\n    } else if (isBucketSort && auxiliaryData.buckets) {\n      setBucketData(auxiliaryData.buckets);\n    } else if (isRadixSort) {\n      if (auxiliaryData.currentDigit !== undefined) {\n        setCurrentDigit(auxiliaryData.currentDigit);\n      }\n      if (auxiliaryData.buckets) {\n        setBucketData(auxiliaryData.buckets);\n      }\n    }\n    \n    // Render the auxiliary data\n    renderAuxiliaryData();\n  }, [auxiliaryData, auxRenderer]);\n  \n  // Update visualization based on the current step\n  useEffect(() => {\n    if (!step || !mainRenderer) return;\n    \n    // Apply step-specific visualization\n    if (step.type === 'distribution') {\n      // Highlight elements being distributed\n      mainRenderer.highlight(step.indices || []);\n      \n      // Update bucket or count visualization\n      renderAuxiliaryData();\n    } else if (step.type === 'collection') {\n      // Highlight elements being collected back\n      mainRenderer.highlight(step.indices || []);\n      \n      // Update main array with collected elements\n      if (step.array) {\n        mainRenderer.setData(step.array, false);\n      }\n    } else if (step.type === 'counting') {\n      // Highlight the element being counted\n      mainRenderer.highlight([step.index]);\n      \n      // Highlight the corresponding count\n      renderAuxiliaryData(step.countIndex);\n    } else if (step.type === 'digit-extraction') {\n      // For radix sort, highlight the element and its current digit\n      mainRenderer.highlight([step.index]);\n      setCurrentDigit(step.digitPosition);\n    }\n  }, [step, mainRenderer]);\n  \n  /**\n   * Render auxiliary data structures (buckets, counts, etc.)\n   * @param {number} [highlightIndex] - Optional index to highlight\n   */\n  const renderAuxiliaryData = (highlightIndex) => {\n    if (!auxRenderer || !auxRenderer.ctx) return;\n    \n    const { ctx, canvas } = auxRenderer;\n    const width = canvas.width;\n    const height = canvas.height;\n    \n    // Clear the canvas\n    ctx.clearRect(0, 0, width, height);\n    ctx.fillStyle = 'rgb(24, 24, 36)'; // Dark background\n    ctx.fillRect(0, 0, width, height);\n    \n    // Render based on algorithm type\n    if (isCountingSort && countData && countData.length > 0) {\n      renderCountArray(ctx, countData, width, height, highlightIndex);\n    } else if ((isBucketSort || isRadixSort) && bucketData && bucketData.length > 0) {\n      renderBuckets(ctx, bucketData, width, height, highlightIndex);\n    }\n  };\n  \n  /**\n   * Render the count array for Counting Sort or Pigeonhole Sort\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\n   * @param {Array<number>} counts - Count array\n   * @param {number} width - Canvas width\n   * @param {number} height - Canvas height\n   * @param {number} [highlightIndex] - Optional index to highlight\n   * @private\n   */\n  const renderCountArray = (ctx, counts, width, height, highlightIndex) => {\n    const { countBarWidth, countBarSpacing, showLabels } = visualizationOptions;\n    \n    // Calculate dimensions\n    const maxCount = Math.max(...counts, 1);\n    const totalBars = counts.length;\n    const availableWidth = width - 40; // Padding\n    const barWidth = Math.min(countBarWidth, availableWidth / totalBars - countBarSpacing);\n    const startX = (width - (barWidth + countBarSpacing) * totalBars) / 2;\n    const maxBarHeight = height - 60; // Leave room for labels\n    \n    // Title\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 16px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('Count Array', width / 2, 25);\n    \n    // Draw count bars\n    counts.forEach((count, i) => {\n      const x = startX + i * (barWidth + countBarSpacing);\n      const barHeight = (count / maxCount) * maxBarHeight;\n      const y = height - 30 - barHeight; // Bottom-aligned\n      \n      // Determine color\n      let fillColor = DistributionVisualizationUtils.getCountColor(count, maxCount);\n      \n      // Highlight specific count if requested\n      if (highlightIndex !== undefined && i === highlightIndex) {\n        fillColor = '#FFEB3B'; // Yellow highlight\n        \n        // Draw highlight effect\n        ctx.fillStyle = 'rgba(255, 235, 59, 0.3)';\n        ctx.fillRect(x - 5, y - 5, barWidth + 10, barHeight + 10);\n      }\n      \n      // Draw bar\n      ctx.fillStyle = fillColor;\n      ctx.fillRect(x, y, barWidth, barHeight);\n      \n      // Draw border\n      ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(x, y, barWidth, barHeight);\n      \n      // Draw count value\n      ctx.fillStyle = 'black';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(count.toString(), x + barWidth / 2, y - 5);\n      \n      // Draw index labels\n      if (showLabels) {\n        ctx.fillStyle = 'white';\n        ctx.fillText(i.toString(), x + barWidth / 2, height - 10);\n      }\n    });\n  };\n  \n  /**\n   * Render buckets for Bucket Sort or Radix Sort\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\n   * @param {Array<Array>} buckets - Array of bucket contents\n   * @param {number} width - Canvas width\n   * @param {number} height - Canvas height\n   * @param {number} [highlightIndex] - Optional bucket index to highlight\n   * @private\n   */\n  const renderBuckets = (ctx, buckets, width, height, highlightIndex) => {\n    const { barWidth, spacing, bucketSpacing, bucketLabelHeight, showLabels } = visualizationOptions;\n    \n    // Calculate dimensions\n    const totalBuckets = buckets.length;\n    const maxBucketSize = Math.max(...buckets.map(bucket => bucket.length), 1);\n    const availableWidth = width - 40; // Padding\n    const bucketWidth = availableWidth / totalBuckets - bucketSpacing;\n    \n    // Calculate maximum bar height\n    const maxBarHeight = (height - 60 - bucketLabelHeight) / maxBucketSize;\n    const effectiveBarHeight = Math.min(25, maxBarHeight);\n    \n    // Title\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 16px Arial';\n    ctx.textAlign = 'center';\n    \n    const title = isRadixSort \n      ? `Radix Sort - Digit Position: ${currentDigit}` \n      : 'Bucket Distribution';\n    ctx.fillText(title, width / 2, 25);\n    \n    // Draw buckets\n    buckets.forEach((bucket, bucketIndex) => {\n      const bucketX = 20 + bucketIndex * (bucketWidth + bucketSpacing);\n      const bucketY = 40;\n      const bucketHeight = height - bucketY - 20;\n      \n      // Determine bucket color\n      const bucketColor = DistributionVisualizationUtils.getBucketColor(bucketIndex, totalBuckets);\n      \n      // Highlight specific bucket if requested\n      if (highlightIndex !== undefined && bucketIndex === highlightIndex) {\n        // Draw highlight effect around bucket\n        ctx.fillStyle = 'rgba(255, 235, 59, 0.2)';\n        ctx.fillRect(bucketX - 5, bucketY - 5, bucketWidth + 10, bucketHeight + 10);\n      }\n      \n      // Draw bucket container\n      ctx.fillStyle = 'rgba(30, 30, 45, 0.8)';\n      ctx.fillRect(bucketX, bucketY, bucketWidth, bucketHeight);\n      \n      // Draw bucket border\n      ctx.strokeStyle = bucketColor;\n      ctx.lineWidth = 2;\n      ctx.strokeRect(bucketX, bucketY, bucketWidth, bucketHeight);\n      \n      // Draw bucket label\n      if (showLabels) {\n        ctx.fillStyle = bucketColor;\n        ctx.font = '14px Arial';\n        ctx.textAlign = 'center';\n        \n        let label;\n        if (isRadixSort) {\n          label = `Digit: ${bucketIndex}`;\n        } else {\n          label = `Bucket ${bucketIndex}`;\n        }\n        \n        ctx.fillText(label, bucketX + bucketWidth / 2, bucketY + 20);\n      }\n      \n      // Draw bucket elements\n      bucket.forEach((value, elementIndex) => {\n        const elementY = bucketY + 30 + elementIndex * (effectiveBarHeight + 2);\n        const elementHeight = effectiveBarHeight;\n        \n        // Draw element bar\n        ctx.fillStyle = bucketColor;\n        ctx.fillRect(bucketX + 10, elementY, bucketWidth - 20, elementHeight);\n        \n        // Draw element value\n        ctx.fillStyle = 'white';\n        ctx.font = '12px Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText(value.toString(), bucketX + bucketWidth / 2, elementY + elementHeight / 2 + 4);\n      });\n      \n      // Draw bucket size\n      ctx.fillStyle = 'white';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'right';\n      ctx.fillText(`Size: ${bucket.length}`, bucketX + bucketWidth - 10, bucketY + bucketHeight - 10);\n    });\n  };\n  \n  return (\n    <div className=\"distribution-visualizer\" style={{ width, height: height + 50 }}>\n      <div className=\"visualization-container\" style={{ display: 'flex', flexDirection: 'column' }}>\n        <div className=\"main-array-container\" style={{ marginBottom: '20px' }}>\n          <h3 className=\"visualization-title\" style={{ margin: '0 0 10px 0', fontSize: '16px' }}>\n            Main Array\n          </h3>\n          <canvas\n            ref={mainCanvasRef}\n            width={width}\n            height={height / 2 - 30}\n            className=\"main-canvas\"\n            style={{ border: '1px solid #2d3748', borderRadius: '4px' }}\n          />\n        </div>\n        \n        <div className=\"auxiliary-container\">\n          <h3 className=\"visualization-title\" style={{ margin: '0 0 10px 0', fontSize: '16px' }}>\n            {isCountingSort \n              ? 'Count Array' \n              : isRadixSort \n                ? `Digit Buckets (Position: ${currentDigit})` \n                : 'Buckets'}\n          </h3>\n          <canvas\n            ref={auxiliaryCanvasRef}\n            width={width}\n            height={height / 2 - 30}\n            className=\"auxiliary-canvas\"\n            style={{ border: '1px solid #2d3748', borderRadius: '4px' }}\n          />\n        </div>\n      </div>\n      \n      {step && (\n        <div className=\"step-description\" style={{ \n          padding: '10px', \n          background: '#f8fafc', \n          borderRadius: '4px',\n          marginTop: '10px',\n          fontSize: '14px'\n        }}>\n          <strong>Current Operation:</strong> {step.message || 'No description available'}\n        </div>\n      )}\n    </div>\n  );\n};\n\n// PropTypes for documentation and runtime type checking\nDistributionVisualizer.propTypes = {\n  /** The distribution algorithm being visualized ('counting-sort', 'radix-sort', 'bucket-sort', 'pigeonhole-sort') */\n  algorithm: PropTypes.string.isRequired,\n  \n  /** The current array data being sorted */\n  data: PropTypes.arrayOf(PropTypes.number).isRequired,\n  \n  /** Auxiliary data structures used by the algorithm */\n  auxiliaryData: PropTypes.shape({\n    /** Count array for counting sort */\n    counts: PropTypes.arrayOf(PropTypes.number),\n    \n    /** Buckets for bucket sort or radix sort */\n    buckets: PropTypes.arrayOf(PropTypes.array),\n    \n    /** Current digit position for radix sort */\n    currentDigit: PropTypes.number,\n    \n    /** Range information */\n    min: PropTypes.number,\n    max: PropTypes.number\n  }),\n  \n  /** Current algorithm step information */\n  step: PropTypes.shape({\n    /** Type of operation ('distribution', 'collection', 'counting', 'digit-extraction') */\n    type: PropTypes.string,\n    \n    /** Array indices involved in current operation */\n    indices: PropTypes.arrayOf(PropTypes.number),\n    \n    /** Description message */\n    message: PropTypes.string,\n    \n    /** Current array state if applicable */\n    array: PropTypes.arrayOf(PropTypes.number),\n    \n    /** Index being processed */\n    index: PropTypes.number,\n    \n    /** Count array index if applicable */\n    countIndex: PropTypes.number,\n    \n    /** Digit position for radix sort */\n    digitPosition: PropTypes.number\n  }),\n  \n  /** Canvas width in pixels */\n  width: PropTypes.number,\n  \n  /** Canvas height in pixels */\n  height: PropTypes.number,\n  \n  /** Visualization options */\n  options: PropTypes.object\n};\n\nexport default DistributionVisualizer;\n"],"mappings":";AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,KAAK,IAAIC,MAAM,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC1D,OAAOC,SAAS,MAAM,YAAY;AAClC,SAASC,aAAa,QAAQ,6BAA6B;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,0BAA0B,GAAG;EACjC;EACAC,OAAO,EAAE,CACP,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS,CAAE;EAAA,CACZ;EAED;EACAC,MAAM,EAAE,CACN,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAC1C,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAC1C,SAAS,EAAE,SAAS,CACrB;EAED;EACAC,MAAM,EAAE,CACN,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS;EAAE;EACX,SAAS,CAAE;EAAA,CACZ;EAED;EACAC,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS;AACpG,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,8BAA8B,GAAG;EACrC;AACF;AACA;AACA;AACA;AACA;EACEC,cAAcA,CAACC,KAAK,EAAEC,KAAK,EAAE;IAC3B,MAAMC,MAAM,GAAGT,0BAA0B,CAACC,OAAO;IACjD;IACA,OAAOQ,MAAM,CAACF,KAAK,GAAGE,MAAM,CAACC,MAAM,CAAC;EACtC,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAACC,KAAK,EAAEC,QAAQ,EAAE;IAC7B,MAAMC,eAAe,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAACL,KAAK,GAAGC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IAClE,MAAMN,KAAK,GAAGQ,IAAI,CAACG,KAAK,CAACJ,eAAe,IAAId,0BAA0B,CAACE,MAAM,CAACQ,MAAM,GAAG,CAAC,CAAC,CAAC;IAC1F,OAAOV,0BAA0B,CAACE,MAAM,CAACK,KAAK,CAAC;EACjD,CAAC;EAED;AACF;AACA;AACA;AACA;EACEY,qBAAqBA,CAACC,QAAQ,EAAE;IAC9B,MAAMX,MAAM,GAAGT,0BAA0B,CAACG,MAAM;IAChD,OAAOM,MAAM,CAACW,QAAQ,GAAGX,MAAM,CAACC,MAAM,CAAC;EACzC,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEW,SAASA,CAACC,GAAG,EAAEC,KAAK,GAAG,CAAC,EAAE;IACxB,MAAMC,CAAC,GAAGC,QAAQ,CAACH,GAAG,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG;IAC7C,MAAMC,CAAC,GAAGF,QAAQ,CAACH,GAAG,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG;IAC7C,MAAME,CAAC,GAAGH,QAAQ,CAACH,GAAG,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG;IAC7C,OAAO,CAACF,CAAC,EAAEG,CAAC,EAAEC,CAAC,EAAEL,KAAK,CAAC;EACzB,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEM,oBAAoBA,CAACb,GAAG,EAAEC,GAAG,EAAEL,KAAK,EAAE;IACpC,MAAMkB,KAAK,GAAGb,GAAG,GAAGD,GAAG;IACvB,MAAMe,IAAI,GAAGD,KAAK,GAAGlB,KAAK;IAE1B,OAAOoB,KAAK,CAACC,IAAI,CAAC;MAAEvB,MAAM,EAAEE;IAAM,CAAC,EAAE,CAACsB,CAAC,EAAEC,CAAC,KAAK;MAC7C,MAAMC,UAAU,GAAGpB,GAAG,GAAGmB,CAAC,GAAGJ,IAAI;MACjC,MAAMM,UAAU,GAAGrB,GAAG,GAAG,CAACmB,CAAC,GAAG,CAAC,IAAIJ,IAAI;MACvC,OAAO,GAAGhB,IAAI,CAACG,KAAK,CAACkB,UAAU,CAAC,IAAIrB,IAAI,CAACuB,IAAI,CAACD,UAAU,CAAC,GAAG,CAAC,EAAE;IACjE,CAAC,CAAC;EACJ,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEE,wBAAwBA,CAACC,SAAS,EAAEC,OAAO,EAAE;IAC3C,MAAM;MAAEzB,GAAG,GAAG,CAAC;MAAEC,GAAG,GAAG,GAAG;MAAEyB,WAAW,GAAG,EAAE;MAAEC,aAAa,GAAG,CAAC;MAAEC,KAAK,GAAG;IAAG,CAAC,GAAGH,OAAO;IAEvF,QAAQD,SAAS;MACf,KAAK,UAAU;MACf,KAAK,YAAY;QACf;QACA,OAAQK,KAAK,IAAKA,KAAK,GAAG7B,GAAG;MAE/B,KAAK,QAAQ;QACX;QACA,MAAMc,KAAK,GAAGb,GAAG,GAAGD,GAAG;QACvB,OAAQ6B,KAAK,IAAK9B,IAAI,CAACC,GAAG,CAAC0B,WAAW,GAAG,CAAC,EAAE3B,IAAI,CAACG,KAAK,CAAE,CAAC2B,KAAK,GAAG7B,GAAG,IAAIc,KAAK,GAAIY,WAAW,CAAC,CAAC;MAEhG,KAAK,OAAO;QACV;QACA,OAAQG,KAAK,IAAK;UAChB;UACA,MAAMC,aAAa,GAAG/B,IAAI,CAACgC,GAAG,CAACF,KAAK,CAAC;UACrC,IAAIG,KAAK;UAET,IAAIL,aAAa,KAAK,CAAC,EAAE;YACvB;YACAK,KAAK,GAAGF,aAAa,GAAGF,KAAK;UAC/B,CAAC,MAAM;YACL;YACAI,KAAK,GAAGjC,IAAI,CAACG,KAAK,CAAC4B,aAAa,GAAG/B,IAAI,CAACkC,GAAG,CAACL,KAAK,EAAED,aAAa,CAAC,CAAC,GAAGC,KAAK;UAC5E;UAEA,OAAOI,KAAK;QACd,CAAC;MAEH;QACE;QACA,OAAQH,KAAK,IAAKA,KAAK;IAC3B;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,sBAAsB,GAAGA,CAAC;EAC9B;EACAV,SAAS;EACTW,IAAI;EACJC,aAAa;EACbrB,IAAI;EAEJ;EACAsB,KAAK,GAAG,GAAG;EACXC,MAAM,GAAG,GAAG;EAEZ;EACAb,OAAO,GAAG,CAAC;AACb,CAAC,KAAK;EACJ;EACA,MAAMc,oBAAoB,GAAG;IAC3BC,QAAQ,EAAE,CAAC;IACXC,OAAO,EAAE,CAAC;IACVC,aAAa,EAAE,EAAE;IACjBC,iBAAiB,EAAE,EAAE;IACrBC,aAAa,EAAE,EAAE;IACjBC,eAAe,EAAE,CAAC;IAClBC,iBAAiB,EAAE,GAAG;IACtBC,UAAU,EAAE,IAAI;IAChBC,WAAW,EAAE,UAAU;IACvBC,eAAe,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,CAAC;IACtC,GAAGxB;EACL,CAAC;;EAED;EACA,MAAMyB,aAAa,GAAGvE,MAAM,CAAC,IAAI,CAAC;EAClC,MAAMwE,kBAAkB,GAAGxE,MAAM,CAAC,IAAI,CAAC;;EAEvC;EACA,MAAM,CAACyE,YAAY,EAAEC,eAAe,CAAC,GAAGzE,QAAQ,CAAC,IAAI,CAAC;EACtD,MAAM,CAAC0E,WAAW,EAAEC,cAAc,CAAC,GAAG3E,QAAQ,CAAC,IAAI,CAAC;EACpD,MAAM,CAAC4E,YAAY,EAAEC,eAAe,CAAC,GAAG7E,QAAQ,CAAC,EAAE,CAAC;EACpD,MAAM,CAAC8E,UAAU,EAAEC,aAAa,CAAC,GAAG/E,QAAQ,CAAC,EAAE,CAAC;EAChD,MAAM,CAACgF,SAAS,EAAEC,YAAY,CAAC,GAAGjF,QAAQ,CAAC,EAAE,CAAC;EAC9C,MAAM,CAACkF,YAAY,EAAEC,eAAe,CAAC,GAAGnF,QAAQ,CAAC,CAAC,CAAC;;EAEnD;EACA,MAAMoF,WAAW,GAAGxC,SAAS,KAAK,YAAY;EAC9C,MAAMyC,cAAc,GAAGzC,SAAS,KAAK,eAAe,IAAIA,SAAS,KAAK,iBAAiB;EACvF,MAAM0C,YAAY,GAAG1C,SAAS,KAAK,aAAa;;EAEhD;EACA3C,SAAS,CAAC,MAAM;IACd;IACA,IAAIqE,aAAa,CAACiB,OAAO,EAAE;MACzB,MAAMC,QAAQ,GAAG,IAAIrF,aAAa,CAACmE,aAAa,CAACiB,OAAO,EAAE;QACxD3B,QAAQ,EAAED,oBAAoB,CAACC,QAAQ;QACvCC,OAAO,EAAEF,oBAAoB,CAACE,OAAO;QACrCO,WAAW,EAAET,oBAAoB,CAACS,WAAW;QAC7CqB,UAAU,EAAE9B,oBAAoB,CAACU,eAAe;QAChDH,iBAAiB,EAAEP,oBAAoB,CAACO;MAC1C,CAAC,CAAC;MAEFO,eAAe,CAACe,QAAQ,CAAC;MAEzB,IAAIjC,IAAI,IAAIA,IAAI,CAACzC,MAAM,GAAG,CAAC,EAAE;QAC3B0E,QAAQ,CAACE,OAAO,CAACnC,IAAI,CAAC;MACxB;IACF;;IAEA;IACA,IAAIgB,kBAAkB,CAACgB,OAAO,EAAE;MAC9B;MACA,MAAMI,MAAM,GAAGpB,kBAAkB,CAACgB,OAAO;MACzC,MAAMK,GAAG,GAAGD,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;;MAEnC;MACAlB,cAAc,CAAC;QAAEiB,GAAG;QAAED;MAAO,CAAC,CAAC;IACjC;;IAEA;IACA,OAAO,MAAM;MACX,IAAInB,YAAY,EAAE;QAChBA,YAAY,CAACsB,OAAO,CAAC,CAAC;MACxB;IACF,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA7F,SAAS,CAAC,MAAM;IACd,IAAIuE,YAAY,IAAIjB,IAAI,IAAIA,IAAI,CAACzC,MAAM,GAAG,CAAC,EAAE;MAC3C0D,YAAY,CAACkB,OAAO,CAACnC,IAAI,CAAC;MAC1BsB,eAAe,CAAC,CAAC,GAAGtB,IAAI,CAAC,CAAC;IAC5B;EACF,CAAC,EAAE,CAACA,IAAI,CAAC,CAAC;;EAEV;EACAtD,SAAS,CAAC,MAAM;IACd,IAAI,CAACuD,aAAa,EAAE;IAEpB,IAAI6B,cAAc,IAAI7B,aAAa,CAACuC,MAAM,EAAE;MAC1Cd,YAAY,CAACzB,aAAa,CAACuC,MAAM,CAAC;IACpC,CAAC,MAAM,IAAIT,YAAY,IAAI9B,aAAa,CAACwC,OAAO,EAAE;MAChDjB,aAAa,CAACvB,aAAa,CAACwC,OAAO,CAAC;IACtC,CAAC,MAAM,IAAIZ,WAAW,EAAE;MACtB,IAAI5B,aAAa,CAAC0B,YAAY,KAAKe,SAAS,EAAE;QAC5Cd,eAAe,CAAC3B,aAAa,CAAC0B,YAAY,CAAC;MAC7C;MACA,IAAI1B,aAAa,CAACwC,OAAO,EAAE;QACzBjB,aAAa,CAACvB,aAAa,CAACwC,OAAO,CAAC;MACtC;IACF;;IAEA;IACAE,mBAAmB,CAAC,CAAC;EACvB,CAAC,EAAE,CAAC1C,aAAa,EAAEkB,WAAW,CAAC,CAAC;;EAEhC;EACAzE,SAAS,CAAC,MAAM;IACd,IAAI,CAACkC,IAAI,IAAI,CAACqC,YAAY,EAAE;;IAE5B;IACA,IAAIrC,IAAI,CAACgE,IAAI,KAAK,cAAc,EAAE;MAChC;MACA3B,YAAY,CAAC4B,SAAS,CAACjE,IAAI,CAACkE,OAAO,IAAI,EAAE,CAAC;;MAE1C;MACAH,mBAAmB,CAAC,CAAC;IACvB,CAAC,MAAM,IAAI/D,IAAI,CAACgE,IAAI,KAAK,YAAY,EAAE;MACrC;MACA3B,YAAY,CAAC4B,SAAS,CAACjE,IAAI,CAACkE,OAAO,IAAI,EAAE,CAAC;;MAE1C;MACA,IAAIlE,IAAI,CAACmE,KAAK,EAAE;QACd9B,YAAY,CAACkB,OAAO,CAACvD,IAAI,CAACmE,KAAK,EAAE,KAAK,CAAC;MACzC;IACF,CAAC,MAAM,IAAInE,IAAI,CAACgE,IAAI,KAAK,UAAU,EAAE;MACnC;MACA3B,YAAY,CAAC4B,SAAS,CAAC,CAACjE,IAAI,CAACxB,KAAK,CAAC,CAAC;;MAEpC;MACAuF,mBAAmB,CAAC/D,IAAI,CAACoE,UAAU,CAAC;IACtC,CAAC,MAAM,IAAIpE,IAAI,CAACgE,IAAI,KAAK,kBAAkB,EAAE;MAC3C;MACA3B,YAAY,CAAC4B,SAAS,CAAC,CAACjE,IAAI,CAACxB,KAAK,CAAC,CAAC;MACpCwE,eAAe,CAAChD,IAAI,CAACY,aAAa,CAAC;IACrC;EACF,CAAC,EAAE,CAACZ,IAAI,EAAEqC,YAAY,CAAC,CAAC;;EAExB;AACF;AACA;AACA;EACE,MAAM0B,mBAAmB,GAAIM,cAAc,IAAK;IAC9C,IAAI,CAAC9B,WAAW,IAAI,CAACA,WAAW,CAACkB,GAAG,EAAE;IAEtC,MAAM;MAAEA,GAAG;MAAED;IAAO,CAAC,GAAGjB,WAAW;IACnC,MAAMjB,KAAK,GAAGkC,MAAM,CAAClC,KAAK;IAC1B,MAAMC,MAAM,GAAGiC,MAAM,CAACjC,MAAM;;IAE5B;IACAkC,GAAG,CAACa,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEhD,KAAK,EAAEC,MAAM,CAAC;IAClCkC,GAAG,CAACc,SAAS,GAAG,iBAAiB,CAAC,CAAC;IACnCd,GAAG,CAACe,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAElD,KAAK,EAAEC,MAAM,CAAC;;IAEjC;IACA,IAAI2B,cAAc,IAAIL,SAAS,IAAIA,SAAS,CAAClE,MAAM,GAAG,CAAC,EAAE;MACvD8F,gBAAgB,CAAChB,GAAG,EAAEZ,SAAS,EAAEvB,KAAK,EAAEC,MAAM,EAAE8C,cAAc,CAAC;IACjE,CAAC,MAAM,IAAI,CAAClB,YAAY,IAAIF,WAAW,KAAKN,UAAU,IAAIA,UAAU,CAAChE,MAAM,GAAG,CAAC,EAAE;MAC/E+F,aAAa,CAACjB,GAAG,EAAEd,UAAU,EAAErB,KAAK,EAAEC,MAAM,EAAE8C,cAAc,CAAC;IAC/D;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMI,gBAAgB,GAAGA,CAAChB,GAAG,EAAEG,MAAM,EAAEtC,KAAK,EAAEC,MAAM,EAAE8C,cAAc,KAAK;IACvE,MAAM;MAAExC,aAAa;MAAEC,eAAe;MAAEE;IAAW,CAAC,GAAGR,oBAAoB;;IAE3E;IACA,MAAM1C,QAAQ,GAAGE,IAAI,CAACE,GAAG,CAAC,GAAG0E,MAAM,EAAE,CAAC,CAAC;IACvC,MAAMe,SAAS,GAAGf,MAAM,CAACjF,MAAM;IAC/B,MAAMiG,cAAc,GAAGtD,KAAK,GAAG,EAAE,CAAC,CAAC;IACnC,MAAMG,QAAQ,GAAGzC,IAAI,CAACC,GAAG,CAAC4C,aAAa,EAAE+C,cAAc,GAAGD,SAAS,GAAG7C,eAAe,CAAC;IACtF,MAAM+C,MAAM,GAAG,CAACvD,KAAK,GAAG,CAACG,QAAQ,GAAGK,eAAe,IAAI6C,SAAS,IAAI,CAAC;IACrE,MAAMG,YAAY,GAAGvD,MAAM,GAAG,EAAE,CAAC,CAAC;;IAElC;IACAkC,GAAG,CAACc,SAAS,GAAG,OAAO;IACvBd,GAAG,CAACsB,IAAI,GAAG,iBAAiB;IAC5BtB,GAAG,CAACuB,SAAS,GAAG,QAAQ;IACxBvB,GAAG,CAACwB,QAAQ,CAAC,aAAa,EAAE3D,KAAK,GAAG,CAAC,EAAE,EAAE,CAAC;;IAE1C;IACAsC,MAAM,CAACsB,OAAO,CAAC,CAACrG,KAAK,EAAEuB,CAAC,KAAK;MAC3B,MAAM+E,CAAC,GAAGN,MAAM,GAAGzE,CAAC,IAAIqB,QAAQ,GAAGK,eAAe,CAAC;MACnD,MAAMsD,SAAS,GAAIvG,KAAK,GAAGC,QAAQ,GAAIgG,YAAY;MACnD,MAAMO,CAAC,GAAG9D,MAAM,GAAG,EAAE,GAAG6D,SAAS,CAAC,CAAC;;MAEnC;MACA,IAAIE,SAAS,GAAGhH,8BAA8B,CAACM,aAAa,CAACC,KAAK,EAAEC,QAAQ,CAAC;;MAE7E;MACA,IAAIuF,cAAc,KAAKP,SAAS,IAAI1D,CAAC,KAAKiE,cAAc,EAAE;QACxDiB,SAAS,GAAG,SAAS,CAAC,CAAC;;QAEvB;QACA7B,GAAG,CAACc,SAAS,GAAG,yBAAyB;QACzCd,GAAG,CAACe,QAAQ,CAACW,CAAC,GAAG,CAAC,EAAEE,CAAC,GAAG,CAAC,EAAE5D,QAAQ,GAAG,EAAE,EAAE2D,SAAS,GAAG,EAAE,CAAC;MAC3D;;MAEA;MACA3B,GAAG,CAACc,SAAS,GAAGe,SAAS;MACzB7B,GAAG,CAACe,QAAQ,CAACW,CAAC,EAAEE,CAAC,EAAE5D,QAAQ,EAAE2D,SAAS,CAAC;;MAEvC;MACA3B,GAAG,CAAC8B,WAAW,GAAG,oBAAoB;MACtC9B,GAAG,CAAC+B,SAAS,GAAG,CAAC;MACjB/B,GAAG,CAACgC,UAAU,CAACN,CAAC,EAAEE,CAAC,EAAE5D,QAAQ,EAAE2D,SAAS,CAAC;;MAEzC;MACA3B,GAAG,CAACc,SAAS,GAAG,OAAO;MACvBd,GAAG,CAACsB,IAAI,GAAG,YAAY;MACvBtB,GAAG,CAACuB,SAAS,GAAG,QAAQ;MACxBvB,GAAG,CAACwB,QAAQ,CAACpG,KAAK,CAAC6G,QAAQ,CAAC,CAAC,EAAEP,CAAC,GAAG1D,QAAQ,GAAG,CAAC,EAAE4D,CAAC,GAAG,CAAC,CAAC;;MAEvD;MACA,IAAIrD,UAAU,EAAE;QACdyB,GAAG,CAACc,SAAS,GAAG,OAAO;QACvBd,GAAG,CAACwB,QAAQ,CAAC7E,CAAC,CAACsF,QAAQ,CAAC,CAAC,EAAEP,CAAC,GAAG1D,QAAQ,GAAG,CAAC,EAAEF,MAAM,GAAG,EAAE,CAAC;MAC3D;IACF,CAAC,CAAC;EACJ,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMmD,aAAa,GAAGA,CAACjB,GAAG,EAAEI,OAAO,EAAEvC,KAAK,EAAEC,MAAM,EAAE8C,cAAc,KAAK;IACrE,MAAM;MAAE5C,QAAQ;MAAEC,OAAO;MAAEC,aAAa;MAAEC,iBAAiB;MAAEI;IAAW,CAAC,GAAGR,oBAAoB;;IAEhG;IACA,MAAMmE,YAAY,GAAG9B,OAAO,CAAClF,MAAM;IACnC,MAAMiH,aAAa,GAAG5G,IAAI,CAACE,GAAG,CAAC,GAAG2E,OAAO,CAACgC,GAAG,CAACC,MAAM,IAAIA,MAAM,CAACnH,MAAM,CAAC,EAAE,CAAC,CAAC;IAC1E,MAAMiG,cAAc,GAAGtD,KAAK,GAAG,EAAE,CAAC,CAAC;IACnC,MAAMyE,WAAW,GAAGnB,cAAc,GAAGe,YAAY,GAAGhE,aAAa;;IAEjE;IACA,MAAMmD,YAAY,GAAG,CAACvD,MAAM,GAAG,EAAE,GAAGK,iBAAiB,IAAIgE,aAAa;IACtE,MAAMI,kBAAkB,GAAGhH,IAAI,CAACC,GAAG,CAAC,EAAE,EAAE6F,YAAY,CAAC;;IAErD;IACArB,GAAG,CAACc,SAAS,GAAG,OAAO;IACvBd,GAAG,CAACsB,IAAI,GAAG,iBAAiB;IAC5BtB,GAAG,CAACuB,SAAS,GAAG,QAAQ;IAExB,MAAMiB,KAAK,GAAGhD,WAAW,GACrB,gCAAgCF,YAAY,EAAE,GAC9C,qBAAqB;IACzBU,GAAG,CAACwB,QAAQ,CAACgB,KAAK,EAAE3E,KAAK,GAAG,CAAC,EAAE,EAAE,CAAC;;IAElC;IACAuC,OAAO,CAACqB,OAAO,CAAC,CAACY,MAAM,EAAEI,WAAW,KAAK;MACvC,MAAMC,OAAO,GAAG,EAAE,GAAGD,WAAW,IAAIH,WAAW,GAAGpE,aAAa,CAAC;MAChE,MAAMyE,OAAO,GAAG,EAAE;MAClB,MAAMC,YAAY,GAAG9E,MAAM,GAAG6E,OAAO,GAAG,EAAE;;MAE1C;MACA,MAAME,WAAW,GAAGhI,8BAA8B,CAACC,cAAc,CAAC2H,WAAW,EAAEP,YAAY,CAAC;;MAE5F;MACA,IAAItB,cAAc,KAAKP,SAAS,IAAIoC,WAAW,KAAK7B,cAAc,EAAE;QAClE;QACAZ,GAAG,CAACc,SAAS,GAAG,yBAAyB;QACzCd,GAAG,CAACe,QAAQ,CAAC2B,OAAO,GAAG,CAAC,EAAEC,OAAO,GAAG,CAAC,EAAEL,WAAW,GAAG,EAAE,EAAEM,YAAY,GAAG,EAAE,CAAC;MAC7E;;MAEA;MACA5C,GAAG,CAACc,SAAS,GAAG,uBAAuB;MACvCd,GAAG,CAACe,QAAQ,CAAC2B,OAAO,EAAEC,OAAO,EAAEL,WAAW,EAAEM,YAAY,CAAC;;MAEzD;MACA5C,GAAG,CAAC8B,WAAW,GAAGe,WAAW;MAC7B7C,GAAG,CAAC+B,SAAS,GAAG,CAAC;MACjB/B,GAAG,CAACgC,UAAU,CAACU,OAAO,EAAEC,OAAO,EAAEL,WAAW,EAAEM,YAAY,CAAC;;MAE3D;MACA,IAAIrE,UAAU,EAAE;QACdyB,GAAG,CAACc,SAAS,GAAG+B,WAAW;QAC3B7C,GAAG,CAACsB,IAAI,GAAG,YAAY;QACvBtB,GAAG,CAACuB,SAAS,GAAG,QAAQ;QAExB,IAAIuB,KAAK;QACT,IAAItD,WAAW,EAAE;UACfsD,KAAK,GAAG,UAAUL,WAAW,EAAE;QACjC,CAAC,MAAM;UACLK,KAAK,GAAG,UAAUL,WAAW,EAAE;QACjC;QAEAzC,GAAG,CAACwB,QAAQ,CAACsB,KAAK,EAAEJ,OAAO,GAAGJ,WAAW,GAAG,CAAC,EAAEK,OAAO,GAAG,EAAE,CAAC;MAC9D;;MAEA;MACAN,MAAM,CAACZ,OAAO,CAAC,CAACpE,KAAK,EAAE0F,YAAY,KAAK;QACtC,MAAMC,QAAQ,GAAGL,OAAO,GAAG,EAAE,GAAGI,YAAY,IAAIR,kBAAkB,GAAG,CAAC,CAAC;QACvE,MAAMU,aAAa,GAAGV,kBAAkB;;QAExC;QACAvC,GAAG,CAACc,SAAS,GAAG+B,WAAW;QAC3B7C,GAAG,CAACe,QAAQ,CAAC2B,OAAO,GAAG,EAAE,EAAEM,QAAQ,EAAEV,WAAW,GAAG,EAAE,EAAEW,aAAa,CAAC;;QAErE;QACAjD,GAAG,CAACc,SAAS,GAAG,OAAO;QACvBd,GAAG,CAACsB,IAAI,GAAG,YAAY;QACvBtB,GAAG,CAACuB,SAAS,GAAG,QAAQ;QACxBvB,GAAG,CAACwB,QAAQ,CAACnE,KAAK,CAAC4E,QAAQ,CAAC,CAAC,EAAES,OAAO,GAAGJ,WAAW,GAAG,CAAC,EAAEU,QAAQ,GAAGC,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC;MAC7F,CAAC,CAAC;;MAEF;MACAjD,GAAG,CAACc,SAAS,GAAG,OAAO;MACvBd,GAAG,CAACsB,IAAI,GAAG,YAAY;MACvBtB,GAAG,CAACuB,SAAS,GAAG,OAAO;MACvBvB,GAAG,CAACwB,QAAQ,CAAC,SAASa,MAAM,CAACnH,MAAM,EAAE,EAAEwH,OAAO,GAAGJ,WAAW,GAAG,EAAE,EAAEK,OAAO,GAAGC,YAAY,GAAG,EAAE,CAAC;IACjG,CAAC,CAAC;EACJ,CAAC;EAED,oBACE1I,KAAA,CAAAgJ,aAAA;IAAKC,SAAS,EAAC,yBAAyB;IAACC,KAAK,EAAE;MAAEvF,KAAK;MAAEC,MAAM,EAAEA,MAAM,GAAG;IAAG,CAAE;IAAAuF,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,gBAC7ExJ,KAAA,CAAAgJ,aAAA;IAAKC,SAAS,EAAC,yBAAyB;IAACC,KAAK,EAAE;MAAEO,OAAO,EAAE,MAAM;MAAEC,aAAa,EAAE;IAAS,CAAE;IAAAP,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,gBAC3FxJ,KAAA,CAAAgJ,aAAA;IAAKC,SAAS,EAAC,sBAAsB;IAACC,KAAK,EAAE;MAAES,YAAY,EAAE;IAAO,CAAE;IAAAR,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,gBACpExJ,KAAA,CAAAgJ,aAAA;IAAIC,SAAS,EAAC,qBAAqB;IAACC,KAAK,EAAE;MAAEU,MAAM,EAAE,YAAY;MAAEC,QAAQ,EAAE;IAAO,CAAE;IAAAV,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,GAAC,YAEnF,CAAC,eACLxJ,KAAA,CAAAgJ,aAAA;IACEc,GAAG,EAAEtF,aAAc;IACnBb,KAAK,EAAEA,KAAM;IACbC,MAAM,EAAEA,MAAM,GAAG,CAAC,GAAG,EAAG;IACxBqF,SAAS,EAAC,aAAa;IACvBC,KAAK,EAAE;MAAEa,MAAM,EAAE,mBAAmB;MAAEC,YAAY,EAAE;IAAM,CAAE;IAAAb,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,CAC7D,CACE,CAAC,eAENxJ,KAAA,CAAAgJ,aAAA;IAAKC,SAAS,EAAC,qBAAqB;IAAAE,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,gBAClCxJ,KAAA,CAAAgJ,aAAA;IAAIC,SAAS,EAAC,qBAAqB;IAACC,KAAK,EAAE;MAAEU,MAAM,EAAE,YAAY;MAAEC,QAAQ,EAAE;IAAO,CAAE;IAAAV,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,GACnFjE,cAAc,GACX,aAAa,GACbD,WAAW,GACT,4BAA4BF,YAAY,GAAG,GAC3C,SACJ,CAAC,eACLpF,KAAA,CAAAgJ,aAAA;IACEc,GAAG,EAAErF,kBAAmB;IACxBd,KAAK,EAAEA,KAAM;IACbC,MAAM,EAAEA,MAAM,GAAG,CAAC,GAAG,EAAG;IACxBqF,SAAS,EAAC,kBAAkB;IAC5BC,KAAK,EAAE;MAAEa,MAAM,EAAE,mBAAmB;MAAEC,YAAY,EAAE;IAAM,CAAE;IAAAb,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,CAC7D,CACE,CACF,CAAC,EAELnH,IAAI,iBACHrC,KAAA,CAAAgJ,aAAA;IAAKC,SAAS,EAAC,kBAAkB;IAACC,KAAK,EAAE;MACvCe,OAAO,EAAE,MAAM;MACftE,UAAU,EAAE,SAAS;MACrBqE,YAAY,EAAE,KAAK;MACnBE,SAAS,EAAE,MAAM;MACjBL,QAAQ,EAAE;IACZ,CAAE;IAAAV,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,gBACAxJ,KAAA,CAAAgJ,aAAA;IAAAG,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,GAAQ,oBAA0B,CAAC,KAAC,EAACnH,IAAI,CAAC8H,OAAO,IAAI,0BAClD,CAEJ,CAAC;AAEV,CAAC;;AAED;AACA3G,sBAAsB,CAAC4G,SAAS,GAAG;EACjC;EACAtH,SAAS,EAAE1C,SAAS,CAACiK,MAAM,CAACC,UAAU;EAEtC;EACA7G,IAAI,EAAErD,SAAS,CAACmK,OAAO,CAACnK,SAAS,CAACoK,MAAM,CAAC,CAACF,UAAU;EAEpD;EACA5G,aAAa,EAAEtD,SAAS,CAACqK,KAAK,CAAC;IAC7B;IACAxE,MAAM,EAAE7F,SAAS,CAACmK,OAAO,CAACnK,SAAS,CAACoK,MAAM,CAAC;IAE3C;IACAtE,OAAO,EAAE9F,SAAS,CAACmK,OAAO,CAACnK,SAAS,CAACoG,KAAK,CAAC;IAE3C;IACApB,YAAY,EAAEhF,SAAS,CAACoK,MAAM;IAE9B;IACAlJ,GAAG,EAAElB,SAAS,CAACoK,MAAM;IACrBjJ,GAAG,EAAEnB,SAAS,CAACoK;EACjB,CAAC,CAAC;EAEF;EACAnI,IAAI,EAAEjC,SAAS,CAACqK,KAAK,CAAC;IACpB;IACApE,IAAI,EAAEjG,SAAS,CAACiK,MAAM;IAEtB;IACA9D,OAAO,EAAEnG,SAAS,CAACmK,OAAO,CAACnK,SAAS,CAACoK,MAAM,CAAC;IAE5C;IACAL,OAAO,EAAE/J,SAAS,CAACiK,MAAM;IAEzB;IACA7D,KAAK,EAAEpG,SAAS,CAACmK,OAAO,CAACnK,SAAS,CAACoK,MAAM,CAAC;IAE1C;IACA3J,KAAK,EAAET,SAAS,CAACoK,MAAM;IAEvB;IACA/D,UAAU,EAAErG,SAAS,CAACoK,MAAM;IAE5B;IACAvH,aAAa,EAAE7C,SAAS,CAACoK;EAC3B,CAAC,CAAC;EAEF;EACA7G,KAAK,EAAEvD,SAAS,CAACoK,MAAM;EAEvB;EACA5G,MAAM,EAAExD,SAAS,CAACoK,MAAM;EAExB;EACAzH,OAAO,EAAE3C,SAAS,CAACsK;AACrB,CAAC;AAED,eAAelH,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"module"}