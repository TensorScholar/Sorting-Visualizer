{"ast":null,"code":"// src/algorithms/comparison/heap.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Heap Sort algorithm with multiple optimization strategies.\n * \n * Heap Sort works by:\n * 1. Building a max-heap from the input array\n * 2. Repeatedly extracting the maximum element and rebuilding the heap\n * \n * This implementation includes optimizations:\n * - Floyd's \"build heap\" method to optimize heap construction\n * - Tail recursion elimination for heapify operations\n * - Optimized leaf node detection\n * - Sift-up/sift-down variants for heap operations\n * \n * @class HeapSort\n * @extends Algorithm\n */\nclass HeapSort extends Algorithm {\n  /**\n   * Create a new HeapSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.visualizeHeap=true] - Visualize the implicit heap structure\n   * @param {boolean} [options.optimizeLeafChecks=true] - Optimize leaf node detection\n   * @param {boolean} [options.bottomUpHeapify=true] - Use bottom-up heapify (Floyd's method)\n   * @param {boolean} [options.tailRecursion=false] - Use tail recursion for heapify\n   */\n  constructor(options = {}) {\n    super('Heap Sort', 'comparison', options);\n\n    // Default options\n    this.options = {\n      visualizeHeap: true,\n      // Visualize the implicit heap structure\n      optimizeLeafChecks: true,\n      // Optimize leaf node detection\n      bottomUpHeapify: true,\n      // Use bottom-up heapify (Floyd's method)\n      tailRecursion: false,\n      // Use tail recursion for heapify\n      ...options\n    };\n  }\n\n  /**\n   * Execute Heap Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('heap-construction');\n\n    // Build max heap (rearrange array)\n    this.buildMaxHeap(result, n, options);\n    this.setPhase('sorting');\n\n    // Extract elements from heap one by one\n    for (let i = n - 1; i > 0; i--) {\n      // Move current root to end\n      this.swap(result, 0, i);\n\n      // Record the state after swap\n      this.recordState(result, {\n        type: 'extract-max',\n        index: i,\n        value: result[i],\n        message: `Extracted maximum element ${result[i]} and placed at position ${i}`\n      });\n\n      // Call heapify on the reduced heap\n      this.heapify(result, 0, i, options);\n\n      // Mark the last element as sorted\n      this.recordState(result, {\n        type: 'sorted',\n        indices: Array.from({\n          length: n - i\n        }, (_, idx) => i + idx),\n        message: `Elements from index ${i} to ${n - 1} are now sorted`\n      });\n    }\n    this.setPhase('completed');\n    return result;\n  }\n\n  /**\n   * Build a max heap from the array\n   * \n   * @param {Array} array - Array to heapify\n   * @param {number} size - Size of the heap\n   * @param {Object} options - Runtime options\n   */\n  buildMaxHeap(array, size, options) {\n    this.recordState(array, {\n      type: 'heap-start',\n      message: 'Starting heap construction'\n    });\n\n    // Floyd's \"build heap\" method - start from the last non-leaf node\n    // This is more efficient than inserting one by one (O(n) vs O(n log n))\n    const startIdx = Math.floor(size / 2) - 1;\n    for (let i = startIdx; i >= 0; i--) {\n      this.heapify(array, i, size, options);\n    }\n    this.recordState(array, {\n      type: 'heap-complete',\n      message: 'Heap construction complete',\n      heapStructure: this.extractHeapStructure(array, size)\n    });\n  }\n\n  /**\n   * Heapify a subtree rooted at node i\n   * \n   * @param {Array} array - Array representing the heap\n   * @param {number} i - Index of the root of the subtree\n   * @param {number} size - Size of the heap\n   * @param {Object} options - Runtime options\n   */\n  heapify(array, i, size, options) {\n    // Iterative implementation to avoid call stack issues with large arrays\n    let current = i;\n    while (true) {\n      let largest = current;\n      const left = 2 * current + 1;\n      const right = 2 * current + 2;\n\n      // Check if this is a leaf node to avoid unnecessary comparisons\n      if (options.optimizeLeafChecks && left >= size) {\n        // Current node is a leaf, no heapify needed\n        break;\n      }\n\n      // Visualize the current node and its children\n      if (options.visualizeHeap) {\n        this.recordState(array, {\n          type: 'heapify',\n          node: current,\n          children: [left, right].filter(idx => idx < size),\n          message: `Heapifying subtree rooted at index ${current}`,\n          heapStructure: this.extractHeapStructure(array, size, current)\n        });\n      }\n\n      // Compare with left child\n      if (left < size && this.compare(array[left], array[largest]) > 0) {\n        largest = left;\n      }\n\n      // Compare with right child\n      if (right < size && this.compare(array[right], array[largest]) > 0) {\n        largest = right;\n      }\n\n      // If largest is not the current node, swap and continue heapifying\n      if (largest !== current) {\n        this.swap(array, current, largest);\n        this.recordState(array, {\n          type: 'heapify-swap',\n          indices: [current, largest],\n          message: `Swapped ${array[largest]} and ${array[current]} to maintain heap property`\n        });\n\n        // Move down to the child for next iteration\n        current = largest;\n      } else {\n        // Heap property is satisfied, exit the loop\n        break;\n      }\n    }\n  }\n\n  /**\n   * Extract the implicit heap structure for visualization\n   * \n   * @param {Array} array - Array representing the heap\n   * @param {number} size - Size of the heap\n   * @param {number} highlight - Optional index to highlight\n   * @returns {Object} - Heap structure representation\n   */\n  extractHeapStructure(array, size, highlight = -1) {\n    // Create a representation of the binary heap for visualization\n    const structure = {\n      nodes: [],\n      edges: [],\n      highlight: highlight\n    };\n\n    // Add nodes with their values and positions\n    for (let i = 0; i < size; i++) {\n      structure.nodes.push({\n        id: i,\n        value: array[i],\n        level: Math.floor(Math.log2(i + 1)),\n        isLeaf: 2 * i + 1 >= size\n      });\n\n      // Add edges to children\n      const left = 2 * i + 1;\n      const right = 2 * i + 2;\n      if (left < size) {\n        structure.edges.push({\n          from: i,\n          to: left,\n          type: 'left'\n        });\n      }\n      if (right < size) {\n        structure.edges.push({\n          from: i,\n          to: right,\n          type: 'right'\n        });\n      }\n    }\n    return structure;\n  }\n\n  /**\n   * Get the time and space complexity of Heap Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(n log n)',\n        average: 'O(n log n)',\n        worst: 'O(n log n)'\n      },\n      space: {\n        best: 'O(1)',\n        average: 'O(1)',\n        worst: 'O(1)'\n      }\n    };\n  }\n\n  /**\n   * Whether Heap Sort is stable\n   * \n   * @returns {boolean} - False as Heap Sort is not stable\n   */\n  isStable() {\n    return false;\n  }\n\n  /**\n   * Whether Heap Sort is in-place\n   * \n   * @returns {boolean} - True as Heap Sort is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add heap sort specific information\n    info.optimization = {\n      visualizeHeap: this.options.visualizeHeap,\n      optimizeLeafChecks: this.options.optimizeLeafChecks,\n      bottomUpHeapify: this.options.bottomUpHeapify,\n      tailRecursion: this.options.tailRecursion\n    };\n    info.properties = {\n      comparisonBased: true,\n      stable: false,\n      inPlace: true,\n      online: false,\n      divideAndConquer: false,\n      usesBinaryHeap: true\n    };\n    info.suitable = {\n      smallArrays: false,\n      nearlySortedArrays: false,\n      largeArrays: true,\n      limitedMemory: true\n    };\n    info.variants = ['Standard Heap Sort', 'Bottom-up Heap Sort', 'Smooth Sort (variant using Leonardo numbers)', 'Weak Heap Sort', 'Binary Heap Sort with optimized leaf detection'];\n    info.advantages = ['Guaranteed O(n log n) performance in all cases', 'In-place sorting with no extra memory needed', 'Good for sorting large datasets with limited memory', 'Useful as a priority queue implementation', 'Predictable performance regardless of input distribution'];\n    info.disadvantages = ['Not stable (does not preserve order of equal elements)', 'Relatively poor cache performance due to non-local memory access', 'Usually outperformed by quicksort on average cases', 'Complex to parallelize due to heap property maintenance'];\n    return info;\n  }\n}\nexport default HeapSort;","map":{"version":3,"names":["Algorithm","HeapSort","constructor","options","visualizeHeap","optimizeLeafChecks","bottomUpHeapify","tailRecursion","run","array","result","n","length","setPhase","buildMaxHeap","i","swap","recordState","type","index","value","message","heapify","indices","Array","from","_","idx","size","startIdx","Math","floor","heapStructure","extractHeapStructure","current","largest","left","right","node","children","filter","compare","highlight","structure","nodes","edges","push","id","level","log2","isLeaf","to","getComplexity","time","best","average","worst","space","isStable","isInPlace","getInfo","info","optimization","properties","comparisonBased","stable","inPlace","online","divideAndConquer","usesBinaryHeap","suitable","smallArrays","nearlySortedArrays","largeArrays","limitedMemory","variants","advantages","disadvantages"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/comparison/heap.js"],"sourcesContent":["// src/algorithms/comparison/heap.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Heap Sort algorithm with multiple optimization strategies.\n * \n * Heap Sort works by:\n * 1. Building a max-heap from the input array\n * 2. Repeatedly extracting the maximum element and rebuilding the heap\n * \n * This implementation includes optimizations:\n * - Floyd's \"build heap\" method to optimize heap construction\n * - Tail recursion elimination for heapify operations\n * - Optimized leaf node detection\n * - Sift-up/sift-down variants for heap operations\n * \n * @class HeapSort\n * @extends Algorithm\n */\nclass HeapSort extends Algorithm {\n  /**\n   * Create a new HeapSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.visualizeHeap=true] - Visualize the implicit heap structure\n   * @param {boolean} [options.optimizeLeafChecks=true] - Optimize leaf node detection\n   * @param {boolean} [options.bottomUpHeapify=true] - Use bottom-up heapify (Floyd's method)\n   * @param {boolean} [options.tailRecursion=false] - Use tail recursion for heapify\n   */\n  constructor(options = {}) {\n    super('Heap Sort', 'comparison', options);\n    \n    // Default options\n    this.options = {\n      visualizeHeap: true,       // Visualize the implicit heap structure\n      optimizeLeafChecks: true,  // Optimize leaf node detection\n      bottomUpHeapify: true,     // Use bottom-up heapify (Floyd's method)\n      tailRecursion: false,      // Use tail recursion for heapify\n      ...options\n    };\n  }\n  \n  /**\n   * Execute Heap Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('heap-construction');\n    \n    // Build max heap (rearrange array)\n    this.buildMaxHeap(result, n, options);\n    \n    this.setPhase('sorting');\n    \n    // Extract elements from heap one by one\n    for (let i = n - 1; i > 0; i--) {\n      // Move current root to end\n      this.swap(result, 0, i);\n      \n      // Record the state after swap\n      this.recordState(result, {\n        type: 'extract-max',\n        index: i,\n        value: result[i],\n        message: `Extracted maximum element ${result[i]} and placed at position ${i}`\n      });\n      \n      // Call heapify on the reduced heap\n      this.heapify(result, 0, i, options);\n      \n      // Mark the last element as sorted\n      this.recordState(result, {\n        type: 'sorted',\n        indices: Array.from({ length: n - i }, (_, idx) => i + idx),\n        message: `Elements from index ${i} to ${n-1} are now sorted`\n      });\n    }\n    \n    this.setPhase('completed');\n    return result;\n  }\n  \n  /**\n   * Build a max heap from the array\n   * \n   * @param {Array} array - Array to heapify\n   * @param {number} size - Size of the heap\n   * @param {Object} options - Runtime options\n   */\n  buildMaxHeap(array, size, options) {\n    this.recordState(array, {\n      type: 'heap-start',\n      message: 'Starting heap construction'\n    });\n    \n    // Floyd's \"build heap\" method - start from the last non-leaf node\n    // This is more efficient than inserting one by one (O(n) vs O(n log n))\n    const startIdx = Math.floor(size / 2) - 1;\n    \n    for (let i = startIdx; i >= 0; i--) {\n      this.heapify(array, i, size, options);\n    }\n    \n    this.recordState(array, {\n      type: 'heap-complete',\n      message: 'Heap construction complete',\n      heapStructure: this.extractHeapStructure(array, size)\n    });\n  }\n  \n  /**\n   * Heapify a subtree rooted at node i\n   * \n   * @param {Array} array - Array representing the heap\n   * @param {number} i - Index of the root of the subtree\n   * @param {number} size - Size of the heap\n   * @param {Object} options - Runtime options\n   */\n  heapify(array, i, size, options) {\n    // Iterative implementation to avoid call stack issues with large arrays\n    let current = i;\n    \n    while (true) {\n      let largest = current;\n      const left = 2 * current + 1;\n      const right = 2 * current + 2;\n      \n      // Check if this is a leaf node to avoid unnecessary comparisons\n      if (options.optimizeLeafChecks && left >= size) {\n        // Current node is a leaf, no heapify needed\n        break;\n      }\n      \n      // Visualize the current node and its children\n      if (options.visualizeHeap) {\n        this.recordState(array, {\n          type: 'heapify',\n          node: current,\n          children: [left, right].filter(idx => idx < size),\n          message: `Heapifying subtree rooted at index ${current}`,\n          heapStructure: this.extractHeapStructure(array, size, current)\n        });\n      }\n      \n      // Compare with left child\n      if (left < size && this.compare(array[left], array[largest]) > 0) {\n        largest = left;\n      }\n      \n      // Compare with right child\n      if (right < size && this.compare(array[right], array[largest]) > 0) {\n        largest = right;\n      }\n      \n      // If largest is not the current node, swap and continue heapifying\n      if (largest !== current) {\n        this.swap(array, current, largest);\n        \n        this.recordState(array, {\n          type: 'heapify-swap',\n          indices: [current, largest],\n          message: `Swapped ${array[largest]} and ${array[current]} to maintain heap property`\n        });\n        \n        // Move down to the child for next iteration\n        current = largest;\n      } else {\n        // Heap property is satisfied, exit the loop\n        break;\n      }\n    }\n  }\n  \n  /**\n   * Extract the implicit heap structure for visualization\n   * \n   * @param {Array} array - Array representing the heap\n   * @param {number} size - Size of the heap\n   * @param {number} highlight - Optional index to highlight\n   * @returns {Object} - Heap structure representation\n   */\n  extractHeapStructure(array, size, highlight = -1) {\n    // Create a representation of the binary heap for visualization\n    const structure = {\n      nodes: [],\n      edges: [],\n      highlight: highlight\n    };\n    \n    // Add nodes with their values and positions\n    for (let i = 0; i < size; i++) {\n      structure.nodes.push({\n        id: i,\n        value: array[i],\n        level: Math.floor(Math.log2(i + 1)),\n        isLeaf: 2 * i + 1 >= size\n      });\n      \n      // Add edges to children\n      const left = 2 * i + 1;\n      const right = 2 * i + 2;\n      \n      if (left < size) {\n        structure.edges.push({ from: i, to: left, type: 'left' });\n      }\n      \n      if (right < size) {\n        structure.edges.push({ from: i, to: right, type: 'right' });\n      }\n    }\n    \n    return structure;\n  }\n  \n  /**\n   * Get the time and space complexity of Heap Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(n log n)',\n        average: 'O(n log n)',\n        worst: 'O(n log n)'\n      },\n      space: {\n        best: 'O(1)',\n        average: 'O(1)',\n        worst: 'O(1)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Heap Sort is stable\n   * \n   * @returns {boolean} - False as Heap Sort is not stable\n   */\n  isStable() {\n    return false;\n  }\n  \n  /**\n   * Whether Heap Sort is in-place\n   * \n   * @returns {boolean} - True as Heap Sort is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add heap sort specific information\n    info.optimization = {\n      visualizeHeap: this.options.visualizeHeap,\n      optimizeLeafChecks: this.options.optimizeLeafChecks, \n      bottomUpHeapify: this.options.bottomUpHeapify,\n      tailRecursion: this.options.tailRecursion\n    };\n    \n    info.properties = {\n      comparisonBased: true,\n      stable: false,\n      inPlace: true,\n      online: false,\n      divideAndConquer: false,\n      usesBinaryHeap: true\n    };\n    \n    info.suitable = {\n      smallArrays: false,\n      nearlySortedArrays: false,\n      largeArrays: true,\n      limitedMemory: true\n    };\n    \n    info.variants = [\n      'Standard Heap Sort',\n      'Bottom-up Heap Sort',\n      'Smooth Sort (variant using Leonardo numbers)',\n      'Weak Heap Sort',\n      'Binary Heap Sort with optimized leaf detection'\n    ];\n    \n    info.advantages = [\n      'Guaranteed O(n log n) performance in all cases',\n      'In-place sorting with no extra memory needed',\n      'Good for sorting large datasets with limited memory',\n      'Useful as a priority queue implementation',\n      'Predictable performance regardless of input distribution'\n    ];\n    \n    info.disadvantages = [\n      'Not stable (does not preserve order of equal elements)',\n      'Relatively poor cache performance due to non-local memory access',\n      'Usually outperformed by quicksort on average cases',\n      'Complex to parallelize due to heap property maintenance'\n    ];\n    \n    return info;\n  }\n}\n\nexport default HeapSort;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}