{"ast":null,"code":"/**\n * @file algorithm-base.js\n * @module algorithms/core\n * @description Foundational abstract base class for all algorithmic implementations in the\n * visualization platform. Provides a standardized interface, comprehensive instrumentation,\n * and robust state management for algorithm execution and analysis.\n * @author Advanced Sorting Algorithm Visualization Platform Team\n * @copyright 2025\n */\n\n/**\n * Abstract base class for all algorithms in the visualization platform.\n * Implements the Template Method design pattern, defining the skeleton of\n * algorithmic operations while allowing subclasses to override specific steps.\n * \n * This architecture ensures consistent instrumentation, state tracking, and\n * visualization capabilities across all algorithm implementations while\n * maintaining separation of concerns between the algorithm logic and its\n * performance measurement.\n * \n * @abstract\n * @class Algorithm\n */\nclass Algorithm {\n  /**\n   * Creates a new Algorithm instance with the specified parameters.\n   * \n   * @param {string} name - Human-readable algorithm name\n   * @param {string} category - Algorithmic classification category\n   * @param {Object} [options={}] - Configuration options for the algorithm\n   * @throws {TypeError} If name or category are not provided\n   */\n  constructor(name, category, options = {}) {\n    // Parameter validation\n    if (!name || typeof name !== 'string') {\n      throw new TypeError('Algorithm name must be a non-empty string');\n    }\n    if (!category || typeof category !== 'string') {\n      throw new TypeError('Algorithm category must be a non-empty string');\n    }\n    if (this.constructor === Algorithm) {\n      throw new TypeError('Cannot instantiate abstract Algorithm class directly');\n    }\n\n    // Basic information\n    this.name = name;\n    this.category = category;\n\n    // Default options with override support\n    this.options = {\n      trackMemoryAccess: true,\n      // Track memory access operations\n      trackOperations: true,\n      // Track algorithmic operations\n      recordHistory: true,\n      // Record state history for visualization\n      animationSpeed: 1,\n      // Animation playback speed multiplier\n      ...options // Override with provided options\n    };\n\n    // Initialize metrics tracking system\n    this.metrics = {\n      // Operation counts\n      comparisons: 0,\n      // Number of element comparisons\n      swaps: 0,\n      // Number of element swaps\n      reads: 0,\n      // Number of read operations\n      writes: 0,\n      // Number of write operations\n      memoryAccesses: 0,\n      // Total memory access operations (reads + writes)\n      recursiveCalls: 0,\n      // Number of recursive function calls\n\n      // Memory usage\n      auxiliarySpace: 0,\n      // Peak additional memory used (bytes)\n\n      // Performance timing\n      startTime: 0,\n      // Execution start timestamp (ms)\n      endTime: 0,\n      // Execution end timestamp (ms)\n      executionTime: 0,\n      // Total execution time (ms)\n\n      // Advanced metrics\n      branchMispredictions: 0,\n      // Estimated branch mispredictions\n      cacheEfficiency: {\n        // Cache efficiency simulation\n        hits: 0,\n        misses: 0,\n        hitRate: 0\n      }\n    };\n\n    // State history for visualization and analysis\n    this.history = []; // Array of algorithm states for visualization\n    this.currentStep = 0; // Current step in visualization playback\n\n    // Execution status flags\n    this.isRunning = false; // Whether algorithm is currently executing\n    this.isPaused = false; // Whether execution is paused (for step-by-step)\n    this.isComplete = false; // Whether execution has completed\n\n    // Event listener registry (Observer pattern)\n    this.eventListeners = {\n      step: [],\n      // Triggered on each visualization step\n      comparison: [],\n      // Triggered on element comparison\n      swap: [],\n      // Triggered on element swap\n      access: [],\n      // Triggered on memory access\n      complete: [],\n      // Triggered on execution completion\n      phase: [] // Triggered on algorithm phase change\n    };\n\n    // Current algorithm phase\n    this.currentPhase = 'initialization';\n  }\n\n  /**\n   * Resets the algorithm state and metrics to initial values.\n   * Used before each new execution to ensure clean state.\n   * \n   * @returns {Algorithm} The algorithm instance for method chaining\n   */\n  reset() {\n    // Reset all metrics\n    this.metrics = {\n      comparisons: 0,\n      swaps: 0,\n      reads: 0,\n      writes: 0,\n      memoryAccesses: 0,\n      recursiveCalls: 0,\n      auxiliarySpace: 0,\n      startTime: 0,\n      endTime: 0,\n      executionTime: 0,\n      branchMispredictions: 0,\n      cacheEfficiency: {\n        hits: 0,\n        misses: 0,\n        hitRate: 0\n      }\n    };\n\n    // Reset state\n    this.history = [];\n    this.currentStep = 0;\n    this.isRunning = false;\n    this.isPaused = false;\n    this.isComplete = false;\n    this.currentPhase = 'initialization';\n    return this;\n  }\n\n  /**\n   * Executes the algorithm on the provided input data.\n   * This is the main public interface for algorithm execution.\n   * Implements the Template Method pattern by defining the execution\n   * workflow while delegating specific algorithm logic to the run() method.\n   * \n   * @param {Array} array - The input array to process\n   * @param {Object} [options={}] - Runtime options that override instance options\n   * @returns {Array} The processed result array\n   * @throws {Error} If execution fails\n   */\n  execute(array, options = {}) {\n    try {\n      // Reset algorithm state before execution\n      this.reset();\n\n      // Merge instance options with runtime options\n      const mergedOptions = {\n        ...this.options,\n        ...options\n      };\n\n      // Set execution flags\n      this.isRunning = true;\n\n      // Start performance timer\n      this.metrics.startTime = performance.now();\n\n      // Create a defensive copy of the input array to avoid mutating the original\n      const arrayCopy = Array.isArray(array) ? [...array] : Array.from(array);\n\n      // Record initial state if history tracking is enabled\n      if (mergedOptions.recordHistory) {\n        this.recordState(arrayCopy, {\n          type: 'initial',\n          message: 'Initial array state'\n        });\n      }\n\n      // Execute the specific algorithm implementation (delegated to subclasses)\n      const result = this.run(arrayCopy, mergedOptions);\n\n      // Stop performance timer and calculate metrics\n      this.metrics.endTime = performance.now();\n      this.metrics.executionTime = this.metrics.endTime - this.metrics.startTime;\n\n      // Calculate cache efficiency ratio if applicable\n      const {\n        hits,\n        misses\n      } = this.metrics.cacheEfficiency;\n      if (hits > 0 || misses > 0) {\n        this.metrics.cacheEfficiency.hitRate = hits / (hits + misses);\n      }\n\n      // Update execution flags\n      this.isRunning = false;\n      this.isComplete = true;\n\n      // Record final state if history tracking is enabled\n      if (mergedOptions.recordHistory) {\n        this.recordState(result, {\n          type: 'final',\n          message: 'Final processed state'\n        });\n      }\n\n      // Emit execution completion event\n      this.emit('complete', {\n        metrics: this.metrics,\n        result\n      });\n      return result;\n    } catch (error) {\n      // Set error state\n      this.isRunning = false;\n      this.isComplete = false;\n\n      // Enhance error with algorithm context\n      const contextError = new Error(`Execution of ${this.name} algorithm failed: ${error.message}`);\n      contextError.originalError = error;\n      contextError.algorithmName = this.name;\n      contextError.algorithmCategory = this.category;\n\n      // Rethrow enhanced error\n      throw contextError;\n    }\n  }\n\n  /**\n   * Abstract method that implements the specific algorithm logic.\n   * Must be overridden by concrete algorithm subclasses.\n   * \n   * @abstract\n   * @param {Array} array - The input array to process\n   * @param {Object} options - Runtime options\n   * @returns {Array} The processed array\n   * @throws {Error} If not implemented by subclass\n   */\n  run(array, options) {\n    throw new Error(`Method run() must be implemented by ${this.name} algorithm subclass`);\n  }\n\n  /**\n   * Compare two elements with comprehensive instrumentation.\n   * Serves as a standard comparison operation for all algorithms.\n   * \n   * @param {*} a - First element\n   * @param {*} b - Second element\n   * @param {Function} [comparator=null] - Optional custom comparator function\n   * @returns {number} - Negative if a < b, 0 if a === b, positive if a > b\n   */\n  compare(a, b, comparator = null) {\n    // Increment comparison counter\n    this.metrics.comparisons++;\n\n    // Perform comparison\n    let result;\n    if (typeof comparator === 'function') {\n      // Use custom comparator if provided\n      result = comparator(a, b);\n    } else {\n      // Default comparison logic\n      result = a < b ? -1 : a > b ? 1 : 0;\n    }\n\n    // Simulate branch prediction\n    // In a real CPU, branch predictors work best when branches are consistent\n    // This is a simple model of misprediction for educational purposes\n    if (this.metrics.comparisons > 1) {\n      const lastComparisonResult = this._lastComparisonResult || 0;\n      if (Math.sign(lastComparisonResult) !== Math.sign(result)) {\n        this.metrics.branchMispredictions++;\n      }\n    }\n    this._lastComparisonResult = result;\n\n    // Emit comparison event\n    this.emit('comparison', {\n      a,\n      b,\n      result\n    });\n    return result;\n  }\n\n  /**\n   * Swap two elements in an array with comprehensive instrumentation.\n   * Serves as a standard swap operation for all algorithms.\n   * \n   * @param {Array} array - The array to modify\n   * @param {number} i - First index\n   * @param {number} j - Second index\n   * @throws {RangeError} If either index is out of bounds\n   */\n  swap(array, i, j) {\n    // Validate indices\n    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {\n      throw new RangeError(`Swap indices (${i}, ${j}) out of bounds for array of length ${array.length}`);\n    }\n\n    // Skip redundant swap of same index\n    if (i === j) return;\n\n    // Update metrics\n    this.metrics.swaps++;\n    this.metrics.writes += 2;\n    this.metrics.reads += 2;\n    this.metrics.memoryAccesses += 4;\n\n    // Perform the swap\n    const temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n\n    // Emit swap event\n    this.emit('swap', {\n      array,\n      indices: [i, j],\n      values: [array[i], array[j]]\n    });\n  }\n\n  /**\n   * Read a value from an array with instrumentation.\n   * Serves as a standard read operation for all algorithms.\n   * \n   * @param {Array} array - The array to read from\n   * @param {number} index - The index to read\n   * @returns {*} The value at the specified index\n   * @throws {RangeError} If the index is out of bounds\n   */\n  read(array, index) {\n    // Validate index\n    if (index < 0 || index >= array.length) {\n      throw new RangeError(`Read index ${index} out of bounds for array of length ${array.length}`);\n    }\n\n    // Update metrics\n    this.metrics.reads++;\n    this.metrics.memoryAccesses++;\n\n    // Simulate cache behavior\n    this._simulateCacheAccess(index);\n\n    // Perform the read\n    const value = array[index];\n\n    // Emit access event\n    this.emit('access', {\n      type: 'read',\n      index,\n      value\n    });\n    return value;\n  }\n\n  /**\n   * Write a value to an array with instrumentation.\n   * Serves as a standard write operation for all algorithms.\n   * \n   * @param {Array} array - The array to write to\n   * @param {number} index - The index to write\n   * @param {*} value - The value to write\n   * @throws {RangeError} If the index is out of bounds\n   */\n  write(array, index, value) {\n    // Validate index\n    if (index < 0 || index >= array.length) {\n      throw new RangeError(`Write index ${index} out of bounds for array of length ${array.length}`);\n    }\n\n    // Update metrics\n    this.metrics.writes++;\n    this.metrics.memoryAccesses++;\n\n    // Simulate cache behavior\n    this._simulateCacheAccess(index);\n\n    // Perform the write\n    array[index] = value;\n\n    // Emit access event\n    this.emit('access', {\n      type: 'write',\n      index,\n      value\n    });\n  }\n\n  /**\n   * Record the current algorithm state for visualization and analysis.\n   * \n   * @param {Array} array - The current array state\n   * @param {Object} [metadata={}] - Additional information about this state\n   */\n  recordState(array, metadata = {}) {\n    // Skip if history recording is disabled\n    if (!this.options.recordHistory) return;\n\n    // Create state snapshot with current metrics\n    const state = {\n      array: [...array],\n      // Defensive copy of array\n      metrics: {\n        ...this.metrics\n      },\n      // Copy of current metrics\n      timestamp: performance.now(),\n      // Precise timestamp\n      phase: this.currentPhase,\n      // Current algorithm phase\n      ...metadata // Additional metadata\n    };\n\n    // Add to history\n    this.history.push(state);\n\n    // Emit step event\n    this.emit('step', {\n      step: this.history.length - 1,\n      state: state\n    });\n  }\n\n  /**\n   * Set the current phase of the algorithm execution.\n   * Useful for tracking major stages in algorithm progress.\n   * \n   * @param {string} phase - The current algorithm phase\n   */\n  setPhase(phase) {\n    if (phase === this.currentPhase) return;\n    const previousPhase = this.currentPhase;\n    this.currentPhase = phase;\n\n    // Emit phase change event\n    this.emit('phase', {\n      from: previousPhase,\n      to: phase,\n      timestamp: performance.now()\n    });\n  }\n\n  /**\n   * Get a specific step from the algorithm history.\n   * \n   * @param {number} stepIndex - The step index to retrieve\n   * @returns {Object|null} The state at the requested step or null if invalid\n   */\n  getStep(stepIndex) {\n    if (stepIndex < 0 || stepIndex >= this.history.length) {\n      return null;\n    }\n    this.currentStep = stepIndex;\n    return this.history[stepIndex];\n  }\n\n  /**\n   * Register an event listener\n   * \n   * @param {string} event - The event name to listen for\n   * @param {Function} callback - The callback function to execute\n   * @returns {Algorithm} The algorithm instance for method chaining\n   * @throws {TypeError} If event type is invalid or callback is not a function\n   */\n  on(event, callback) {\n    // Validate parameters\n    if (!this.eventListeners.hasOwnProperty(event)) {\n      throw new TypeError(`Invalid event type: ${event}. Valid events are: ${Object.keys(this.eventListeners).join(', ')}`);\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError('Event callback must be a function');\n    }\n\n    // Register callback\n    this.eventListeners[event].push(callback);\n    return this;\n  }\n\n  /**\n   * Trigger an event and execute all registered listeners\n   * \n   * @param {string} event - The event name to trigger\n   * @param {*} data - Event data to pass to listeners\n   */\n  emit(event, data) {\n    // Skip if event type is invalid\n    if (!this.eventListeners.hasOwnProperty(event)) return;\n\n    // Execute all registered callbacks\n    for (const callback of this.eventListeners[event]) {\n      try {\n        callback(data);\n      } catch (error) {\n        console.error(`Error in ${event} event listener:`, error);\n      }\n    }\n  }\n\n  /**\n   * Get comprehensive algorithm information for display and analysis\n   * \n   * @returns {Object} Algorithm metadata and performance characteristics\n   */\n  getInfo() {\n    return {\n      name: this.name,\n      category: this.category,\n      metrics: {\n        ...this.metrics\n      },\n      complexity: this.getComplexity(),\n      stability: this.isStable(),\n      inPlace: this.isInPlace(),\n      options: {\n        ...this.options\n      },\n      history: {\n        steps: this.history.length,\n        currentStep: this.currentStep\n      },\n      status: {\n        isRunning: this.isRunning,\n        isPaused: this.isPaused,\n        isComplete: this.isComplete,\n        currentPhase: this.currentPhase\n      }\n    };\n  }\n\n  /**\n   * Get algorithm metrics\n   * \n   * @returns {Object} Current performance metrics\n   */\n  getMetrics() {\n    return {\n      ...this.metrics\n    };\n  }\n\n  /**\n   * Get the time and space complexity of the algorithm.\n   * Must be overridden by subclasses with accurate complexity analysis.\n   * \n   * @abstract\n   * @returns {Object} Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(?)',\n        average: 'O(?)',\n        worst: 'O(?)'\n      },\n      space: {\n        best: 'O(?)',\n        average: 'O(?)',\n        worst: 'O(?)'\n      }\n    };\n  }\n\n  /**\n   * Whether the algorithm is stable (preserves relative order of equal elements).\n   * Must be overridden by subclasses with accurate stability analysis.\n   * \n   * @abstract\n   * @returns {boolean} True if the algorithm is stable\n   */\n  isStable() {\n    return false;\n  }\n\n  /**\n   * Whether the algorithm is in-place (uses O(1) auxiliary space).\n   * Must be overridden by subclasses with accurate space complexity analysis.\n   * \n   * @abstract\n   * @returns {boolean} True if the algorithm is in-place\n   */\n  isInPlace() {\n    return false;\n  }\n\n  /**\n   * Simulate cache behavior for memory access\n   * This is a simplified model for educational purposes\n   * \n   * @private\n   * @param {number} index - The array index being accessed\n   */\n  _simulateCacheAccess(index) {\n    // Simple cache model using the last 8 accessed indices\n    if (!this._cacheModel) {\n      this._cacheModel = new Set();\n    }\n\n    // Check if index is in cache\n    if (this._cacheModel.has(index)) {\n      // Cache hit\n      this.metrics.cacheEfficiency.hits++;\n    } else {\n      // Cache miss\n      this.metrics.cacheEfficiency.misses++;\n\n      // Add to cache, evicting if necessary (LRU approximation)\n      if (this._cacheModel.size >= 8) {\n        // Evict oldest entry (using Set iteration order as approximation)\n        const oldest = this._cacheModel.values().next().value;\n        this._cacheModel.delete(oldest);\n      }\n      this._cacheModel.add(index);\n    }\n  }\n}\nexport default Algorithm;","map":{"version":3,"names":["Algorithm","constructor","name","category","options","TypeError","trackMemoryAccess","trackOperations","recordHistory","animationSpeed","metrics","comparisons","swaps","reads","writes","memoryAccesses","recursiveCalls","auxiliarySpace","startTime","endTime","executionTime","branchMispredictions","cacheEfficiency","hits","misses","hitRate","history","currentStep","isRunning","isPaused","isComplete","eventListeners","step","comparison","swap","access","complete","phase","currentPhase","reset","execute","array","mergedOptions","performance","now","arrayCopy","Array","isArray","from","recordState","type","message","result","run","emit","error","contextError","Error","originalError","algorithmName","algorithmCategory","compare","a","b","comparator","lastComparisonResult","_lastComparisonResult","Math","sign","i","j","length","RangeError","temp","indices","values","read","index","_simulateCacheAccess","value","write","metadata","state","timestamp","push","setPhase","previousPhase","to","getStep","stepIndex","on","event","callback","hasOwnProperty","Object","keys","join","data","console","getInfo","complexity","getComplexity","stability","isStable","inPlace","isInPlace","steps","status","getMetrics","time","best","average","worst","space","_cacheModel","Set","has","size","oldest","next","delete","add"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/core/algorithm-base.js"],"sourcesContent":["/**\n * @file algorithm-base.js\n * @module algorithms/core\n * @description Foundational abstract base class for all algorithmic implementations in the\n * visualization platform. Provides a standardized interface, comprehensive instrumentation,\n * and robust state management for algorithm execution and analysis.\n * @author Advanced Sorting Algorithm Visualization Platform Team\n * @copyright 2025\n */\n\n/**\n * Abstract base class for all algorithms in the visualization platform.\n * Implements the Template Method design pattern, defining the skeleton of\n * algorithmic operations while allowing subclasses to override specific steps.\n * \n * This architecture ensures consistent instrumentation, state tracking, and\n * visualization capabilities across all algorithm implementations while\n * maintaining separation of concerns between the algorithm logic and its\n * performance measurement.\n * \n * @abstract\n * @class Algorithm\n */\nclass Algorithm {\n  /**\n   * Creates a new Algorithm instance with the specified parameters.\n   * \n   * @param {string} name - Human-readable algorithm name\n   * @param {string} category - Algorithmic classification category\n   * @param {Object} [options={}] - Configuration options for the algorithm\n   * @throws {TypeError} If name or category are not provided\n   */\n  constructor(name, category, options = {}) {\n    // Parameter validation\n    if (!name || typeof name !== 'string') {\n      throw new TypeError('Algorithm name must be a non-empty string');\n    }\n    \n    if (!category || typeof category !== 'string') {\n      throw new TypeError('Algorithm category must be a non-empty string');\n    }\n    \n    if (this.constructor === Algorithm) {\n      throw new TypeError('Cannot instantiate abstract Algorithm class directly');\n    }\n    \n    // Basic information\n    this.name = name;\n    this.category = category;\n    \n    // Default options with override support\n    this.options = {\n      trackMemoryAccess: true,    // Track memory access operations\n      trackOperations: true,      // Track algorithmic operations\n      recordHistory: true,        // Record state history for visualization\n      animationSpeed: 1,          // Animation playback speed multiplier\n      ...options                  // Override with provided options\n    };\n    \n    // Initialize metrics tracking system\n    this.metrics = {\n      // Operation counts\n      comparisons: 0,             // Number of element comparisons\n      swaps: 0,                   // Number of element swaps\n      reads: 0,                   // Number of read operations\n      writes: 0,                  // Number of write operations\n      memoryAccesses: 0,          // Total memory access operations (reads + writes)\n      recursiveCalls: 0,          // Number of recursive function calls\n      \n      // Memory usage\n      auxiliarySpace: 0,          // Peak additional memory used (bytes)\n      \n      // Performance timing\n      startTime: 0,               // Execution start timestamp (ms)\n      endTime: 0,                 // Execution end timestamp (ms)\n      executionTime: 0,           // Total execution time (ms)\n      \n      // Advanced metrics\n      branchMispredictions: 0,    // Estimated branch mispredictions\n      cacheEfficiency: {          // Cache efficiency simulation\n        hits: 0,\n        misses: 0,\n        hitRate: 0\n      }\n    };\n    \n    // State history for visualization and analysis\n    this.history = [];            // Array of algorithm states for visualization\n    this.currentStep = 0;         // Current step in visualization playback\n    \n    // Execution status flags\n    this.isRunning = false;       // Whether algorithm is currently executing\n    this.isPaused = false;        // Whether execution is paused (for step-by-step)\n    this.isComplete = false;      // Whether execution has completed\n    \n    // Event listener registry (Observer pattern)\n    this.eventListeners = {\n      step: [],                   // Triggered on each visualization step\n      comparison: [],             // Triggered on element comparison\n      swap: [],                   // Triggered on element swap\n      access: [],                 // Triggered on memory access\n      complete: [],               // Triggered on execution completion\n      phase: []                   // Triggered on algorithm phase change\n    };\n    \n    // Current algorithm phase\n    this.currentPhase = 'initialization';\n  }\n  \n  /**\n   * Resets the algorithm state and metrics to initial values.\n   * Used before each new execution to ensure clean state.\n   * \n   * @returns {Algorithm} The algorithm instance for method chaining\n   */\n  reset() {\n    // Reset all metrics\n    this.metrics = {\n      comparisons: 0,\n      swaps: 0,\n      reads: 0,\n      writes: 0,\n      memoryAccesses: 0,\n      recursiveCalls: 0,\n      auxiliarySpace: 0,\n      startTime: 0,\n      endTime: 0,\n      executionTime: 0,\n      branchMispredictions: 0,\n      cacheEfficiency: {\n        hits: 0,\n        misses: 0,\n        hitRate: 0\n      }\n    };\n    \n    // Reset state\n    this.history = [];\n    this.currentStep = 0;\n    this.isRunning = false;\n    this.isPaused = false;\n    this.isComplete = false;\n    this.currentPhase = 'initialization';\n    \n    return this;\n  }\n  \n  /**\n   * Executes the algorithm on the provided input data.\n   * This is the main public interface for algorithm execution.\n   * Implements the Template Method pattern by defining the execution\n   * workflow while delegating specific algorithm logic to the run() method.\n   * \n   * @param {Array} array - The input array to process\n   * @param {Object} [options={}] - Runtime options that override instance options\n   * @returns {Array} The processed result array\n   * @throws {Error} If execution fails\n   */\n  execute(array, options = {}) {\n    try {\n      // Reset algorithm state before execution\n      this.reset();\n      \n      // Merge instance options with runtime options\n      const mergedOptions = { ...this.options, ...options };\n      \n      // Set execution flags\n      this.isRunning = true;\n      \n      // Start performance timer\n      this.metrics.startTime = performance.now();\n      \n      // Create a defensive copy of the input array to avoid mutating the original\n      const arrayCopy = Array.isArray(array) ? [...array] : Array.from(array);\n      \n      // Record initial state if history tracking is enabled\n      if (mergedOptions.recordHistory) {\n        this.recordState(arrayCopy, {\n          type: 'initial',\n          message: 'Initial array state'\n        });\n      }\n      \n      // Execute the specific algorithm implementation (delegated to subclasses)\n      const result = this.run(arrayCopy, mergedOptions);\n      \n      // Stop performance timer and calculate metrics\n      this.metrics.endTime = performance.now();\n      this.metrics.executionTime = this.metrics.endTime - this.metrics.startTime;\n      \n      // Calculate cache efficiency ratio if applicable\n      const { hits, misses } = this.metrics.cacheEfficiency;\n      if (hits > 0 || misses > 0) {\n        this.metrics.cacheEfficiency.hitRate = hits / (hits + misses);\n      }\n      \n      // Update execution flags\n      this.isRunning = false;\n      this.isComplete = true;\n      \n      // Record final state if history tracking is enabled\n      if (mergedOptions.recordHistory) {\n        this.recordState(result, {\n          type: 'final',\n          message: 'Final processed state'\n        });\n      }\n      \n      // Emit execution completion event\n      this.emit('complete', {\n        metrics: this.metrics,\n        result\n      });\n      \n      return result;\n    } catch (error) {\n      // Set error state\n      this.isRunning = false;\n      this.isComplete = false;\n      \n      // Enhance error with algorithm context\n      const contextError = new Error(\n        `Execution of ${this.name} algorithm failed: ${error.message}`\n      );\n      contextError.originalError = error;\n      contextError.algorithmName = this.name;\n      contextError.algorithmCategory = this.category;\n      \n      // Rethrow enhanced error\n      throw contextError;\n    }\n  }\n  \n  /**\n   * Abstract method that implements the specific algorithm logic.\n   * Must be overridden by concrete algorithm subclasses.\n   * \n   * @abstract\n   * @param {Array} array - The input array to process\n   * @param {Object} options - Runtime options\n   * @returns {Array} The processed array\n   * @throws {Error} If not implemented by subclass\n   */\n  run(array, options) {\n    throw new Error(`Method run() must be implemented by ${this.name} algorithm subclass`);\n  }\n  \n  /**\n   * Compare two elements with comprehensive instrumentation.\n   * Serves as a standard comparison operation for all algorithms.\n   * \n   * @param {*} a - First element\n   * @param {*} b - Second element\n   * @param {Function} [comparator=null] - Optional custom comparator function\n   * @returns {number} - Negative if a < b, 0 if a === b, positive if a > b\n   */\n  compare(a, b, comparator = null) {\n    // Increment comparison counter\n    this.metrics.comparisons++;\n    \n    // Perform comparison\n    let result;\n    \n    if (typeof comparator === 'function') {\n      // Use custom comparator if provided\n      result = comparator(a, b);\n    } else {\n      // Default comparison logic\n      result = a < b ? -1 : (a > b ? 1 : 0);\n    }\n    \n    // Simulate branch prediction\n    // In a real CPU, branch predictors work best when branches are consistent\n    // This is a simple model of misprediction for educational purposes\n    if (this.metrics.comparisons > 1) {\n      const lastComparisonResult = this._lastComparisonResult || 0;\n      if (Math.sign(lastComparisonResult) !== Math.sign(result)) {\n        this.metrics.branchMispredictions++;\n      }\n    }\n    this._lastComparisonResult = result;\n    \n    // Emit comparison event\n    this.emit('comparison', { a, b, result });\n    \n    return result;\n  }\n  \n  /**\n   * Swap two elements in an array with comprehensive instrumentation.\n   * Serves as a standard swap operation for all algorithms.\n   * \n   * @param {Array} array - The array to modify\n   * @param {number} i - First index\n   * @param {number} j - Second index\n   * @throws {RangeError} If either index is out of bounds\n   */\n  swap(array, i, j) {\n    // Validate indices\n    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {\n      throw new RangeError(`Swap indices (${i}, ${j}) out of bounds for array of length ${array.length}`);\n    }\n    \n    // Skip redundant swap of same index\n    if (i === j) return;\n    \n    // Update metrics\n    this.metrics.swaps++;\n    this.metrics.writes += 2;\n    this.metrics.reads += 2;\n    this.metrics.memoryAccesses += 4;\n    \n    // Perform the swap\n    const temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n    \n    // Emit swap event\n    this.emit('swap', { \n      array, \n      indices: [i, j], \n      values: [array[i], array[j]] \n    });\n  }\n  \n  /**\n   * Read a value from an array with instrumentation.\n   * Serves as a standard read operation for all algorithms.\n   * \n   * @param {Array} array - The array to read from\n   * @param {number} index - The index to read\n   * @returns {*} The value at the specified index\n   * @throws {RangeError} If the index is out of bounds\n   */\n  read(array, index) {\n    // Validate index\n    if (index < 0 || index >= array.length) {\n      throw new RangeError(`Read index ${index} out of bounds for array of length ${array.length}`);\n    }\n    \n    // Update metrics\n    this.metrics.reads++;\n    this.metrics.memoryAccesses++;\n    \n    // Simulate cache behavior\n    this._simulateCacheAccess(index);\n    \n    // Perform the read\n    const value = array[index];\n    \n    // Emit access event\n    this.emit('access', { type: 'read', index, value });\n    \n    return value;\n  }\n  \n  /**\n   * Write a value to an array with instrumentation.\n   * Serves as a standard write operation for all algorithms.\n   * \n   * @param {Array} array - The array to write to\n   * @param {number} index - The index to write\n   * @param {*} value - The value to write\n   * @throws {RangeError} If the index is out of bounds\n   */\n  write(array, index, value) {\n    // Validate index\n    if (index < 0 || index >= array.length) {\n      throw new RangeError(`Write index ${index} out of bounds for array of length ${array.length}`);\n    }\n    \n    // Update metrics\n    this.metrics.writes++;\n    this.metrics.memoryAccesses++;\n    \n    // Simulate cache behavior\n    this._simulateCacheAccess(index);\n    \n    // Perform the write\n    array[index] = value;\n    \n    // Emit access event\n    this.emit('access', { type: 'write', index, value });\n  }\n  \n  /**\n   * Record the current algorithm state for visualization and analysis.\n   * \n   * @param {Array} array - The current array state\n   * @param {Object} [metadata={}] - Additional information about this state\n   */\n  recordState(array, metadata = {}) {\n    // Skip if history recording is disabled\n    if (!this.options.recordHistory) return;\n    \n    // Create state snapshot with current metrics\n    const state = {\n      array: [...array],                // Defensive copy of array\n      metrics: { ...this.metrics },     // Copy of current metrics\n      timestamp: performance.now(),     // Precise timestamp\n      phase: this.currentPhase,         // Current algorithm phase\n      ...metadata                       // Additional metadata\n    };\n    \n    // Add to history\n    this.history.push(state);\n    \n    // Emit step event\n    this.emit('step', { \n      step: this.history.length - 1,\n      state: state\n    });\n  }\n  \n  /**\n   * Set the current phase of the algorithm execution.\n   * Useful for tracking major stages in algorithm progress.\n   * \n   * @param {string} phase - The current algorithm phase\n   */\n  setPhase(phase) {\n    if (phase === this.currentPhase) return;\n    \n    const previousPhase = this.currentPhase;\n    this.currentPhase = phase;\n    \n    // Emit phase change event\n    this.emit('phase', {\n      from: previousPhase,\n      to: phase,\n      timestamp: performance.now()\n    });\n  }\n  \n  /**\n   * Get a specific step from the algorithm history.\n   * \n   * @param {number} stepIndex - The step index to retrieve\n   * @returns {Object|null} The state at the requested step or null if invalid\n   */\n  getStep(stepIndex) {\n    if (stepIndex < 0 || stepIndex >= this.history.length) {\n      return null;\n    }\n    \n    this.currentStep = stepIndex;\n    return this.history[stepIndex];\n  }\n  \n  /**\n   * Register an event listener\n   * \n   * @param {string} event - The event name to listen for\n   * @param {Function} callback - The callback function to execute\n   * @returns {Algorithm} The algorithm instance for method chaining\n   * @throws {TypeError} If event type is invalid or callback is not a function\n   */\n  on(event, callback) {\n    // Validate parameters\n    if (!this.eventListeners.hasOwnProperty(event)) {\n      throw new TypeError(`Invalid event type: ${event}. Valid events are: ${Object.keys(this.eventListeners).join(', ')}`);\n    }\n    \n    if (typeof callback !== 'function') {\n      throw new TypeError('Event callback must be a function');\n    }\n    \n    // Register callback\n    this.eventListeners[event].push(callback);\n    \n    return this;\n  }\n  \n  /**\n   * Trigger an event and execute all registered listeners\n   * \n   * @param {string} event - The event name to trigger\n   * @param {*} data - Event data to pass to listeners\n   */\n  emit(event, data) {\n    // Skip if event type is invalid\n    if (!this.eventListeners.hasOwnProperty(event)) return;\n    \n    // Execute all registered callbacks\n    for (const callback of this.eventListeners[event]) {\n      try {\n        callback(data);\n      } catch (error) {\n        console.error(`Error in ${event} event listener:`, error);\n      }\n    }\n  }\n  \n  /**\n   * Get comprehensive algorithm information for display and analysis\n   * \n   * @returns {Object} Algorithm metadata and performance characteristics\n   */\n  getInfo() {\n    return {\n      name: this.name,\n      category: this.category,\n      metrics: { ...this.metrics },\n      complexity: this.getComplexity(),\n      stability: this.isStable(),\n      inPlace: this.isInPlace(),\n      options: { ...this.options },\n      history: {\n        steps: this.history.length,\n        currentStep: this.currentStep\n      },\n      status: {\n        isRunning: this.isRunning,\n        isPaused: this.isPaused,\n        isComplete: this.isComplete,\n        currentPhase: this.currentPhase\n      }\n    };\n  }\n  \n  /**\n   * Get algorithm metrics\n   * \n   * @returns {Object} Current performance metrics\n   */\n  getMetrics() {\n    return { ...this.metrics };\n  }\n  \n  /**\n   * Get the time and space complexity of the algorithm.\n   * Must be overridden by subclasses with accurate complexity analysis.\n   * \n   * @abstract\n   * @returns {Object} Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(?)',\n        average: 'O(?)',\n        worst: 'O(?)'\n      },\n      space: {\n        best: 'O(?)',\n        average: 'O(?)',\n        worst: 'O(?)'\n      }\n    };\n  }\n  \n  /**\n   * Whether the algorithm is stable (preserves relative order of equal elements).\n   * Must be overridden by subclasses with accurate stability analysis.\n   * \n   * @abstract\n   * @returns {boolean} True if the algorithm is stable\n   */\n  isStable() {\n    return false;\n  }\n  \n  /**\n   * Whether the algorithm is in-place (uses O(1) auxiliary space).\n   * Must be overridden by subclasses with accurate space complexity analysis.\n   * \n   * @abstract\n   * @returns {boolean} True if the algorithm is in-place\n   */\n  isInPlace() {\n    return false;\n  }\n  \n  /**\n   * Simulate cache behavior for memory access\n   * This is a simplified model for educational purposes\n   * \n   * @private\n   * @param {number} index - The array index being accessed\n   */\n  _simulateCacheAccess(index) {\n    // Simple cache model using the last 8 accessed indices\n    if (!this._cacheModel) {\n      this._cacheModel = new Set();\n    }\n    \n    // Check if index is in cache\n    if (this._cacheModel.has(index)) {\n      // Cache hit\n      this.metrics.cacheEfficiency.hits++;\n    } else {\n      // Cache miss\n      this.metrics.cacheEfficiency.misses++;\n      \n      // Add to cache, evicting if necessary (LRU approximation)\n      if (this._cacheModel.size >= 8) {\n        // Evict oldest entry (using Set iteration order as approximation)\n        const oldest = this._cacheModel.values().next().value;\n        this._cacheModel.delete(oldest);\n      }\n      \n      this._cacheModel.add(index);\n    }\n  }\n}\n\nexport default Algorithm;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}