{"ast":null,"code":"// src/algorithms/comparison/selection.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Selection Sort with algorithmic optimizations and educational instrumentation.\n * \n * Selection Sort operates by dividing the input into a sorted and unsorted region,\n * repeatedly selecting the smallest (or largest) element from the unsorted region\n * and moving it to the sorted region. The algorithm maintains two subarrays:\n * 1. The subarray which is already sorted\n * 2. The remaining subarray which remains to be sorted\n * \n * This implementation includes multiple variants:\n * - Standard Selection Sort (one-way traversal finding minimum elements)\n * - Bidirectional Selection Sort (finding both minimum and maximum each pass)\n * - Stable Selection Sort variant\n * \n * Time Complexity:\n * - Best:    O(n²) - Even if array is sorted, all comparisons still occur\n * - Average: O(n²)\n * - Worst:   O(n²)\n * \n * Space Complexity: O(1) for standard implementation\n * \n * @class SelectionSort\n * @extends Algorithm\n */\nclass SelectionSort extends Algorithm {\n  /**\n   * Create a new SelectionSort instance with configurable options\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.bidirectional=false] - Use bidirectional optimization (min+max each pass)\n   * @param {boolean} [options.stable=false] - Use stable variant (preserves order of equal elements)\n   * @param {boolean} [options.visualizeRegions=true] - Visualize sorted and unsorted regions\n   * @param {boolean} [options.enhancedInstrumentation=true] - Use enhanced operation instrumentation\n   */\n  constructor(options = {}) {\n    super('Selection Sort', 'comparison', options);\n\n    // Default options\n    this.options = {\n      bidirectional: false,\n      // Use bidirectional optimization\n      stable: false,\n      // Use stable variant\n      visualizeRegions: true,\n      // Visualize sorted and unsorted regions\n      enhancedInstrumentation: true,\n      // Enhanced operation instrumentation\n      ...options\n    };\n  }\n\n  /**\n   * Execute Selection Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('sorting');\n\n    // Select implementation based on options\n    if (options.bidirectional) {\n      this.bidirectionalSelectionSort(result, n, options);\n    } else if (options.stable) {\n      this.stableSelectionSort(result, n, options);\n    } else {\n      this.standardSelectionSort(result, n, options);\n    }\n    this.setPhase('completed');\n    return result;\n  }\n\n  /**\n   * Standard Selection Sort algorithm implementation\n   * This is the most common implementation, finding the minimum element\n   * in each pass and placing it at the beginning of the unsorted region.\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} n - Array length\n   * @param {Object} options - Runtime options\n   */\n  standardSelectionSort(array, n, options) {\n    // In each iteration, the smallest unsorted element is selected and placed\n    // at the end of the sorted portion of the array\n    for (let i = 0; i < n - 1; i++) {\n      // Find the minimum element in the unsorted portion\n      let minIndex = i;\n\n      // Visualize the current boundary between sorted and unsorted regions\n      if (options.visualizeRegions) {\n        this.recordState(array, {\n          type: 'region-boundary',\n          sortedRegion: Array.from({\n            length: i\n          }, (_, idx) => idx),\n          currentPosition: i,\n          message: `Elements 0 to ${i - 1} are sorted. Finding minimum in remaining elements.`\n        });\n      }\n\n      // Search for minimum element in unsorted region\n      for (let j = i + 1; j < n; j++) {\n        // Record comparison operation\n        if (options.enhancedInstrumentation) {\n          this.recordState(array, {\n            type: 'comparison',\n            indices: [minIndex, j],\n            message: `Comparing minimum so far (${array[minIndex]}) with element at position ${j} (${array[j]})`\n          });\n        }\n\n        // Compare current minimum with element at j\n        if (this.compare(array[j], array[minIndex]) < 0) {\n          minIndex = j;\n\n          // Record new minimum found\n          if (options.enhancedInstrumentation) {\n            this.recordState(array, {\n              type: 'new-minimum',\n              index: j,\n              value: array[j],\n              message: `New minimum ${array[j]} found at position ${j}`\n            });\n          }\n        }\n      }\n\n      // If the minimum element isn't already at position i, swap it\n      if (minIndex !== i) {\n        this.swap(array, i, minIndex);\n\n        // Record swap operation\n        this.recordState(array, {\n          type: 'swap',\n          indices: [i, minIndex],\n          message: `Placed minimum element ${array[i]} at position ${i}`\n        });\n      } else {\n        // Record that element is already in correct position\n        this.recordState(array, {\n          type: 'already-positioned',\n          index: i,\n          message: `Element ${array[i]} is already the minimum and in correct position ${i}`\n        });\n      }\n\n      // Mark the element as sorted\n      this.recordState(array, {\n        type: 'sorted',\n        indices: Array.from({\n          length: i + 1\n        }, (_, idx) => idx),\n        message: `Elements 0 to ${i} are now sorted`\n      });\n    }\n  }\n\n  /**\n   * Bidirectional Selection Sort implementation\n   * This optimization finds both minimum and maximum elements in each pass,\n   * reducing the number of passes by approximately half.\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} n - Array length\n   * @param {Object} options - Runtime options\n   */\n  bidirectionalSelectionSort(array, n, options) {\n    let left = 0;\n    let right = n - 1;\n\n    // Continue until the pointers meet in the middle\n    while (left < right) {\n      // Initialize min and max indices\n      let minIndex = left;\n      let maxIndex = right;\n\n      // Visualize the current boundaries\n      if (options.visualizeRegions) {\n        this.recordState(array, {\n          type: 'region-boundary',\n          sortedLeftRegion: Array.from({\n            length: left\n          }, (_, idx) => idx),\n          sortedRightRegion: Array.from({\n            length: n - right - 1\n          }, (_, idx) => right + 1 + idx),\n          unsortedRegion: Array.from({\n            length: right - left + 1\n          }, (_, idx) => left + idx),\n          message: `Elements 0 to ${left - 1} and ${right + 1} to ${n - 1} are sorted. Processing middle region.`\n        });\n      }\n\n      // Find both minimum and maximum in a single pass\n      for (let i = left; i <= right; i++) {\n        // Compare with current minimum\n        if (this.compare(array[i], array[minIndex]) < 0) {\n          minIndex = i;\n          if (options.enhancedInstrumentation) {\n            this.recordState(array, {\n              type: 'new-minimum',\n              index: i,\n              value: array[i],\n              message: `New minimum ${array[i]} found at position ${i}`\n            });\n          }\n        }\n        // Compare with current maximum\n        else if (this.compare(array[i], array[maxIndex]) > 0) {\n          maxIndex = i;\n          if (options.enhancedInstrumentation) {\n            this.recordState(array, {\n              type: 'new-maximum',\n              index: i,\n              value: array[i],\n              message: `New maximum ${array[i]} found at position ${i}`\n            });\n          }\n        }\n      }\n\n      // Special case: if the minimum element is at the right boundary\n      // or the maximum element is at the left boundary, there is potential \n      // for a value to be overwritten, so we need to handle these cases carefully\n\n      // If the minimum element is at the right boundary\n      if (minIndex === right) {\n        // If the maximum element is at the left boundary, and we move the \n        // minimum element to the left boundary first, then we'd lose track\n        // of the maximum element's new position\n        if (maxIndex === left) {\n          maxIndex = minIndex; // Update maxIndex to the new position\n        }\n      }\n      // If the maximum element is at the left boundary\n      else if (maxIndex === left) {\n        // If we move the maximum element to the right boundary first, \n        // and the minimum element is at the right boundary, then we'd lose\n        // track of the minimum element's new position\n        if (minIndex === right) {\n          minIndex = maxIndex; // Update minIndex to the new position\n        }\n      }\n\n      // Place minimum element at the left boundary\n      if (minIndex !== left) {\n        this.swap(array, left, minIndex);\n\n        // If the maximum was at the position we just swapped with,\n        // update its new position\n        if (maxIndex === left) {\n          maxIndex = minIndex;\n        }\n        this.recordState(array, {\n          type: 'swap',\n          indices: [left, minIndex],\n          message: `Placed minimum element ${array[left]} at position ${left}`\n        });\n      } else {\n        this.recordState(array, {\n          type: 'already-positioned',\n          index: left,\n          message: `Element ${array[left]} is already the minimum and in correct position ${left}`\n        });\n      }\n\n      // Place maximum element at the right boundary\n      if (maxIndex !== right) {\n        this.swap(array, right, maxIndex);\n        this.recordState(array, {\n          type: 'swap',\n          indices: [right, maxIndex],\n          message: `Placed maximum element ${array[right]} at position ${right}`\n        });\n      } else {\n        this.recordState(array, {\n          type: 'already-positioned',\n          index: right,\n          message: `Element ${array[right]} is already the maximum and in correct position ${right}`\n        });\n      }\n\n      // Mark elements as sorted\n      this.recordState(array, {\n        type: 'sorted',\n        indices: [...Array.from({\n          length: left + 1\n        }, (_, idx) => idx), ...Array.from({\n          length: n - right\n        }, (_, idx) => right + idx)],\n        message: `Elements 0 to ${left} and ${right} to ${n - 1} are now sorted`\n      });\n\n      // Move boundaries inward\n      left++;\n      right--;\n    }\n  }\n\n  /**\n   * Stable Selection Sort implementation\n   * This variant preserves the relative order of equal elements,\n   * at the cost of increased time complexity.\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} n - Array length\n   * @param {Object} options - Runtime options\n   */\n  stableSelectionSort(array, n, options) {\n    // For each position in the array\n    for (let i = 0; i < n - 1; i++) {\n      // Find the minimum element\n      let minIndex = i;\n\n      // Visualize the current boundary\n      if (options.visualizeRegions) {\n        this.recordState(array, {\n          type: 'region-boundary',\n          sortedRegion: Array.from({\n            length: i\n          }, (_, idx) => idx),\n          currentPosition: i,\n          message: `Elements 0 to ${i - 1} are sorted. Finding minimum in remaining elements.`\n        });\n      }\n\n      // Find the minimum element\n      for (let j = i + 1; j < n; j++) {\n        if (options.enhancedInstrumentation) {\n          this.recordState(array, {\n            type: 'comparison',\n            indices: [minIndex, j],\n            message: `Comparing minimum so far (${array[minIndex]}) with element at position ${j} (${array[j]})`\n          });\n        }\n        if (this.compare(array[j], array[minIndex]) < 0) {\n          minIndex = j;\n          if (options.enhancedInstrumentation) {\n            this.recordState(array, {\n              type: 'new-minimum',\n              index: j,\n              value: array[j],\n              message: `New minimum ${array[j]} found at position ${j}`\n            });\n          }\n        }\n      }\n\n      // To ensure stability, we need to shift elements rather than swap\n      if (minIndex !== i) {\n        // Save the minimum value to insert at position i\n        const minValue = this.read(array, minIndex);\n\n        // Shift all elements between i and minIndex one position to the right\n        for (let j = minIndex; j > i; j--) {\n          this.write(array, j, this.read(array, j - 1));\n          if (options.enhancedInstrumentation) {\n            this.recordState(array, {\n              type: 'shift',\n              index: j,\n              value: array[j],\n              message: `Shifted element from position ${j - 1} to position ${j}`\n            });\n          }\n        }\n\n        // Insert the minimum value at position i\n        this.write(array, i, minValue);\n        this.recordState(array, {\n          type: 'insert',\n          index: i,\n          value: minValue,\n          message: `Inserted minimum element ${minValue} at position ${i}`\n        });\n      } else {\n        this.recordState(array, {\n          type: 'already-positioned',\n          index: i,\n          message: `Element ${array[i]} is already the minimum and in correct position ${i}`\n        });\n      }\n\n      // Mark the element as sorted\n      this.recordState(array, {\n        type: 'sorted',\n        indices: Array.from({\n          length: i + 1\n        }, (_, idx) => idx),\n        message: `Elements 0 to ${i} are now sorted`\n      });\n    }\n  }\n\n  /**\n   * Get the time and space complexity of Selection Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(n²)',\n        average: 'O(n²)',\n        worst: 'O(n²)'\n      },\n      space: {\n        best: this.options.stable ? 'O(1)' : 'O(1)',\n        average: this.options.stable ? 'O(1)' : 'O(1)',\n        worst: this.options.stable ? 'O(1)' : 'O(1)'\n      }\n    };\n  }\n\n  /**\n   * Whether Selection Sort is stable\n   * Standard implementation is not stable, but stable variant is available\n   * \n   * @returns {boolean} - True if using stable variant, otherwise false\n   */\n  isStable() {\n    return this.options.stable;\n  }\n\n  /**\n   * Whether Selection Sort is in-place\n   * \n   * @returns {boolean} - True as Selection Sort is in-place\n   */\n  isInPlace() {\n    return true; // Both variants use O(1) auxiliary space\n  }\n\n  /**\n   * Get detailed algorithm information including variants and characteristics\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add selection sort specific information\n    info.optimization = {\n      bidirectional: this.options.bidirectional,\n      stable: this.options.stable,\n      visualizeRegions: this.options.visualizeRegions,\n      enhancedInstrumentation: this.options.enhancedInstrumentation\n    };\n    info.properties = {\n      comparisonBased: true,\n      stable: this.options.stable,\n      inPlace: true,\n      online: false,\n      adaptive: false\n    };\n    info.suitable = {\n      smallArrays: true,\n      nearlySortedArrays: false,\n      largeArrays: false,\n      limitedMemory: true\n    };\n    info.variants = ['Standard Selection Sort', 'Bidirectional Selection Sort', 'Stable Selection Sort (preserves order of equal elements)', 'Heap Selection (Heap Sort)'];\n    info.advantages = ['Simple implementation with minimal conceptual complexity', 'In-place sorting with O(1) auxiliary space', 'Minimal number of writes to the original array (O(n))', 'Performs well for small arrays', 'Performance is consistent regardless of input distribution'];\n    info.disadvantages = ['O(n²) time complexity makes it inefficient for large arrays', 'No early termination possibility for already-sorted arrays', 'Standard implementation is not stable', 'Doesn\\'t utilize hardware caches efficiently'];\n    info.analysis = {\n      comparisons: {\n        formula: 'n(n-1)/2',\n        exact: true,\n        explanation: 'Always performs exactly this many comparisons regardless of input'\n      },\n      swaps: {\n        formula: 'n-1 ≤ swaps ≤ n-1',\n        exact: false,\n        explanation: 'Minimum when array is already sorted, maximum when each element needs to be swapped'\n      },\n      writes: {\n        bidirectional: 'Approximately 2n writes in the worst case',\n        standard: 'Up to 3(n-1) writes in the worst case',\n        stable: 'Up to n² writes in the worst case'\n      }\n    };\n    return info;\n  }\n}\nexport default SelectionSort;","map":{"version":3,"names":["Algorithm","SelectionSort","constructor","options","bidirectional","stable","visualizeRegions","enhancedInstrumentation","run","array","result","n","length","setPhase","bidirectionalSelectionSort","stableSelectionSort","standardSelectionSort","i","minIndex","recordState","type","sortedRegion","Array","from","_","idx","currentPosition","message","j","indices","compare","index","value","swap","left","right","maxIndex","sortedLeftRegion","sortedRightRegion","unsortedRegion","minValue","read","write","getComplexity","time","best","average","worst","space","isStable","isInPlace","getInfo","info","optimization","properties","comparisonBased","inPlace","online","adaptive","suitable","smallArrays","nearlySortedArrays","largeArrays","limitedMemory","variants","advantages","disadvantages","analysis","comparisons","formula","exact","explanation","swaps","writes","standard"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/comparison/selection.js"],"sourcesContent":["// src/algorithms/comparison/selection.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Selection Sort with algorithmic optimizations and educational instrumentation.\n * \n * Selection Sort operates by dividing the input into a sorted and unsorted region,\n * repeatedly selecting the smallest (or largest) element from the unsorted region\n * and moving it to the sorted region. The algorithm maintains two subarrays:\n * 1. The subarray which is already sorted\n * 2. The remaining subarray which remains to be sorted\n * \n * This implementation includes multiple variants:\n * - Standard Selection Sort (one-way traversal finding minimum elements)\n * - Bidirectional Selection Sort (finding both minimum and maximum each pass)\n * - Stable Selection Sort variant\n * \n * Time Complexity:\n * - Best:    O(n²) - Even if array is sorted, all comparisons still occur\n * - Average: O(n²)\n * - Worst:   O(n²)\n * \n * Space Complexity: O(1) for standard implementation\n * \n * @class SelectionSort\n * @extends Algorithm\n */\nclass SelectionSort extends Algorithm {\n  /**\n   * Create a new SelectionSort instance with configurable options\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.bidirectional=false] - Use bidirectional optimization (min+max each pass)\n   * @param {boolean} [options.stable=false] - Use stable variant (preserves order of equal elements)\n   * @param {boolean} [options.visualizeRegions=true] - Visualize sorted and unsorted regions\n   * @param {boolean} [options.enhancedInstrumentation=true] - Use enhanced operation instrumentation\n   */\n  constructor(options = {}) {\n    super('Selection Sort', 'comparison', options);\n    \n    // Default options\n    this.options = {\n      bidirectional: false,       // Use bidirectional optimization\n      stable: false,              // Use stable variant\n      visualizeRegions: true,     // Visualize sorted and unsorted regions\n      enhancedInstrumentation: true, // Enhanced operation instrumentation\n      ...options\n    };\n  }\n  \n  /**\n   * Execute Selection Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('sorting');\n    \n    // Select implementation based on options\n    if (options.bidirectional) {\n      this.bidirectionalSelectionSort(result, n, options);\n    } else if (options.stable) {\n      this.stableSelectionSort(result, n, options);\n    } else {\n      this.standardSelectionSort(result, n, options);\n    }\n    \n    this.setPhase('completed');\n    return result;\n  }\n  \n  /**\n   * Standard Selection Sort algorithm implementation\n   * This is the most common implementation, finding the minimum element\n   * in each pass and placing it at the beginning of the unsorted region.\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} n - Array length\n   * @param {Object} options - Runtime options\n   */\n  standardSelectionSort(array, n, options) {\n    // In each iteration, the smallest unsorted element is selected and placed\n    // at the end of the sorted portion of the array\n    for (let i = 0; i < n - 1; i++) {\n      // Find the minimum element in the unsorted portion\n      let minIndex = i;\n      \n      // Visualize the current boundary between sorted and unsorted regions\n      if (options.visualizeRegions) {\n        this.recordState(array, {\n          type: 'region-boundary',\n          sortedRegion: Array.from({ length: i }, (_, idx) => idx),\n          currentPosition: i,\n          message: `Elements 0 to ${i-1} are sorted. Finding minimum in remaining elements.`\n        });\n      }\n      \n      // Search for minimum element in unsorted region\n      for (let j = i + 1; j < n; j++) {\n        // Record comparison operation\n        if (options.enhancedInstrumentation) {\n          this.recordState(array, {\n            type: 'comparison',\n            indices: [minIndex, j],\n            message: `Comparing minimum so far (${array[minIndex]}) with element at position ${j} (${array[j]})`\n          });\n        }\n        \n        // Compare current minimum with element at j\n        if (this.compare(array[j], array[minIndex]) < 0) {\n          minIndex = j;\n          \n          // Record new minimum found\n          if (options.enhancedInstrumentation) {\n            this.recordState(array, {\n              type: 'new-minimum',\n              index: j,\n              value: array[j],\n              message: `New minimum ${array[j]} found at position ${j}`\n            });\n          }\n        }\n      }\n      \n      // If the minimum element isn't already at position i, swap it\n      if (minIndex !== i) {\n        this.swap(array, i, minIndex);\n        \n        // Record swap operation\n        this.recordState(array, {\n          type: 'swap',\n          indices: [i, minIndex],\n          message: `Placed minimum element ${array[i]} at position ${i}`\n        });\n      } else {\n        // Record that element is already in correct position\n        this.recordState(array, {\n          type: 'already-positioned',\n          index: i,\n          message: `Element ${array[i]} is already the minimum and in correct position ${i}`\n        });\n      }\n      \n      // Mark the element as sorted\n      this.recordState(array, {\n        type: 'sorted',\n        indices: Array.from({ length: i + 1 }, (_, idx) => idx),\n        message: `Elements 0 to ${i} are now sorted`\n      });\n    }\n  }\n  \n  /**\n   * Bidirectional Selection Sort implementation\n   * This optimization finds both minimum and maximum elements in each pass,\n   * reducing the number of passes by approximately half.\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} n - Array length\n   * @param {Object} options - Runtime options\n   */\n  bidirectionalSelectionSort(array, n, options) {\n    let left = 0;\n    let right = n - 1;\n    \n    // Continue until the pointers meet in the middle\n    while (left < right) {\n      // Initialize min and max indices\n      let minIndex = left;\n      let maxIndex = right;\n      \n      // Visualize the current boundaries\n      if (options.visualizeRegions) {\n        this.recordState(array, {\n          type: 'region-boundary',\n          sortedLeftRegion: Array.from({ length: left }, (_, idx) => idx),\n          sortedRightRegion: Array.from({ length: n - right - 1 }, (_, idx) => right + 1 + idx),\n          unsortedRegion: Array.from({ length: right - left + 1 }, (_, idx) => left + idx),\n          message: `Elements 0 to ${left-1} and ${right+1} to ${n-1} are sorted. Processing middle region.`\n        });\n      }\n      \n      // Find both minimum and maximum in a single pass\n      for (let i = left; i <= right; i++) {\n        // Compare with current minimum\n        if (this.compare(array[i], array[minIndex]) < 0) {\n          minIndex = i;\n          \n          if (options.enhancedInstrumentation) {\n            this.recordState(array, {\n              type: 'new-minimum',\n              index: i,\n              value: array[i],\n              message: `New minimum ${array[i]} found at position ${i}`\n            });\n          }\n        }\n        // Compare with current maximum\n        else if (this.compare(array[i], array[maxIndex]) > 0) {\n          maxIndex = i;\n          \n          if (options.enhancedInstrumentation) {\n            this.recordState(array, {\n              type: 'new-maximum',\n              index: i,\n              value: array[i],\n              message: `New maximum ${array[i]} found at position ${i}`\n            });\n          }\n        }\n      }\n      \n      // Special case: if the minimum element is at the right boundary\n      // or the maximum element is at the left boundary, there is potential \n      // for a value to be overwritten, so we need to handle these cases carefully\n      \n      // If the minimum element is at the right boundary\n      if (minIndex === right) {\n        // If the maximum element is at the left boundary, and we move the \n        // minimum element to the left boundary first, then we'd lose track\n        // of the maximum element's new position\n        if (maxIndex === left) {\n          maxIndex = minIndex; // Update maxIndex to the new position\n        }\n      }\n      // If the maximum element is at the left boundary\n      else if (maxIndex === left) {\n        // If we move the maximum element to the right boundary first, \n        // and the minimum element is at the right boundary, then we'd lose\n        // track of the minimum element's new position\n        if (minIndex === right) {\n          minIndex = maxIndex; // Update minIndex to the new position\n        }\n      }\n      \n      // Place minimum element at the left boundary\n      if (minIndex !== left) {\n        this.swap(array, left, minIndex);\n        \n        // If the maximum was at the position we just swapped with,\n        // update its new position\n        if (maxIndex === left) {\n          maxIndex = minIndex;\n        }\n        \n        this.recordState(array, {\n          type: 'swap',\n          indices: [left, minIndex],\n          message: `Placed minimum element ${array[left]} at position ${left}`\n        });\n      } else {\n        this.recordState(array, {\n          type: 'already-positioned',\n          index: left,\n          message: `Element ${array[left]} is already the minimum and in correct position ${left}`\n        });\n      }\n      \n      // Place maximum element at the right boundary\n      if (maxIndex !== right) {\n        this.swap(array, right, maxIndex);\n        \n        this.recordState(array, {\n          type: 'swap',\n          indices: [right, maxIndex],\n          message: `Placed maximum element ${array[right]} at position ${right}`\n        });\n      } else {\n        this.recordState(array, {\n          type: 'already-positioned',\n          index: right,\n          message: `Element ${array[right]} is already the maximum and in correct position ${right}`\n        });\n      }\n      \n      // Mark elements as sorted\n      this.recordState(array, {\n        type: 'sorted',\n        indices: [\n          ...Array.from({ length: left + 1 }, (_, idx) => idx), \n          ...Array.from({ length: n - right }, (_, idx) => right + idx)\n        ],\n        message: `Elements 0 to ${left} and ${right} to ${n-1} are now sorted`\n      });\n      \n      // Move boundaries inward\n      left++;\n      right--;\n    }\n  }\n  \n  /**\n   * Stable Selection Sort implementation\n   * This variant preserves the relative order of equal elements,\n   * at the cost of increased time complexity.\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} n - Array length\n   * @param {Object} options - Runtime options\n   */\n  stableSelectionSort(array, n, options) {\n    // For each position in the array\n    for (let i = 0; i < n - 1; i++) {\n      // Find the minimum element\n      let minIndex = i;\n      \n      // Visualize the current boundary\n      if (options.visualizeRegions) {\n        this.recordState(array, {\n          type: 'region-boundary',\n          sortedRegion: Array.from({ length: i }, (_, idx) => idx),\n          currentPosition: i,\n          message: `Elements 0 to ${i-1} are sorted. Finding minimum in remaining elements.`\n        });\n      }\n      \n      // Find the minimum element\n      for (let j = i + 1; j < n; j++) {\n        if (options.enhancedInstrumentation) {\n          this.recordState(array, {\n            type: 'comparison',\n            indices: [minIndex, j],\n            message: `Comparing minimum so far (${array[minIndex]}) with element at position ${j} (${array[j]})`\n          });\n        }\n        \n        if (this.compare(array[j], array[minIndex]) < 0) {\n          minIndex = j;\n          \n          if (options.enhancedInstrumentation) {\n            this.recordState(array, {\n              type: 'new-minimum',\n              index: j,\n              value: array[j],\n              message: `New minimum ${array[j]} found at position ${j}`\n            });\n          }\n        }\n      }\n      \n      // To ensure stability, we need to shift elements rather than swap\n      if (minIndex !== i) {\n        // Save the minimum value to insert at position i\n        const minValue = this.read(array, minIndex);\n        \n        // Shift all elements between i and minIndex one position to the right\n        for (let j = minIndex; j > i; j--) {\n          this.write(array, j, this.read(array, j - 1));\n          \n          if (options.enhancedInstrumentation) {\n            this.recordState(array, {\n              type: 'shift',\n              index: j,\n              value: array[j],\n              message: `Shifted element from position ${j-1} to position ${j}`\n            });\n          }\n        }\n        \n        // Insert the minimum value at position i\n        this.write(array, i, minValue);\n        \n        this.recordState(array, {\n          type: 'insert',\n          index: i,\n          value: minValue,\n          message: `Inserted minimum element ${minValue} at position ${i}`\n        });\n      } else {\n        this.recordState(array, {\n          type: 'already-positioned',\n          index: i,\n          message: `Element ${array[i]} is already the minimum and in correct position ${i}`\n        });\n      }\n      \n      // Mark the element as sorted\n      this.recordState(array, {\n        type: 'sorted',\n        indices: Array.from({ length: i + 1 }, (_, idx) => idx),\n        message: `Elements 0 to ${i} are now sorted`\n      });\n    }\n  }\n  \n  /**\n   * Get the time and space complexity of Selection Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(n²)',\n        average: 'O(n²)',\n        worst: 'O(n²)'\n      },\n      space: {\n        best: this.options.stable ? 'O(1)' : 'O(1)',\n        average: this.options.stable ? 'O(1)' : 'O(1)',\n        worst: this.options.stable ? 'O(1)' : 'O(1)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Selection Sort is stable\n   * Standard implementation is not stable, but stable variant is available\n   * \n   * @returns {boolean} - True if using stable variant, otherwise false\n   */\n  isStable() {\n    return this.options.stable;\n  }\n  \n  /**\n   * Whether Selection Sort is in-place\n   * \n   * @returns {boolean} - True as Selection Sort is in-place\n   */\n  isInPlace() {\n    return true; // Both variants use O(1) auxiliary space\n  }\n  \n  /**\n   * Get detailed algorithm information including variants and characteristics\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add selection sort specific information\n    info.optimization = {\n      bidirectional: this.options.bidirectional,\n      stable: this.options.stable,\n      visualizeRegions: this.options.visualizeRegions,\n      enhancedInstrumentation: this.options.enhancedInstrumentation\n    };\n    \n    info.properties = {\n      comparisonBased: true,\n      stable: this.options.stable,\n      inPlace: true,\n      online: false,\n      adaptive: false\n    };\n    \n    info.suitable = {\n      smallArrays: true,\n      nearlySortedArrays: false,\n      largeArrays: false, \n      limitedMemory: true\n    };\n    \n    info.variants = [\n      'Standard Selection Sort',\n      'Bidirectional Selection Sort',\n      'Stable Selection Sort (preserves order of equal elements)',\n      'Heap Selection (Heap Sort)'\n    ];\n    \n    info.advantages = [\n      'Simple implementation with minimal conceptual complexity',\n      'In-place sorting with O(1) auxiliary space',\n      'Minimal number of writes to the original array (O(n))',\n      'Performs well for small arrays',\n      'Performance is consistent regardless of input distribution'\n    ];\n    \n    info.disadvantages = [\n      'O(n²) time complexity makes it inefficient for large arrays',\n      'No early termination possibility for already-sorted arrays',\n      'Standard implementation is not stable',\n      'Doesn\\'t utilize hardware caches efficiently'\n    ];\n    \n    info.analysis = {\n      comparisons: {\n        formula: 'n(n-1)/2',\n        exact: true,\n        explanation: 'Always performs exactly this many comparisons regardless of input'\n      },\n      swaps: {\n        formula: 'n-1 ≤ swaps ≤ n-1',\n        exact: false,\n        explanation: 'Minimum when array is already sorted, maximum when each element needs to be swapped'\n      },\n      writes: {\n        bidirectional: 'Approximately 2n writes in the worst case',\n        standard: 'Up to 3(n-1) writes in the worst case',\n        stable: 'Up to n² writes in the worst case'\n      }\n    };\n    \n    return info;\n  }\n}\n\nexport default SelectionSort;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}