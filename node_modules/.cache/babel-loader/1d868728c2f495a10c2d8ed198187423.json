{"ast":null,"code":"var _jsxFileName = \"/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/visualization/components/HeapVisualizer.js\";\n// src/visualization/components/heap-visualizer.js\n\n/**\n * @file HeapVisualizer component for binary heap visualization\n * @module HeapVisualizer\n * @author Algorithm Visualization Platform Team\n * @version 1.2.0\n * \n * @description\n * Advanced visualization component for binary heap data structures used in Heap Sort\n * and other heap-based algorithms. This component provides a sophisticated \n * representation of the implicit binary tree structure within an array,\n * with educational annotations and interactive capabilities.\n * \n * The visualization demonstrates the fundamental heap property (max-heap or min-heap)\n * and illustrates parent-child relationships through an optimized Canvas-based\n * rendering system that scales efficiently for heaps of various sizes.\n * \n * Performance characteristics:\n * - Time complexity: O(n) for rendering n nodes\n * - Space complexity: O(n) for internal data structures\n * - Rendering performance: Optimized for heaps with up to 1023 nodes (complete binary tree height 9)\n */\n\nimport React, { useRef, useEffect, useState, useMemo } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * Mathematical and layout utility functions for heap visualization\n * @namespace HeapMathUtils\n * @private\n */\nconst HeapMathUtils = {\n  /**\n   * Calculate the total number of levels needed for a heap of given size\n   * @param {number} nodeCount - Number of nodes in the heap\n   * @returns {number} Number of levels in the complete binary tree\n   */\n  calculateHeapLevels(nodeCount) {\n    if (nodeCount <= 0) return 0;\n    return Math.floor(Math.log2(nodeCount)) + 1;\n  },\n  /**\n   * Calculate the maximum number of nodes that can exist at a given level\n   * @param {number} level - Level in the tree (0-based, root is 0)\n   * @returns {number} Maximum number of nodes at the level\n   */\n  nodesAtLevel(level) {\n    return Math.pow(2, level);\n  },\n  /**\n   * Calculate the total width needed for the visualization\n   * @param {number} levels - Number of levels in the heap\n   * @param {number} nodeSize - Diameter of each node\n   * @param {number} horizontalSpacing - Horizontal spacing between nodes\n   * @returns {number} Total width required\n   */\n  calculateTotalWidth(levels, nodeSize, horizontalSpacing) {\n    // Widest level has 2^(levels-1) nodes\n    const nodesInWidestLevel = Math.pow(2, levels - 1);\n    // Total width = nodes * (size + spacing)\n    return nodesInWidestLevel * (nodeSize + horizontalSpacing) - horizontalSpacing;\n  },\n  /**\n   * Determine if a node is a leaf node\n   * @param {number} index - Index of the node in the heap array\n   * @param {number} size - Total number of nodes in the heap\n   * @returns {boolean} True if the node is a leaf\n   */\n  isLeafNode(index, size) {\n    return 2 * index + 1 >= size;\n  },\n  /**\n   * Get the parent index for a given node\n   * @param {number} index - Index of the node in the heap array\n   * @returns {number} Index of the parent node, or -1 if root\n   */\n  getParentIndex(index) {\n    if (index <= 0) return -1;\n    return Math.floor((index - 1) / 2);\n  },\n  /**\n   * Get the left child index for a given node\n   * @param {number} index - Index of the node in the heap array\n   * @returns {number} Index of the left child\n   */\n  getLeftChildIndex(index) {\n    return 2 * index + 1;\n  },\n  /**\n   * Get the right child index for a given node\n   * @param {number} index - Index of the node in the heap array\n   * @returns {number} Index of the right child\n   */\n  getRightChildIndex(index) {\n    return 2 * index + 2;\n  },\n  /**\n   * Check if node violates the heap property\n   * @param {Array} values - Array of node values\n   * @param {number} index - Index to check\n   * @param {boolean} isMaxHeap - True if max heap, false if min heap\n   * @returns {boolean} True if heap property is violated\n   */\n  violatesHeapProperty(values, index, isMaxHeap) {\n    const parentIndex = this.getParentIndex(index);\n    if (parentIndex === -1) return false;\n    if (isMaxHeap) {\n      return values[index] > values[parentIndex];\n    } else {\n      return values[index] < values[parentIndex];\n    }\n  }\n};\n\n/**\n * Rendering utilities for heap visualization\n * @namespace HeapRenderUtils\n * @private\n */\nconst HeapRenderUtils = {\n  /**\n   * Draw a node in the heap\n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {number} x - X coordinate of the node center\n   * @param {number} y - Y coordinate of the node center\n   * @param {number} radius - Radius of the node\n   * @param {Object} node - Node data\n   * @param {boolean} highlighted - Whether the node is highlighted\n   * @param {Object} colors - Color configuration\n   */\n  drawNode(ctx, x, y, radius, node, highlighted, colors) {\n    const {\n      value,\n      id,\n      isLeaf\n    } = node;\n    const nodeColor = highlighted ? colors.highlightColor : isLeaf ? colors.leafColor : colors.nodeColor;\n\n    // Draw node circle\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, 2 * Math.PI);\n    ctx.fillStyle = nodeColor;\n    ctx.fill();\n\n    // Draw node outline\n    ctx.strokeStyle = colors.outlineColor;\n    ctx.lineWidth = highlighted ? 3 : 2;\n    ctx.stroke();\n\n    // Draw node value\n    ctx.fillStyle = colors.textColor;\n    ctx.font = `bold ${Math.floor(radius * 0.7)}px Arial, sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(value), x, y);\n\n    // Draw node index below\n    ctx.fillStyle = colors.indexColor;\n    ctx.font = `${Math.floor(radius * 0.45)}px Arial, sans-serif`;\n    ctx.fillText(`idx: ${id}`, x, y + radius + radius * 0.6);\n  },\n  /**\n   * Draw an edge between parent and child nodes\n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {number} parentX - Parent node X coordinate\n   * @param {number} parentY - Parent node Y coordinate\n   * @param {number} childX - Child node X coordinate\n   * @param {number} childY - Child node Y coordinate\n   * @param {boolean} isLeft - True if left child, false if right\n   * @param {boolean} highlighted - Whether the edge is highlighted\n   * @param {Object} colors - Color configuration\n   */\n  drawEdge(ctx, parentX, parentY, childX, childY, isLeft, highlighted, colors) {\n    // Calculate control points for the curve\n    const midX = (parentX + childX) / 2;\n    const midY = (parentY + childY) / 2;\n\n    // Draw edge\n    ctx.beginPath();\n    ctx.moveTo(parentX, parentY);\n    ctx.quadraticCurveTo(midX, midY - 10, childX, childY);\n    ctx.strokeStyle = highlighted ? colors.highlightColor : colors.edgeColor;\n    ctx.lineWidth = highlighted ? 3 : 2;\n    ctx.stroke();\n\n    // Draw small label for edge type (left/right)\n    const labelX = midX + (isLeft ? -10 : 10);\n    const labelY = midY - 10;\n    ctx.fillStyle = colors.edgeLabelColor;\n    ctx.font = '10px Arial, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(isLeft ? 'L' : 'R', labelX, labelY);\n  },\n  /**\n   * Draw a property violation indicator\n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {number} x - X coordinate\n   * @param {number} y - Y coordinate\n   * @param {number} radius - Radius of the warning indicator\n   */\n  drawPropertyViolation(ctx, x, y, radius) {\n    // Draw warning triangle\n    ctx.beginPath();\n    ctx.moveTo(x, y - radius);\n    ctx.lineTo(x + radius, y + radius);\n    ctx.lineTo(x - radius, y + radius);\n    ctx.closePath();\n    ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';\n    ctx.fill();\n    ctx.strokeStyle = '#FF0000';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // Draw exclamation mark\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = `bold ${Math.floor(radius * 1.2)}px Arial, sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('!', x, y);\n  },\n  /**\n   * Create the node coordinate map for the entire heap\n   * @param {number} width - Canvas width\n   * @param {number} height - Canvas height\n   * @param {Array} nodes - Array of node data\n   * @param {number} levels - Number of levels in the heap\n   * @param {number} nodeRadius - Radius of each node\n   * @returns {Map} Map of node IDs to coordinates\n   */\n  createNodeCoordinateMap(width, height, nodes, levels, nodeRadius) {\n    const coordinateMap = new Map();\n    const verticalSpacing = height / (levels + 1);\n    nodes.forEach(node => {\n      const level = Math.floor(Math.log2(node.id + 1));\n      const nodesInLevel = Math.pow(2, level);\n      const horizontalSpacing = width / (nodesInLevel + 1);\n\n      // Position in level (0-indexed)\n      const positionInLevel = node.id - (Math.pow(2, level) - 1);\n\n      // Calculate coordinates\n      const x = (positionInLevel + 1) * horizontalSpacing;\n      const y = (level + 1) * verticalSpacing;\n      coordinateMap.set(node.id, {\n        x,\n        y\n      });\n    });\n    return coordinateMap;\n  }\n};\n\n/**\n * HeapVisualizer component for visualizing binary heap structures\n * \n * @component\n */\nconst HeapVisualizer = ({\n  heapStructure,\n  width = 600,\n  height = 400,\n  nodeRadius = 25,\n  isMaxHeap = true,\n  showPropertyViolations = true,\n  highlightColor = '#FF5722',\n  nodeColor = '#3F51B5',\n  leafColor = '#4CAF50',\n  edgeColor = '#888888',\n  textColor = '#FFFFFF',\n  indexColor = '#333333',\n  outlineColor = '#000000',\n  edgeLabelColor = '#888888',\n  backgroundColor = '#FFFFFF'\n}) => {\n  const canvasRef = useRef(null);\n  const [nodeCoordinates, setNodeCoordinates] = useState(new Map());\n\n  // Derive important values from heap structure\n  const hasHeapData = useMemo(() => {\n    return heapStructure && heapStructure.nodes && heapStructure.nodes.length > 0;\n  }, [heapStructure]);\n  const nodeCount = useMemo(() => {\n    return hasHeapData ? heapStructure.nodes.length : 0;\n  }, [hasHeapData, heapStructure]);\n  const levels = useMemo(() => {\n    return HeapMathUtils.calculateHeapLevels(nodeCount);\n  }, [nodeCount]);\n\n  // Extract node values for heap property checking\n  const nodeValues = useMemo(() => {\n    if (!hasHeapData) return [];\n    return heapStructure.nodes.map(node => node.value);\n  }, [hasHeapData, heapStructure]);\n\n  // Color configuration object for consistent styling\n  const colors = useMemo(() => ({\n    highlightColor,\n    nodeColor,\n    leafColor,\n    edgeColor,\n    textColor,\n    indexColor,\n    outlineColor,\n    edgeLabelColor\n  }), [highlightColor, nodeColor, leafColor, edgeColor, textColor, indexColor, outlineColor, edgeLabelColor]);\n\n  // Initialize node coordinates whenever heap structure changes\n  useEffect(() => {\n    if (!hasHeapData || !canvasRef.current) return;\n    const coordinates = HeapRenderUtils.createNodeCoordinateMap(width, height, heapStructure.nodes, levels, nodeRadius);\n    setNodeCoordinates(coordinates);\n  }, [hasHeapData, heapStructure, width, height, levels, nodeRadius]);\n\n  // Render the heap visualization\n  useEffect(() => {\n    if (!hasHeapData || !canvasRef.current || nodeCoordinates.size === 0) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n\n    // Fill background\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw edges first (so they're behind nodes)\n    heapStructure.edges.forEach(edge => {\n      const fromNode = heapStructure.nodes.find(n => n.id === edge.from);\n      const toNode = heapStructure.nodes.find(n => n.id === edge.to);\n      if (!fromNode || !toNode) return;\n      const fromCoords = nodeCoordinates.get(edge.from);\n      const toCoords = nodeCoordinates.get(edge.to);\n      if (!fromCoords || !toCoords) return;\n      const isHighlighted = heapStructure.highlight !== undefined && (edge.from === heapStructure.highlight || edge.to === heapStructure.highlight);\n      HeapRenderUtils.drawEdge(ctx, fromCoords.x, fromCoords.y, toCoords.x, toCoords.y, edge.type === 'left', isHighlighted, colors);\n    });\n\n    // Draw nodes\n    heapStructure.nodes.forEach(node => {\n      const coords = nodeCoordinates.get(node.id);\n      if (!coords) return;\n      const isHighlighted = heapStructure.highlight !== undefined && node.id === heapStructure.highlight;\n      HeapRenderUtils.drawNode(ctx, coords.x, coords.y, nodeRadius, node, isHighlighted, colors);\n\n      // Check if node violates heap property\n      if (showPropertyViolations && HeapMathUtils.violatesHeapProperty(nodeValues, node.id, isMaxHeap)) {\n        HeapRenderUtils.drawPropertyViolation(ctx, coords.x + nodeRadius * 1.2, coords.y - nodeRadius * 0.8, 8);\n      }\n    });\n\n    // Draw heap information\n    ctx.fillStyle = '#333333';\n    ctx.font = '14px Arial, sans-serif';\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    ctx.fillText(`${isMaxHeap ? 'Max Heap' : 'Min Heap'}: ${isMaxHeap ? 'parent ≥ children' : 'parent ≤ children'}`, 10, 10);\n    ctx.fillText(`Nodes: ${nodeCount}, Levels: ${levels}`, 10, 30);\n\n    // Draw legend\n    const legendY = height - 40;\n\n    // Regular node\n    ctx.beginPath();\n    ctx.arc(30, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = nodeColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.textAlign = 'left';\n    ctx.fillText('Internal Node', 50, legendY - 5);\n\n    // Leaf node\n    ctx.beginPath();\n    ctx.arc(150, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = leafColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Leaf Node', 170, legendY - 5);\n\n    // Highlighted node\n    ctx.beginPath();\n    ctx.arc(270, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = highlightColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Current Node', 290, legendY - 5);\n    if (showPropertyViolations) {\n      HeapRenderUtils.drawPropertyViolation(ctx, 380, legendY, 8);\n      ctx.fillStyle = '#333333';\n      ctx.fillText('Heap Property Violation', 400, legendY - 5);\n    }\n  }, [hasHeapData, heapStructure, nodeCoordinates, width, height, nodeRadius, isMaxHeap, showPropertyViolations, colors, backgroundColor, nodeValues, levels, nodeCount]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"heap-visualizer\",\n    style: {\n      position: 'relative',\n      width,\n      height\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 479,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: canvasRef,\n    width: width,\n    height: height,\n    className: \"heap-canvas\",\n    style: {\n      border: '1px solid #ddd',\n      borderRadius: '4px',\n      backgroundColor\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 480,\n      columnNumber: 7\n    }\n  }), !hasHeapData && /*#__PURE__*/React.createElement(\"div\", {\n    className: \"heap-placeholder\",\n    style: {\n      position: 'absolute',\n      top: '50%',\n      left: '50%',\n      transform: 'translate(-50%, -50%)',\n      color: '#888',\n      fontSize: '16px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 492,\n      columnNumber: 9\n    }\n  }, \"Waiting for heap structure data...\"));\n};\n\n/**\n * PropTypes for HeapVisualizer component\n */\nHeapVisualizer.propTypes = {\n  /**\n   * Heap structure data containing nodes and edges\n   * @type {Object}\n   * @property {Array} nodes - Array of node objects with id, value, level, isLeaf properties\n   * @property {Array} edges - Array of edge objects with from, to, type properties\n   * @property {number} highlight - Index of the highlighted node (optional)\n   */\n  heapStructure: PropTypes.shape({\n    nodes: PropTypes.arrayOf(PropTypes.shape({\n      id: PropTypes.number.isRequired,\n      value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n      level: PropTypes.number,\n      isLeaf: PropTypes.bool\n    })).isRequired,\n    edges: PropTypes.arrayOf(PropTypes.shape({\n      from: PropTypes.number.isRequired,\n      to: PropTypes.number.isRequired,\n      type: PropTypes.oneOf(['left', 'right']).isRequired\n    })).isRequired,\n    highlight: PropTypes.number\n  }),\n  /** Canvas width */\n  width: PropTypes.number,\n  /** Canvas height */\n  height: PropTypes.number,\n  /** Radius of each node */\n  nodeRadius: PropTypes.number,\n  /** Whether visualizing a max heap (true) or min heap (false) */\n  isMaxHeap: PropTypes.bool,\n  /** Whether to show heap property violations */\n  showPropertyViolations: PropTypes.bool,\n  /** Color for highlighted nodes */\n  highlightColor: PropTypes.string,\n  /** Color for internal nodes */\n  nodeColor: PropTypes.string,\n  /** Color for leaf nodes */\n  leafColor: PropTypes.string,\n  /** Color for edges */\n  edgeColor: PropTypes.string,\n  /** Color for node text */\n  textColor: PropTypes.string,\n  /** Color for index text */\n  indexColor: PropTypes.string,\n  /** Color for node outlines */\n  outlineColor: PropTypes.string,\n  /** Color for edge labels */\n  edgeLabelColor: PropTypes.string,\n  /** Background color */\n  backgroundColor: PropTypes.string\n};\n\n/**\n * Default props for HeapVisualizer\n */\nHeapVisualizer.defaultProps = {\n  width: 600,\n  height: 400,\n  nodeRadius: 25,\n  isMaxHeap: true,\n  showPropertyViolations: true,\n  highlightColor: '#FF5722',\n  nodeColor: '#3F51B5',\n  leafColor: '#4CAF50',\n  edgeColor: '#888888',\n  textColor: '#FFFFFF',\n  indexColor: '#333333',\n  outlineColor: '#000000',\n  edgeLabelColor: '#888888',\n  backgroundColor: '#FFFFFF'\n};\nexport default HeapVisualizer;","map":{"version":3,"names":["React","useRef","useEffect","useState","useMemo","PropTypes","HeapMathUtils","calculateHeapLevels","nodeCount","Math","floor","log2","nodesAtLevel","level","pow","calculateTotalWidth","levels","nodeSize","horizontalSpacing","nodesInWidestLevel","isLeafNode","index","size","getParentIndex","getLeftChildIndex","getRightChildIndex","violatesHeapProperty","values","isMaxHeap","parentIndex","HeapRenderUtils","drawNode","ctx","x","y","radius","node","highlighted","colors","value","id","isLeaf","nodeColor","highlightColor","leafColor","beginPath","arc","PI","fillStyle","fill","strokeStyle","outlineColor","lineWidth","stroke","textColor","font","textAlign","textBaseline","fillText","String","indexColor","drawEdge","parentX","parentY","childX","childY","isLeft","midX","midY","moveTo","quadraticCurveTo","edgeColor","labelX","labelY","edgeLabelColor","drawPropertyViolation","lineTo","closePath","createNodeCoordinateMap","width","height","nodes","nodeRadius","coordinateMap","Map","verticalSpacing","forEach","nodesInLevel","positionInLevel","set","HeapVisualizer","heapStructure","showPropertyViolations","backgroundColor","canvasRef","nodeCoordinates","setNodeCoordinates","hasHeapData","length","nodeValues","map","current","coordinates","canvas","getContext","clearRect","fillRect","edges","edge","fromNode","find","n","from","toNode","to","fromCoords","get","toCoords","isHighlighted","highlight","undefined","type","coords","legendY","createElement","className","style","position","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","ref","border","borderRadius","top","left","transform","color","fontSize","propTypes","shape","arrayOf","number","isRequired","oneOfType","string","bool","oneOf","defaultProps"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/visualization/components/HeapVisualizer.js"],"sourcesContent":["// src/visualization/components/heap-visualizer.js\n\n/**\n * @file HeapVisualizer component for binary heap visualization\n * @module HeapVisualizer\n * @author Algorithm Visualization Platform Team\n * @version 1.2.0\n * \n * @description\n * Advanced visualization component for binary heap data structures used in Heap Sort\n * and other heap-based algorithms. This component provides a sophisticated \n * representation of the implicit binary tree structure within an array,\n * with educational annotations and interactive capabilities.\n * \n * The visualization demonstrates the fundamental heap property (max-heap or min-heap)\n * and illustrates parent-child relationships through an optimized Canvas-based\n * rendering system that scales efficiently for heaps of various sizes.\n * \n * Performance characteristics:\n * - Time complexity: O(n) for rendering n nodes\n * - Space complexity: O(n) for internal data structures\n * - Rendering performance: Optimized for heaps with up to 1023 nodes (complete binary tree height 9)\n */\n\nimport React, { useRef, useEffect, useState, useMemo } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * Mathematical and layout utility functions for heap visualization\n * @namespace HeapMathUtils\n * @private\n */\nconst HeapMathUtils = {\n  /**\n   * Calculate the total number of levels needed for a heap of given size\n   * @param {number} nodeCount - Number of nodes in the heap\n   * @returns {number} Number of levels in the complete binary tree\n   */\n  calculateHeapLevels(nodeCount) {\n    if (nodeCount <= 0) return 0;\n    return Math.floor(Math.log2(nodeCount)) + 1;\n  },\n  \n  /**\n   * Calculate the maximum number of nodes that can exist at a given level\n   * @param {number} level - Level in the tree (0-based, root is 0)\n   * @returns {number} Maximum number of nodes at the level\n   */\n  nodesAtLevel(level) {\n    return Math.pow(2, level);\n  },\n  \n  /**\n   * Calculate the total width needed for the visualization\n   * @param {number} levels - Number of levels in the heap\n   * @param {number} nodeSize - Diameter of each node\n   * @param {number} horizontalSpacing - Horizontal spacing between nodes\n   * @returns {number} Total width required\n   */\n  calculateTotalWidth(levels, nodeSize, horizontalSpacing) {\n    // Widest level has 2^(levels-1) nodes\n    const nodesInWidestLevel = Math.pow(2, levels - 1);\n    // Total width = nodes * (size + spacing)\n    return nodesInWidestLevel * (nodeSize + horizontalSpacing) - horizontalSpacing;\n  },\n  \n  /**\n   * Determine if a node is a leaf node\n   * @param {number} index - Index of the node in the heap array\n   * @param {number} size - Total number of nodes in the heap\n   * @returns {boolean} True if the node is a leaf\n   */\n  isLeafNode(index, size) {\n    return 2 * index + 1 >= size;\n  },\n  \n  /**\n   * Get the parent index for a given node\n   * @param {number} index - Index of the node in the heap array\n   * @returns {number} Index of the parent node, or -1 if root\n   */\n  getParentIndex(index) {\n    if (index <= 0) return -1;\n    return Math.floor((index - 1) / 2);\n  },\n  \n  /**\n   * Get the left child index for a given node\n   * @param {number} index - Index of the node in the heap array\n   * @returns {number} Index of the left child\n   */\n  getLeftChildIndex(index) {\n    return 2 * index + 1;\n  },\n  \n  /**\n   * Get the right child index for a given node\n   * @param {number} index - Index of the node in the heap array\n   * @returns {number} Index of the right child\n   */\n  getRightChildIndex(index) {\n    return 2 * index + 2;\n  },\n  \n  /**\n   * Check if node violates the heap property\n   * @param {Array} values - Array of node values\n   * @param {number} index - Index to check\n   * @param {boolean} isMaxHeap - True if max heap, false if min heap\n   * @returns {boolean} True if heap property is violated\n   */\n  violatesHeapProperty(values, index, isMaxHeap) {\n    const parentIndex = this.getParentIndex(index);\n    if (parentIndex === -1) return false;\n    \n    if (isMaxHeap) {\n      return values[index] > values[parentIndex];\n    } else {\n      return values[index] < values[parentIndex];\n    }\n  }\n};\n\n/**\n * Rendering utilities for heap visualization\n * @namespace HeapRenderUtils\n * @private\n */\nconst HeapRenderUtils = {\n  /**\n   * Draw a node in the heap\n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {number} x - X coordinate of the node center\n   * @param {number} y - Y coordinate of the node center\n   * @param {number} radius - Radius of the node\n   * @param {Object} node - Node data\n   * @param {boolean} highlighted - Whether the node is highlighted\n   * @param {Object} colors - Color configuration\n   */\n  drawNode(ctx, x, y, radius, node, highlighted, colors) {\n    const { value, id, isLeaf } = node;\n    const nodeColor = highlighted ? colors.highlightColor : \n                     (isLeaf ? colors.leafColor : colors.nodeColor);\n    \n    // Draw node circle\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, 2 * Math.PI);\n    ctx.fillStyle = nodeColor;\n    ctx.fill();\n    \n    // Draw node outline\n    ctx.strokeStyle = colors.outlineColor;\n    ctx.lineWidth = highlighted ? 3 : 2;\n    ctx.stroke();\n    \n    // Draw node value\n    ctx.fillStyle = colors.textColor;\n    ctx.font = `bold ${Math.floor(radius * 0.7)}px Arial, sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(value), x, y);\n    \n    // Draw node index below\n    ctx.fillStyle = colors.indexColor;\n    ctx.font = `${Math.floor(radius * 0.45)}px Arial, sans-serif`;\n    ctx.fillText(`idx: ${id}`, x, y + radius + radius * 0.6);\n  },\n  \n  /**\n   * Draw an edge between parent and child nodes\n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {number} parentX - Parent node X coordinate\n   * @param {number} parentY - Parent node Y coordinate\n   * @param {number} childX - Child node X coordinate\n   * @param {number} childY - Child node Y coordinate\n   * @param {boolean} isLeft - True if left child, false if right\n   * @param {boolean} highlighted - Whether the edge is highlighted\n   * @param {Object} colors - Color configuration\n   */\n  drawEdge(ctx, parentX, parentY, childX, childY, isLeft, highlighted, colors) {\n    // Calculate control points for the curve\n    const midX = (parentX + childX) / 2;\n    const midY = (parentY + childY) / 2;\n    \n    // Draw edge\n    ctx.beginPath();\n    ctx.moveTo(parentX, parentY);\n    ctx.quadraticCurveTo(midX, midY - 10, childX, childY);\n    \n    ctx.strokeStyle = highlighted ? colors.highlightColor : colors.edgeColor;\n    ctx.lineWidth = highlighted ? 3 : 2;\n    ctx.stroke();\n    \n    // Draw small label for edge type (left/right)\n    const labelX = midX + (isLeft ? -10 : 10);\n    const labelY = midY - 10;\n    \n    ctx.fillStyle = colors.edgeLabelColor;\n    ctx.font = '10px Arial, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(isLeft ? 'L' : 'R', labelX, labelY);\n  },\n  \n  /**\n   * Draw a property violation indicator\n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {number} x - X coordinate\n   * @param {number} y - Y coordinate\n   * @param {number} radius - Radius of the warning indicator\n   */\n  drawPropertyViolation(ctx, x, y, radius) {\n    // Draw warning triangle\n    ctx.beginPath();\n    ctx.moveTo(x, y - radius);\n    ctx.lineTo(x + radius, y + radius);\n    ctx.lineTo(x - radius, y + radius);\n    ctx.closePath();\n    \n    ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';\n    ctx.fill();\n    \n    ctx.strokeStyle = '#FF0000';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    \n    // Draw exclamation mark\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = `bold ${Math.floor(radius * 1.2)}px Arial, sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('!', x, y);\n  },\n  \n  /**\n   * Create the node coordinate map for the entire heap\n   * @param {number} width - Canvas width\n   * @param {number} height - Canvas height\n   * @param {Array} nodes - Array of node data\n   * @param {number} levels - Number of levels in the heap\n   * @param {number} nodeRadius - Radius of each node\n   * @returns {Map} Map of node IDs to coordinates\n   */\n  createNodeCoordinateMap(width, height, nodes, levels, nodeRadius) {\n    const coordinateMap = new Map();\n    const verticalSpacing = height / (levels + 1);\n    \n    nodes.forEach(node => {\n      const level = Math.floor(Math.log2(node.id + 1));\n      const nodesInLevel = Math.pow(2, level);\n      const horizontalSpacing = width / (nodesInLevel + 1);\n      \n      // Position in level (0-indexed)\n      const positionInLevel = node.id - (Math.pow(2, level) - 1);\n      \n      // Calculate coordinates\n      const x = (positionInLevel + 1) * horizontalSpacing;\n      const y = (level + 1) * verticalSpacing;\n      \n      coordinateMap.set(node.id, { x, y });\n    });\n    \n    return coordinateMap;\n  }\n};\n\n/**\n * HeapVisualizer component for visualizing binary heap structures\n * \n * @component\n */\nconst HeapVisualizer = ({\n  heapStructure,\n  width = 600,\n  height = 400,\n  nodeRadius = 25,\n  isMaxHeap = true,\n  showPropertyViolations = true,\n  highlightColor = '#FF5722',\n  nodeColor = '#3F51B5',\n  leafColor = '#4CAF50',\n  edgeColor = '#888888',\n  textColor = '#FFFFFF',\n  indexColor = '#333333',\n  outlineColor = '#000000',\n  edgeLabelColor = '#888888',\n  backgroundColor = '#FFFFFF'\n}) => {\n  const canvasRef = useRef(null);\n  const [nodeCoordinates, setNodeCoordinates] = useState(new Map());\n  \n  // Derive important values from heap structure\n  const hasHeapData = useMemo(() => {\n    return heapStructure && heapStructure.nodes && heapStructure.nodes.length > 0;\n  }, [heapStructure]);\n  \n  const nodeCount = useMemo(() => {\n    return hasHeapData ? heapStructure.nodes.length : 0;\n  }, [hasHeapData, heapStructure]);\n  \n  const levels = useMemo(() => {\n    return HeapMathUtils.calculateHeapLevels(nodeCount);\n  }, [nodeCount]);\n  \n  // Extract node values for heap property checking\n  const nodeValues = useMemo(() => {\n    if (!hasHeapData) return [];\n    return heapStructure.nodes.map(node => node.value);\n  }, [hasHeapData, heapStructure]);\n  \n  // Color configuration object for consistent styling\n  const colors = useMemo(() => ({\n    highlightColor,\n    nodeColor,\n    leafColor,\n    edgeColor,\n    textColor,\n    indexColor,\n    outlineColor,\n    edgeLabelColor\n  }), [\n    highlightColor,\n    nodeColor,\n    leafColor,\n    edgeColor,\n    textColor,\n    indexColor,\n    outlineColor,\n    edgeLabelColor\n  ]);\n  \n  // Initialize node coordinates whenever heap structure changes\n  useEffect(() => {\n    if (!hasHeapData || !canvasRef.current) return;\n    \n    const coordinates = HeapRenderUtils.createNodeCoordinateMap(\n      width,\n      height,\n      heapStructure.nodes,\n      levels,\n      nodeRadius\n    );\n    \n    setNodeCoordinates(coordinates);\n  }, [hasHeapData, heapStructure, width, height, levels, nodeRadius]);\n  \n  // Render the heap visualization\n  useEffect(() => {\n    if (!hasHeapData || !canvasRef.current || nodeCoordinates.size === 0) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    // Fill background\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Draw edges first (so they're behind nodes)\n    heapStructure.edges.forEach(edge => {\n      const fromNode = heapStructure.nodes.find(n => n.id === edge.from);\n      const toNode = heapStructure.nodes.find(n => n.id === edge.to);\n      \n      if (!fromNode || !toNode) return;\n      \n      const fromCoords = nodeCoordinates.get(edge.from);\n      const toCoords = nodeCoordinates.get(edge.to);\n      \n      if (!fromCoords || !toCoords) return;\n      \n      const isHighlighted = \n        heapStructure.highlight !== undefined && \n        (edge.from === heapStructure.highlight || edge.to === heapStructure.highlight);\n      \n      HeapRenderUtils.drawEdge(\n        ctx,\n        fromCoords.x,\n        fromCoords.y,\n        toCoords.x,\n        toCoords.y,\n        edge.type === 'left',\n        isHighlighted,\n        colors\n      );\n    });\n    \n    // Draw nodes\n    heapStructure.nodes.forEach(node => {\n      const coords = nodeCoordinates.get(node.id);\n      if (!coords) return;\n      \n      const isHighlighted = heapStructure.highlight !== undefined && node.id === heapStructure.highlight;\n      \n      HeapRenderUtils.drawNode(\n        ctx,\n        coords.x,\n        coords.y,\n        nodeRadius,\n        node,\n        isHighlighted,\n        colors\n      );\n      \n      // Check if node violates heap property\n      if (showPropertyViolations && HeapMathUtils.violatesHeapProperty(nodeValues, node.id, isMaxHeap)) {\n        HeapRenderUtils.drawPropertyViolation(\n          ctx,\n          coords.x + nodeRadius * 1.2,\n          coords.y - nodeRadius * 0.8,\n          8\n        );\n      }\n    });\n    \n    // Draw heap information\n    ctx.fillStyle = '#333333';\n    ctx.font = '14px Arial, sans-serif';\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    ctx.fillText(`${isMaxHeap ? 'Max Heap' : 'Min Heap'}: ${isMaxHeap ? 'parent ≥ children' : 'parent ≤ children'}`, 10, 10);\n    ctx.fillText(`Nodes: ${nodeCount}, Levels: ${levels}`, 10, 30);\n    \n    // Draw legend\n    const legendY = height - 40;\n    \n    // Regular node\n    ctx.beginPath();\n    ctx.arc(30, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = nodeColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.textAlign = 'left';\n    ctx.fillText('Internal Node', 50, legendY - 5);\n    \n    // Leaf node\n    ctx.beginPath();\n    ctx.arc(150, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = leafColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Leaf Node', 170, legendY - 5);\n    \n    // Highlighted node\n    ctx.beginPath();\n    ctx.arc(270, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = highlightColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Current Node', 290, legendY - 5);\n    \n    if (showPropertyViolations) {\n      HeapRenderUtils.drawPropertyViolation(ctx, 380, legendY, 8);\n      ctx.fillStyle = '#333333';\n      ctx.fillText('Heap Property Violation', 400, legendY - 5);\n    }\n    \n  }, [\n    hasHeapData, \n    heapStructure, \n    nodeCoordinates, \n    width, \n    height, \n    nodeRadius, \n    isMaxHeap, \n    showPropertyViolations,\n    colors,\n    backgroundColor,\n    nodeValues,\n    levels,\n    nodeCount\n  ]);\n  \n  return (\n    <div className=\"heap-visualizer\" style={{ position: 'relative', width, height }}>\n      <canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        className=\"heap-canvas\"\n        style={{ \n          border: '1px solid #ddd', \n          borderRadius: '4px',\n          backgroundColor\n        }}\n      />\n      {!hasHeapData && (\n        <div className=\"heap-placeholder\" style={{ \n          position: 'absolute', \n          top: '50%', \n          left: '50%', \n          transform: 'translate(-50%, -50%)',\n          color: '#888',\n          fontSize: '16px'\n        }}>\n          Waiting for heap structure data...\n        </div>\n      )}\n    </div>\n  );\n};\n\n/**\n * PropTypes for HeapVisualizer component\n */\nHeapVisualizer.propTypes = {\n  /**\n   * Heap structure data containing nodes and edges\n   * @type {Object}\n   * @property {Array} nodes - Array of node objects with id, value, level, isLeaf properties\n   * @property {Array} edges - Array of edge objects with from, to, type properties\n   * @property {number} highlight - Index of the highlighted node (optional)\n   */\n  heapStructure: PropTypes.shape({\n    nodes: PropTypes.arrayOf(\n      PropTypes.shape({\n        id: PropTypes.number.isRequired,\n        value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n        level: PropTypes.number,\n        isLeaf: PropTypes.bool\n      })\n    ).isRequired,\n    edges: PropTypes.arrayOf(\n      PropTypes.shape({\n        from: PropTypes.number.isRequired,\n        to: PropTypes.number.isRequired,\n        type: PropTypes.oneOf(['left', 'right']).isRequired\n      })\n    ).isRequired,\n    highlight: PropTypes.number\n  }),\n  \n  /** Canvas width */\n  width: PropTypes.number,\n  \n  /** Canvas height */\n  height: PropTypes.number,\n  \n  /** Radius of each node */\n  nodeRadius: PropTypes.number,\n  \n  /** Whether visualizing a max heap (true) or min heap (false) */\n  isMaxHeap: PropTypes.bool,\n  \n  /** Whether to show heap property violations */\n  showPropertyViolations: PropTypes.bool,\n  \n  /** Color for highlighted nodes */\n  highlightColor: PropTypes.string,\n  \n  /** Color for internal nodes */\n  nodeColor: PropTypes.string,\n  \n  /** Color for leaf nodes */\n  leafColor: PropTypes.string,\n  \n  /** Color for edges */\n  edgeColor: PropTypes.string,\n  \n  /** Color for node text */\n  textColor: PropTypes.string,\n  \n  /** Color for index text */\n  indexColor: PropTypes.string,\n  \n  /** Color for node outlines */\n  outlineColor: PropTypes.string,\n  \n  /** Color for edge labels */\n  edgeLabelColor: PropTypes.string,\n  \n  /** Background color */\n  backgroundColor: PropTypes.string\n};\n\n/**\n * Default props for HeapVisualizer\n */\nHeapVisualizer.defaultProps = {\n  width: 600,\n  height: 400,\n  nodeRadius: 25,\n  isMaxHeap: true,\n  showPropertyViolations: true,\n  highlightColor: '#FF5722',\n  nodeColor: '#3F51B5',\n  leafColor: '#4CAF50',\n  edgeColor: '#888888',\n  textColor: '#FFFFFF',\n  indexColor: '#333333',\n  outlineColor: '#000000',\n  edgeLabelColor: '#888888',\n  backgroundColor: '#FFFFFF'\n};\n\nexport default HeapVisualizer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}