{"ast":null,"code":"// src/algorithms/distribution/radix.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Radix Sort with both LSD and MSD variants.\n * \n * Radix Sort is a non-comparison integer sorting algorithm that processes\n * individual digits, sorting numbers by their positional notation. It has\n * two primary variants:\n * \n * 1. LSD (Least Significant Digit): Processes digits from right to left\n *    - Stable sort\n *    - Simpler implementation\n *    - Requires a single pass through the data for each digit position\n * \n * 2. MSD (Most Significant Digit): Processes digits from left to right\n *    - Not inherently stable without extra work\n *    - More complex recursive implementation\n *    - Can early-terminate for partially ordered data\n * \n * Time Complexity: O(w * n) where w is the number of digits and n is the array size\n * Space Complexity: O(n + k) where k is the range of digit values (typically 10 for decimal)\n * \n * @class RadixSort\n * @extends Algorithm\n */\nclass RadixSort extends Algorithm {\n  /**\n   * Create a new RadixSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {string} [options.variant='lsd'] - Variant to use: 'lsd' or 'msd'\n   * @param {number} [options.radix=10] - The base of the number system (default: decimal)\n   * @param {boolean} [options.useCountingSort=true] - Use counting sort for digit sorting\n   * @param {boolean} [options.inPlace=false] - Attempt to use less auxiliary memory (MSD only)\n   * @param {boolean} [options.stable=true] - Ensure stability (matters for MSD)\n   */\n  constructor(options = {}) {\n    super('Radix Sort', 'distribution', options);\n\n    // Default options\n    this.options = {\n      variant: 'lsd',\n      // 'lsd' (Least Significant Digit) or 'msd' (Most Significant Digit)\n      radix: 10,\n      // Base of the number system (default: decimal)\n      useCountingSort: true,\n      // Use counting sort for digit sorting\n      inPlace: false,\n      // Attempt to use less auxiliary memory (MSD only)\n      stable: true,\n      // Ensure stability (matters for MSD)\n      ...options\n    };\n  }\n\n  /**\n   * Execute Radix Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('analysis');\n\n    // Find the maximum number to determine number of digits\n    let max = Math.abs(result[0]);\n    for (let i = 1; i < n; i++) {\n      max = Math.max(max, Math.abs(result[i]));\n    }\n\n    // Handle arrays with negative numbers\n    const hasNegative = result.some(num => num < 0);\n\n    // Record initial state\n    this.recordState(result, {\n      type: 'initialization',\n      max: max,\n      hasNegative: hasNegative,\n      message: `Analyzing input: max value = ${max}, contains negative numbers: ${hasNegative}`\n    });\n\n    // Choose sorting implementation based on variant\n    if (options.variant === 'msd') {\n      if (hasNegative) {\n        // Handle negative numbers for MSD variant\n        this.handleNegativeNumbersMSD(result, max, options);\n      } else {\n        // Sort positive numbers with MSD Radix Sort\n        this.msdRadixSort(result, 0, n - 1, this.getMaxDigitCount(max, options.radix), options);\n      }\n    } else {\n      // Default to LSD variant\n      if (hasNegative) {\n        // Handle negative numbers for LSD variant\n        this.handleNegativeNumbersLSD(result, max, options);\n      } else {\n        // Sort positive numbers with LSD Radix Sort\n        this.lsdRadixSort(result, max, options);\n      }\n    }\n    this.setPhase('completed');\n    return result;\n  }\n\n  /**\n   * LSD (Least Significant Digit) Radix Sort implementation\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} max - Maximum value in the array\n   * @param {Object} options - Runtime options\n   */\n  lsdRadixSort(array, max, options) {\n    this.setPhase('lsd-sorting');\n    const n = array.length;\n    const radix = options.radix;\n\n    // Get the number of digits in the maximum number\n    const maxDigitCount = this.getMaxDigitCount(max, radix);\n    this.recordState(array, {\n      type: 'radix-info',\n      radix: radix,\n      maxDigits: maxDigitCount,\n      message: `Starting LSD Radix Sort with base ${radix}, maximum of ${maxDigitCount} digits`\n    });\n\n    // Process each digit position, starting from the least significant (rightmost)\n    let exp = 1; // Start with the 1's place\n    for (let digitPlace = 0; digitPlace < maxDigitCount; digitPlace++) {\n      // Record current digit position\n      this.recordState(array, {\n        type: 'digit-position',\n        position: digitPlace,\n        exponent: exp,\n        message: `Sorting by digit position ${digitPlace} (${exp}'s place)`\n      });\n\n      // Sort array elements according to the current digit\n      if (options.useCountingSort) {\n        this.countingSortByDigit(array, exp, radix, options);\n      } else {\n        this.bucketSortByDigit(array, exp, radix, options);\n      }\n\n      // Move to next digit position\n      exp *= radix;\n\n      // Record the array state after sorting this digit position\n      this.recordState(array, {\n        type: 'lsd-pass-complete',\n        position: digitPlace,\n        message: `Completed sorting pass for digit position ${digitPlace}`\n      });\n    }\n  }\n\n  /**\n   * MSD (Most Significant Digit) Radix Sort implementation\n   * Recursive implementation that sorts from most significant to least significant digit\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} start - Start index for current recursion\n   * @param {number} end - End index for current recursion\n   * @param {number} digitPosition - Current digit position (max to 0)\n   * @param {Object} options - Runtime options\n   */\n  msdRadixSort(array, start, end, digitPosition, options) {\n    this.setPhase('msd-sorting');\n\n    // Base cases\n    if (start >= end || digitPosition < 0) {\n      return;\n    }\n\n    // Small subarray optimization\n    if (end - start < 10) {\n      this.insertionSort(array, start, end);\n      return;\n    }\n    const radix = options.radix;\n    const exp = Math.pow(radix, digitPosition);\n\n    // Record the current recursion state\n    this.recordState(array, {\n      type: 'msd-recursion',\n      start: start,\n      end: end,\n      digitPosition: digitPosition,\n      exponent: exp,\n      message: `MSD sorting from index ${start} to ${end} at digit position ${digitPosition}`\n    });\n\n    // Use counting sort to order by the current digit\n    if (options.useCountingSort) {\n      this.countingSortByDigitRange(array, exp, radix, start, end, options);\n    } else {\n      // Alternative: bucket sort for this digit\n      this.bucketSortByDigitRange(array, exp, radix, start, end, options);\n    }\n\n    // Now recursively sort each bucket (group of elements with the same digit)\n    const digitCounts = new Array(radix).fill(0);\n\n    // Count the frequency of each digit value at the current position\n    for (let i = start; i <= end; i++) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      digitCounts[digit]++;\n    }\n\n    // Calculate starting position of each digit group\n    let startIndex = start;\n    for (let digit = 0; digit < radix; digit++) {\n      const count = digitCounts[digit];\n      if (count > 0) {\n        const endIndex = startIndex + count - 1;\n\n        // Record the bucket boundaries\n        this.recordState(array, {\n          type: 'msd-bucket',\n          digit: digit,\n          start: startIndex,\n          end: endIndex,\n          message: `Processing bucket for digit value ${digit} (indices ${startIndex} to ${endIndex})`\n        });\n\n        // Recursively sort this bucket by the next digit position\n        this.msdRadixSort(array, startIndex, endIndex, digitPosition - 1, options);\n        startIndex = endIndex + 1;\n      }\n    }\n  }\n\n  /**\n   * Sort array elements by a specific digit using counting sort\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} exp - Exponent for the current digit position (1, 10, 100, etc.)\n   * @param {number} radix - Base of the number system\n   * @param {Object} options - Runtime options\n   */\n  countingSortByDigit(array, exp, radix, options) {\n    const n = array.length;\n    const output = new Array(n).fill(0);\n    const count = new Array(radix).fill(0);\n\n    // Store count of occurrences of each digit\n    for (let i = 0; i < n; i++) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      count[digit]++;\n\n      // Record the digit extraction\n      if (i % Math.max(1, Math.floor(n / 10)) === 0) {\n        // Record only some steps for large arrays\n        this.recordState(array, {\n          type: 'digit-extraction',\n          index: i,\n          value: array[i],\n          digit: digit,\n          position: exp,\n          message: `Extracted digit ${digit} at position ${exp} from value ${array[i]}`\n        });\n      }\n    }\n\n    // Record the digit counts\n    this.recordState(array, {\n      type: 'digit-counts',\n      counts: [...count],\n      message: `Digit frequency counts at position ${exp}: [${count.join(', ')}]`\n    });\n\n    // Change count[i] so that count[i] contains the position of this digit in output[]\n    for (let i = 1; i < radix; i++) {\n      count[i] += count[i - 1];\n    }\n\n    // Record the cumulative counts\n    this.recordState(array, {\n      type: 'cumulative-counts',\n      counts: [...count],\n      message: `Cumulative counts for stable positioning: [${count.join(', ')}]`\n    });\n\n    // Build the output array\n    // Process elements in reverse to maintain stability\n    for (let i = n - 1; i >= 0; i--) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      const position = count[digit] - 1;\n      output[position] = array[i];\n      count[digit]--;\n\n      // Record significant placement operations\n      if (i % Math.max(1, Math.floor(n / 10)) === 0) {\n        // Record only some steps for large arrays\n        this.recordState([...array], {\n          type: 'element-placement',\n          index: i,\n          value: array[i],\n          digit: digit,\n          position: position,\n          message: `Placing element ${array[i]} with digit ${digit} at output position ${position}`\n        });\n      }\n    }\n\n    // Copy the output array to the original array\n    for (let i = 0; i < n; i++) {\n      this.write(array, i, output[i]);\n    }\n\n    // Record the completed pass\n    this.recordState(array, {\n      type: 'counting-sort-complete',\n      exponent: exp,\n      message: `Completed counting sort pass for digit position ${exp}`\n    });\n  }\n\n  /**\n   * Sort a range of array elements by a specific digit using counting sort\n   * Used for MSD Radix Sort on subarrays\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} exp - Exponent for the current digit position\n   * @param {number} radix - Base of the number system\n   * @param {number} start - Start index of the range\n   * @param {number} end - End index of the range\n   * @param {Object} options - Runtime options\n   */\n  countingSortByDigitRange(array, exp, radix, start, end, options) {\n    const range = end - start + 1;\n    const output = new Array(range);\n    const count = new Array(radix).fill(0);\n\n    // Store count of occurrences of each digit in the range\n    for (let i = start; i <= end; i++) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      count[digit]++;\n    }\n\n    // Record the digit counts\n    this.recordState(array, {\n      type: 'digit-counts',\n      counts: [...count],\n      start: start,\n      end: end,\n      message: `Digit frequency counts at position ${exp} for range [${start}..${end}]: [${count.join(', ')}]`\n    });\n\n    // Change count[i] so that count[i] contains the position of this digit in output[]\n    for (let i = 1; i < radix; i++) {\n      count[i] += count[i - 1];\n    }\n\n    // Build the output array\n    // Process elements in reverse to maintain stability\n    for (let i = end; i >= start; i--) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      const position = count[digit] - 1;\n      output[position] = array[i];\n      count[digit]--;\n\n      // Record significant placement operations\n      if ((i - start) % Math.max(1, Math.floor(range / 10)) === 0) {\n        this.recordState([...array], {\n          type: 'element-placement',\n          index: i,\n          value: array[i],\n          digit: digit,\n          message: `Placing element ${array[i]} with digit ${digit} in output`\n        });\n      }\n    }\n\n    // Copy back to original array\n    for (let i = 0; i < range; i++) {\n      this.write(array, start + i, output[i]);\n    }\n\n    // Record the completed pass\n    this.recordState(array, {\n      type: 'counting-sort-complete',\n      exponent: exp,\n      start: start,\n      end: end,\n      message: `Completed counting sort pass for digit position ${exp} in range [${start}..${end}]`\n    });\n  }\n\n  /**\n   * Sort array elements by a specific digit using bucket sort approach\n   * Alternative to counting sort for digit sorting\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} exp - Exponent for the current digit position\n   * @param {number} radix - Base of the number system\n   * @param {Object} options - Runtime options\n   */\n  bucketSortByDigit(array, exp, radix, options) {\n    const n = array.length;\n    const buckets = Array.from({\n      length: radix\n    }, () => []);\n\n    // Distribute elements into buckets based on the current digit\n    for (let i = 0; i < n; i++) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      buckets[digit].push(array[i]);\n\n      // Record bucket distribution\n      if (i % Math.max(1, Math.floor(n / 10)) === 0) {\n        this.recordState([...array], {\n          type: 'bucket-distribution',\n          index: i,\n          value: array[i],\n          digit: digit,\n          message: `Placing ${array[i]} into bucket ${digit} (${exp}'s place digit)`\n        });\n      }\n    }\n\n    // Record bucket state\n    this.recordState(array, {\n      type: 'buckets-filled',\n      buckets: buckets.map(b => [...b]),\n      message: `Elements distributed into ${radix} buckets by digit at position ${exp}`\n    });\n\n    // Concatenate all buckets back into the original array\n    let index = 0;\n    for (let digit = 0; digit < radix; digit++) {\n      const bucket = buckets[digit];\n\n      // Record that we're processing this bucket\n      if (bucket.length > 0) {\n        this.recordState([...array], {\n          type: 'bucket-processing',\n          digit: digit,\n          bucketSize: bucket.length,\n          message: `Transferring ${bucket.length} elements from bucket ${digit} back to array`\n        });\n      }\n      for (let j = 0; j < bucket.length; j++) {\n        this.write(array, index++, bucket[j]);\n      }\n    }\n\n    // Record the completed pass\n    this.recordState(array, {\n      type: 'bucket-sort-complete',\n      exponent: exp,\n      message: `Completed bucket sort pass for digit position ${exp}`\n    });\n  }\n\n  /**\n   * Sort a range of array elements by a specific digit using bucket sort\n   * Used for MSD Radix Sort on subarrays\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} exp - Exponent for the current digit position\n   * @param {number} radix - Base of the number system\n   * @param {number} start - Start index of the range\n   * @param {number} end - End index of the range\n   * @param {Object} options - Runtime options\n   */\n  bucketSortByDigitRange(array, exp, radix, start, end, options) {\n    const range = end - start + 1;\n    const buckets = Array.from({\n      length: radix\n    }, () => []);\n\n    // Distribute elements into buckets\n    for (let i = start; i <= end; i++) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      buckets[digit].push(array[i]);\n    }\n\n    // Record bucket state\n    this.recordState(array, {\n      type: 'buckets-filled',\n      buckets: buckets.map(b => [...b]),\n      start: start,\n      end: end,\n      message: `Elements from range [${start}..${end}] distributed into buckets by digit at position ${exp}`\n    });\n\n    // Concatenate buckets back into the original array\n    let index = start;\n    for (let digit = 0; digit < radix; digit++) {\n      const bucket = buckets[digit];\n      for (let j = 0; j < bucket.length; j++) {\n        this.write(array, index++, bucket[j]);\n      }\n    }\n\n    // Record the completed pass\n    this.recordState(array, {\n      type: 'bucket-sort-complete',\n      exponent: exp,\n      start: start,\n      end: end,\n      message: `Completed bucket sort pass for digit position ${exp} in range [${start}..${end}]`\n    });\n  }\n\n  /**\n   * Simple insertion sort for small subarrays\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} start - Start index\n   * @param {number} end - End index\n   */\n  insertionSort(array, start, end) {\n    for (let i = start + 1; i <= end; i++) {\n      const key = this.read(array, i);\n      let j = i - 1;\n      while (j >= start && this.compare(this.read(array, j), key) > 0) {\n        this.write(array, j + 1, this.read(array, j));\n        j--;\n      }\n      this.write(array, j + 1, key);\n    }\n    this.recordState(array, {\n      type: 'insertion-sort',\n      start: start,\n      end: end,\n      message: `Applied insertion sort on small range [${start}..${end}]`\n    });\n  }\n\n  /**\n   * Handle arrays with negative numbers for LSD variant\n   * \n   * @param {Array} array - Array containing negative numbers\n   * @param {number} max - Maximum absolute value in the array\n   * @param {Object} options - Runtime options\n   */\n  handleNegativeNumbersLSD(array, max, options) {\n    this.setPhase('handling-negatives');\n    const n = array.length;\n    const positives = [];\n    const negatives = [];\n\n    // Separate positive and negative numbers\n    for (let i = 0; i < n; i++) {\n      const value = this.read(array, i);\n      if (value < 0) {\n        negatives.push(-value); // Store absolute value for sorting\n      } else {\n        positives.push(value);\n      }\n    }\n    this.recordState(array, {\n      type: 'negative-handling',\n      positiveCount: positives.length,\n      negativeCount: negatives.length,\n      message: `Separated into ${positives.length} positive and ${negatives.length} negative numbers`\n    });\n\n    // Sort positive and negative parts separately\n    if (positives.length > 0) {\n      this.lsdRadixSort(positives, max, options);\n    }\n    if (negatives.length > 0) {\n      this.lsdRadixSort(negatives, max, options);\n      // Reverse and negate the sorted negative numbers\n      negatives.reverse();\n      for (let i = 0; i < negatives.length; i++) {\n        negatives[i] = -negatives[i];\n      }\n    }\n\n    // Combine the results: negatives followed by positives\n    const combined = [...negatives, ...positives];\n\n    // Copy back to the original array\n    for (let i = 0; i < n; i++) {\n      this.write(array, i, combined[i]);\n    }\n    this.recordState(array, {\n      type: 'negatives-combined',\n      message: `Combined sorted negative and positive partitions`\n    });\n  }\n\n  /**\n   * Handle arrays with negative numbers for MSD variant\n   * \n   * @param {Array} array - Array containing negative numbers\n   * @param {number} max - Maximum absolute value in the array\n   * @param {Object} options - Runtime options\n   */\n  handleNegativeNumbersMSD(array, max, options) {\n    this.setPhase('handling-negatives');\n    const n = array.length;\n    const positives = [];\n    const negatives = [];\n\n    // Separate positive and negative numbers\n    for (let i = 0; i < n; i++) {\n      const value = this.read(array, i);\n      if (value < 0) {\n        negatives.push(-value); // Store absolute value for sorting\n      } else {\n        positives.push(value);\n      }\n    }\n    this.recordState(array, {\n      type: 'negative-handling',\n      positiveCount: positives.length,\n      negativeCount: negatives.length,\n      message: `Separated into ${positives.length} positive and ${negatives.length} negative numbers`\n    });\n\n    // Sort positive and negative parts separately with MSD\n    const maxDigits = this.getMaxDigitCount(max, options.radix);\n    if (positives.length > 0) {\n      this.msdRadixSort(positives, 0, positives.length - 1, maxDigits - 1, options);\n    }\n    if (negatives.length > 0) {\n      this.msdRadixSort(negatives, 0, negatives.length - 1, maxDigits - 1, options);\n      // Reverse and negate the sorted negative numbers\n      negatives.reverse();\n      for (let i = 0; i < negatives.length; i++) {\n        negatives[i] = -negatives[i];\n      }\n    }\n\n    // Combine the results: negatives followed by positives\n    const combined = [...negatives, ...positives];\n\n    // Copy back to the original array\n    for (let i = 0; i < n; i++) {\n      this.write(array, i, combined[i]);\n    }\n    this.recordState(array, {\n      type: 'negatives-combined',\n      message: `Combined sorted negative and positive partitions`\n    });\n  }\n\n  /**\n   * Calculate the number of digits in a number given a radix\n   * \n   * @param {number} num - Number to analyze\n   * @param {number} radix - Base of the number system\n   * @returns {number} - Number of digits\n   */\n  getMaxDigitCount(num, radix) {\n    if (num === 0) return 1;\n    return Math.floor(Math.log(num) / Math.log(radix)) + 1;\n  }\n\n  /**\n   * Get the time and space complexity of Radix Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    const variant = this.options.variant;\n    return {\n      time: {\n        best: 'O(w * n)',\n        average: 'O(w * n)',\n        worst: 'O(w * n)'\n      },\n      space: {\n        best: variant === 'msd' && this.options.inPlace ? 'O(log n)' : 'O(n + k)',\n        average: 'O(n + k)',\n        worst: 'O(n + k)'\n      }\n    };\n  }\n\n  /**\n   * Whether Radix Sort is stable\n   * \n   * @returns {boolean} - True if LSD variant or if MSD with stability option\n   */\n  isStable() {\n    return this.options.variant === 'lsd' || this.options.variant === 'msd' && this.options.stable;\n  }\n\n  /**\n   * Whether Radix Sort is in-place\n   * \n   * @returns {boolean} - False as Radix Sort requires auxiliary space\n   */\n  isInPlace() {\n    return false; // Standard implementation requires O(n) auxiliary space\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add radix sort specific information\n    info.optimization = {\n      variant: this.options.variant,\n      radix: this.options.radix,\n      useCountingSort: this.options.useCountingSort,\n      inPlace: this.options.inPlace,\n      stable: this.options.stable\n    };\n    info.properties = {\n      comparisonBased: false,\n      stable: this.isStable(),\n      inPlace: this.isInPlace(),\n      online: false,\n      divideAndConquer: this.options.variant === 'msd'\n    };\n    info.suitable = {\n      smallArrays: false,\n      integerData: true,\n      fixedLengthKeys: true,\n      limitedRange: true,\n      stringData: true\n    };\n    info.variants = ['Least Significant Digit (LSD) Radix Sort', 'Most Significant Digit (MSD) Radix Sort', 'American Flag Sort (more efficient MSD variant)', 'Flashsort (MSD variant)', 'In-place MSD Radix Sort'];\n    info.advantages = ['Linear time complexity O(w * n) independent of input distribution', 'Can be faster than O(n log n) comparison sorts for fixed-length keys', 'Stable (for LSD variant)', 'Suitable for parallel implementation', 'Good for string/integer sorting with fixed-length keys'];\n    info.disadvantages = ['Limited to integers and strings (lexicographical ordering)', 'Space intensive due to auxiliary memory requirements', 'Performance highly dependent on key length and distribution', 'Often slower than quicksort for general purpose sorting', 'Complex implementation for variable-length keys'];\n    return info;\n  }\n}\nexport default RadixSort;","map":{"version":3,"names":["Algorithm","RadixSort","constructor","options","variant","radix","useCountingSort","inPlace","stable","run","array","result","n","length","setPhase","max","Math","abs","i","hasNegative","some","num","recordState","type","message","handleNegativeNumbersMSD","msdRadixSort","getMaxDigitCount","handleNegativeNumbersLSD","lsdRadixSort","maxDigitCount","maxDigits","exp","digitPlace","position","exponent","countingSortByDigit","bucketSortByDigit","start","end","digitPosition","insertionSort","pow","countingSortByDigitRange","bucketSortByDigitRange","digitCounts","Array","fill","digit","floor","startIndex","count","endIndex","output","index","value","counts","join","write","range","buckets","from","push","map","b","bucket","bucketSize","j","key","read","compare","positives","negatives","positiveCount","negativeCount","reverse","combined","log","getComplexity","time","best","average","worst","space","isStable","isInPlace","getInfo","info","optimization","properties","comparisonBased","online","divideAndConquer","suitable","smallArrays","integerData","fixedLengthKeys","limitedRange","stringData","variants","advantages","disadvantages"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/distribution/radix.js"],"sourcesContent":["// src/algorithms/distribution/radix.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Radix Sort with both LSD and MSD variants.\n * \n * Radix Sort is a non-comparison integer sorting algorithm that processes\n * individual digits, sorting numbers by their positional notation. It has\n * two primary variants:\n * \n * 1. LSD (Least Significant Digit): Processes digits from right to left\n *    - Stable sort\n *    - Simpler implementation\n *    - Requires a single pass through the data for each digit position\n * \n * 2. MSD (Most Significant Digit): Processes digits from left to right\n *    - Not inherently stable without extra work\n *    - More complex recursive implementation\n *    - Can early-terminate for partially ordered data\n * \n * Time Complexity: O(w * n) where w is the number of digits and n is the array size\n * Space Complexity: O(n + k) where k is the range of digit values (typically 10 for decimal)\n * \n * @class RadixSort\n * @extends Algorithm\n */\nclass RadixSort extends Algorithm {\n  /**\n   * Create a new RadixSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {string} [options.variant='lsd'] - Variant to use: 'lsd' or 'msd'\n   * @param {number} [options.radix=10] - The base of the number system (default: decimal)\n   * @param {boolean} [options.useCountingSort=true] - Use counting sort for digit sorting\n   * @param {boolean} [options.inPlace=false] - Attempt to use less auxiliary memory (MSD only)\n   * @param {boolean} [options.stable=true] - Ensure stability (matters for MSD)\n   */\n  constructor(options = {}) {\n    super('Radix Sort', 'distribution', options);\n    \n    // Default options\n    this.options = {\n      variant: 'lsd',           // 'lsd' (Least Significant Digit) or 'msd' (Most Significant Digit)\n      radix: 10,                // Base of the number system (default: decimal)\n      useCountingSort: true,    // Use counting sort for digit sorting\n      inPlace: false,           // Attempt to use less auxiliary memory (MSD only)\n      stable: true,             // Ensure stability (matters for MSD)\n      ...options\n    };\n  }\n  \n  /**\n   * Execute Radix Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('analysis');\n    \n    // Find the maximum number to determine number of digits\n    let max = Math.abs(result[0]);\n    for (let i = 1; i < n; i++) {\n      max = Math.max(max, Math.abs(result[i]));\n    }\n    \n    // Handle arrays with negative numbers\n    const hasNegative = result.some(num => num < 0);\n    \n    // Record initial state\n    this.recordState(result, {\n      type: 'initialization',\n      max: max,\n      hasNegative: hasNegative,\n      message: `Analyzing input: max value = ${max}, contains negative numbers: ${hasNegative}`\n    });\n    \n    // Choose sorting implementation based on variant\n    if (options.variant === 'msd') {\n      if (hasNegative) {\n        // Handle negative numbers for MSD variant\n        this.handleNegativeNumbersMSD(result, max, options);\n      } else {\n        // Sort positive numbers with MSD Radix Sort\n        this.msdRadixSort(result, 0, n - 1, this.getMaxDigitCount(max, options.radix), options);\n      }\n    } else {\n      // Default to LSD variant\n      if (hasNegative) {\n        // Handle negative numbers for LSD variant\n        this.handleNegativeNumbersLSD(result, max, options);\n      } else {\n        // Sort positive numbers with LSD Radix Sort\n        this.lsdRadixSort(result, max, options);\n      }\n    }\n    \n    this.setPhase('completed');\n    return result;\n  }\n  \n  /**\n   * LSD (Least Significant Digit) Radix Sort implementation\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} max - Maximum value in the array\n   * @param {Object} options - Runtime options\n   */\n  lsdRadixSort(array, max, options) {\n    this.setPhase('lsd-sorting');\n    \n    const n = array.length;\n    const radix = options.radix;\n    \n    // Get the number of digits in the maximum number\n    const maxDigitCount = this.getMaxDigitCount(max, radix);\n    \n    this.recordState(array, {\n      type: 'radix-info',\n      radix: radix,\n      maxDigits: maxDigitCount,\n      message: `Starting LSD Radix Sort with base ${radix}, maximum of ${maxDigitCount} digits`\n    });\n    \n    // Process each digit position, starting from the least significant (rightmost)\n    let exp = 1; // Start with the 1's place\n    for (let digitPlace = 0; digitPlace < maxDigitCount; digitPlace++) {\n      // Record current digit position\n      this.recordState(array, {\n        type: 'digit-position',\n        position: digitPlace,\n        exponent: exp,\n        message: `Sorting by digit position ${digitPlace} (${exp}'s place)`\n      });\n      \n      // Sort array elements according to the current digit\n      if (options.useCountingSort) {\n        this.countingSortByDigit(array, exp, radix, options);\n      } else {\n        this.bucketSortByDigit(array, exp, radix, options);\n      }\n      \n      // Move to next digit position\n      exp *= radix;\n      \n      // Record the array state after sorting this digit position\n      this.recordState(array, {\n        type: 'lsd-pass-complete',\n        position: digitPlace,\n        message: `Completed sorting pass for digit position ${digitPlace}`\n      });\n    }\n  }\n  \n  /**\n   * MSD (Most Significant Digit) Radix Sort implementation\n   * Recursive implementation that sorts from most significant to least significant digit\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} start - Start index for current recursion\n   * @param {number} end - End index for current recursion\n   * @param {number} digitPosition - Current digit position (max to 0)\n   * @param {Object} options - Runtime options\n   */\n  msdRadixSort(array, start, end, digitPosition, options) {\n    this.setPhase('msd-sorting');\n    \n    // Base cases\n    if (start >= end || digitPosition < 0) {\n      return;\n    }\n    \n    // Small subarray optimization\n    if (end - start < 10) {\n      this.insertionSort(array, start, end);\n      return;\n    }\n    \n    const radix = options.radix;\n    const exp = Math.pow(radix, digitPosition);\n    \n    // Record the current recursion state\n    this.recordState(array, {\n      type: 'msd-recursion',\n      start: start,\n      end: end,\n      digitPosition: digitPosition,\n      exponent: exp,\n      message: `MSD sorting from index ${start} to ${end} at digit position ${digitPosition}`\n    });\n    \n    // Use counting sort to order by the current digit\n    if (options.useCountingSort) {\n      this.countingSortByDigitRange(array, exp, radix, start, end, options);\n    } else {\n      // Alternative: bucket sort for this digit\n      this.bucketSortByDigitRange(array, exp, radix, start, end, options);\n    }\n    \n    // Now recursively sort each bucket (group of elements with the same digit)\n    const digitCounts = new Array(radix).fill(0);\n    \n    // Count the frequency of each digit value at the current position\n    for (let i = start; i <= end; i++) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      digitCounts[digit]++;\n    }\n    \n    // Calculate starting position of each digit group\n    let startIndex = start;\n    for (let digit = 0; digit < radix; digit++) {\n      const count = digitCounts[digit];\n      if (count > 0) {\n        const endIndex = startIndex + count - 1;\n        \n        // Record the bucket boundaries\n        this.recordState(array, {\n          type: 'msd-bucket',\n          digit: digit,\n          start: startIndex,\n          end: endIndex,\n          message: `Processing bucket for digit value ${digit} (indices ${startIndex} to ${endIndex})`\n        });\n        \n        // Recursively sort this bucket by the next digit position\n        this.msdRadixSort(array, startIndex, endIndex, digitPosition - 1, options);\n        \n        startIndex = endIndex + 1;\n      }\n    }\n  }\n  \n  /**\n   * Sort array elements by a specific digit using counting sort\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} exp - Exponent for the current digit position (1, 10, 100, etc.)\n   * @param {number} radix - Base of the number system\n   * @param {Object} options - Runtime options\n   */\n  countingSortByDigit(array, exp, radix, options) {\n    const n = array.length;\n    const output = new Array(n).fill(0);\n    const count = new Array(radix).fill(0);\n    \n    // Store count of occurrences of each digit\n    for (let i = 0; i < n; i++) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      count[digit]++;\n      \n      // Record the digit extraction\n      if (i % Math.max(1, Math.floor(n / 10)) === 0) { // Record only some steps for large arrays\n        this.recordState(array, {\n          type: 'digit-extraction',\n          index: i,\n          value: array[i],\n          digit: digit,\n          position: exp,\n          message: `Extracted digit ${digit} at position ${exp} from value ${array[i]}`\n        });\n      }\n    }\n    \n    // Record the digit counts\n    this.recordState(array, {\n      type: 'digit-counts',\n      counts: [...count],\n      message: `Digit frequency counts at position ${exp}: [${count.join(', ')}]`\n    });\n    \n    // Change count[i] so that count[i] contains the position of this digit in output[]\n    for (let i = 1; i < radix; i++) {\n      count[i] += count[i - 1];\n    }\n    \n    // Record the cumulative counts\n    this.recordState(array, {\n      type: 'cumulative-counts',\n      counts: [...count],\n      message: `Cumulative counts for stable positioning: [${count.join(', ')}]`\n    });\n    \n    // Build the output array\n    // Process elements in reverse to maintain stability\n    for (let i = n - 1; i >= 0; i--) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      const position = count[digit] - 1;\n      output[position] = array[i];\n      count[digit]--;\n      \n      // Record significant placement operations\n      if (i % Math.max(1, Math.floor(n / 10)) === 0) { // Record only some steps for large arrays\n        this.recordState([...array], {\n          type: 'element-placement',\n          index: i,\n          value: array[i],\n          digit: digit,\n          position: position,\n          message: `Placing element ${array[i]} with digit ${digit} at output position ${position}`\n        });\n      }\n    }\n    \n    // Copy the output array to the original array\n    for (let i = 0; i < n; i++) {\n      this.write(array, i, output[i]);\n    }\n    \n    // Record the completed pass\n    this.recordState(array, {\n      type: 'counting-sort-complete',\n      exponent: exp,\n      message: `Completed counting sort pass for digit position ${exp}`\n    });\n  }\n  \n  /**\n   * Sort a range of array elements by a specific digit using counting sort\n   * Used for MSD Radix Sort on subarrays\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} exp - Exponent for the current digit position\n   * @param {number} radix - Base of the number system\n   * @param {number} start - Start index of the range\n   * @param {number} end - End index of the range\n   * @param {Object} options - Runtime options\n   */\n  countingSortByDigitRange(array, exp, radix, start, end, options) {\n    const range = end - start + 1;\n    const output = new Array(range);\n    const count = new Array(radix).fill(0);\n    \n    // Store count of occurrences of each digit in the range\n    for (let i = start; i <= end; i++) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      count[digit]++;\n    }\n    \n    // Record the digit counts\n    this.recordState(array, {\n      type: 'digit-counts',\n      counts: [...count],\n      start: start,\n      end: end,\n      message: `Digit frequency counts at position ${exp} for range [${start}..${end}]: [${count.join(', ')}]`\n    });\n    \n    // Change count[i] so that count[i] contains the position of this digit in output[]\n    for (let i = 1; i < radix; i++) {\n      count[i] += count[i - 1];\n    }\n    \n    // Build the output array\n    // Process elements in reverse to maintain stability\n    for (let i = end; i >= start; i--) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      const position = count[digit] - 1;\n      output[position] = array[i];\n      count[digit]--;\n      \n      // Record significant placement operations\n      if ((i - start) % Math.max(1, Math.floor(range / 10)) === 0) {\n        this.recordState([...array], {\n          type: 'element-placement',\n          index: i,\n          value: array[i],\n          digit: digit,\n          message: `Placing element ${array[i]} with digit ${digit} in output`\n        });\n      }\n    }\n    \n    // Copy back to original array\n    for (let i = 0; i < range; i++) {\n      this.write(array, start + i, output[i]);\n    }\n    \n    // Record the completed pass\n    this.recordState(array, {\n      type: 'counting-sort-complete',\n      exponent: exp,\n      start: start,\n      end: end,\n      message: `Completed counting sort pass for digit position ${exp} in range [${start}..${end}]`\n    });\n  }\n  \n  /**\n   * Sort array elements by a specific digit using bucket sort approach\n   * Alternative to counting sort for digit sorting\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} exp - Exponent for the current digit position\n   * @param {number} radix - Base of the number system\n   * @param {Object} options - Runtime options\n   */\n  bucketSortByDigit(array, exp, radix, options) {\n    const n = array.length;\n    const buckets = Array.from({ length: radix }, () => []);\n    \n    // Distribute elements into buckets based on the current digit\n    for (let i = 0; i < n; i++) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      buckets[digit].push(array[i]);\n      \n      // Record bucket distribution\n      if (i % Math.max(1, Math.floor(n / 10)) === 0) {\n        this.recordState([...array], {\n          type: 'bucket-distribution',\n          index: i,\n          value: array[i],\n          digit: digit,\n          message: `Placing ${array[i]} into bucket ${digit} (${exp}'s place digit)`\n        });\n      }\n    }\n    \n    // Record bucket state\n    this.recordState(array, {\n      type: 'buckets-filled',\n      buckets: buckets.map(b => [...b]),\n      message: `Elements distributed into ${radix} buckets by digit at position ${exp}`\n    });\n    \n    // Concatenate all buckets back into the original array\n    let index = 0;\n    for (let digit = 0; digit < radix; digit++) {\n      const bucket = buckets[digit];\n      \n      // Record that we're processing this bucket\n      if (bucket.length > 0) {\n        this.recordState([...array], {\n          type: 'bucket-processing',\n          digit: digit,\n          bucketSize: bucket.length,\n          message: `Transferring ${bucket.length} elements from bucket ${digit} back to array`\n        });\n      }\n      \n      for (let j = 0; j < bucket.length; j++) {\n        this.write(array, index++, bucket[j]);\n      }\n    }\n    \n    // Record the completed pass\n    this.recordState(array, {\n      type: 'bucket-sort-complete',\n      exponent: exp,\n      message: `Completed bucket sort pass for digit position ${exp}`\n    });\n  }\n  \n  /**\n   * Sort a range of array elements by a specific digit using bucket sort\n   * Used for MSD Radix Sort on subarrays\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} exp - Exponent for the current digit position\n   * @param {number} radix - Base of the number system\n   * @param {number} start - Start index of the range\n   * @param {number} end - End index of the range\n   * @param {Object} options - Runtime options\n   */\n  bucketSortByDigitRange(array, exp, radix, start, end, options) {\n    const range = end - start + 1;\n    const buckets = Array.from({ length: radix }, () => []);\n    \n    // Distribute elements into buckets\n    for (let i = start; i <= end; i++) {\n      const digit = Math.floor(Math.abs(array[i]) / exp) % radix;\n      buckets[digit].push(array[i]);\n    }\n    \n    // Record bucket state\n    this.recordState(array, {\n      type: 'buckets-filled',\n      buckets: buckets.map(b => [...b]),\n      start: start,\n      end: end,\n      message: `Elements from range [${start}..${end}] distributed into buckets by digit at position ${exp}`\n    });\n    \n    // Concatenate buckets back into the original array\n    let index = start;\n    for (let digit = 0; digit < radix; digit++) {\n      const bucket = buckets[digit];\n      \n      for (let j = 0; j < bucket.length; j++) {\n        this.write(array, index++, bucket[j]);\n      }\n    }\n    \n    // Record the completed pass\n    this.recordState(array, {\n      type: 'bucket-sort-complete',\n      exponent: exp,\n      start: start,\n      end: end,\n      message: `Completed bucket sort pass for digit position ${exp} in range [${start}..${end}]`\n    });\n  }\n  \n  /**\n   * Simple insertion sort for small subarrays\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {number} start - Start index\n   * @param {number} end - End index\n   */\n  insertionSort(array, start, end) {\n    for (let i = start + 1; i <= end; i++) {\n      const key = this.read(array, i);\n      let j = i - 1;\n      \n      while (j >= start && this.compare(this.read(array, j), key) > 0) {\n        this.write(array, j + 1, this.read(array, j));\n        j--;\n      }\n      \n      this.write(array, j + 1, key);\n    }\n    \n    this.recordState(array, {\n      type: 'insertion-sort',\n      start: start,\n      end: end,\n      message: `Applied insertion sort on small range [${start}..${end}]`\n    });\n  }\n  \n  /**\n   * Handle arrays with negative numbers for LSD variant\n   * \n   * @param {Array} array - Array containing negative numbers\n   * @param {number} max - Maximum absolute value in the array\n   * @param {Object} options - Runtime options\n   */\n  handleNegativeNumbersLSD(array, max, options) {\n    this.setPhase('handling-negatives');\n    \n    const n = array.length;\n    const positives = [];\n    const negatives = [];\n    \n    // Separate positive and negative numbers\n    for (let i = 0; i < n; i++) {\n      const value = this.read(array, i);\n      if (value < 0) {\n        negatives.push(-value); // Store absolute value for sorting\n      } else {\n        positives.push(value);\n      }\n    }\n    \n    this.recordState(array, {\n      type: 'negative-handling',\n      positiveCount: positives.length,\n      negativeCount: negatives.length,\n      message: `Separated into ${positives.length} positive and ${negatives.length} negative numbers`\n    });\n    \n    // Sort positive and negative parts separately\n    if (positives.length > 0) {\n      this.lsdRadixSort(positives, max, options);\n    }\n    \n    if (negatives.length > 0) {\n      this.lsdRadixSort(negatives, max, options);\n      // Reverse and negate the sorted negative numbers\n      negatives.reverse();\n      for (let i = 0; i < negatives.length; i++) {\n        negatives[i] = -negatives[i];\n      }\n    }\n    \n    // Combine the results: negatives followed by positives\n    const combined = [...negatives, ...positives];\n    \n    // Copy back to the original array\n    for (let i = 0; i < n; i++) {\n      this.write(array, i, combined[i]);\n    }\n    \n    this.recordState(array, {\n      type: 'negatives-combined',\n      message: `Combined sorted negative and positive partitions`\n    });\n  }\n  \n  /**\n   * Handle arrays with negative numbers for MSD variant\n   * \n   * @param {Array} array - Array containing negative numbers\n   * @param {number} max - Maximum absolute value in the array\n   * @param {Object} options - Runtime options\n   */\n  handleNegativeNumbersMSD(array, max, options) {\n    this.setPhase('handling-negatives');\n    \n    const n = array.length;\n    const positives = [];\n    const negatives = [];\n    \n    // Separate positive and negative numbers\n    for (let i = 0; i < n; i++) {\n      const value = this.read(array, i);\n      if (value < 0) {\n        negatives.push(-value); // Store absolute value for sorting\n      } else {\n        positives.push(value);\n      }\n    }\n    \n    this.recordState(array, {\n      type: 'negative-handling',\n      positiveCount: positives.length,\n      negativeCount: negatives.length,\n      message: `Separated into ${positives.length} positive and ${negatives.length} negative numbers`\n    });\n    \n    // Sort positive and negative parts separately with MSD\n    const maxDigits = this.getMaxDigitCount(max, options.radix);\n    \n    if (positives.length > 0) {\n      this.msdRadixSort(positives, 0, positives.length - 1, maxDigits - 1, options);\n    }\n    \n    if (negatives.length > 0) {\n      this.msdRadixSort(negatives, 0, negatives.length - 1, maxDigits - 1, options);\n      // Reverse and negate the sorted negative numbers\n      negatives.reverse();\n      for (let i = 0; i < negatives.length; i++) {\n        negatives[i] = -negatives[i];\n      }\n    }\n    \n    // Combine the results: negatives followed by positives\n    const combined = [...negatives, ...positives];\n    \n    // Copy back to the original array\n    for (let i = 0; i < n; i++) {\n      this.write(array, i, combined[i]);\n    }\n    \n    this.recordState(array, {\n      type: 'negatives-combined',\n      message: `Combined sorted negative and positive partitions`\n    });\n  }\n  \n  /**\n   * Calculate the number of digits in a number given a radix\n   * \n   * @param {number} num - Number to analyze\n   * @param {number} radix - Base of the number system\n   * @returns {number} - Number of digits\n   */\n  getMaxDigitCount(num, radix) {\n    if (num === 0) return 1;\n    return Math.floor(Math.log(num) / Math.log(radix)) + 1;\n  }\n  \n  /**\n   * Get the time and space complexity of Radix Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    const variant = this.options.variant;\n    \n    return {\n      time: {\n        best: 'O(w * n)',\n        average: 'O(w * n)',\n        worst: 'O(w * n)'\n      },\n      space: {\n        best: variant === 'msd' && this.options.inPlace ? 'O(log n)' : 'O(n + k)',\n        average: 'O(n + k)',\n        worst: 'O(n + k)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Radix Sort is stable\n   * \n   * @returns {boolean} - True if LSD variant or if MSD with stability option\n   */\n  isStable() {\n    return this.options.variant === 'lsd' || \n           (this.options.variant === 'msd' && this.options.stable);\n  }\n  \n  /**\n   * Whether Radix Sort is in-place\n   * \n   * @returns {boolean} - False as Radix Sort requires auxiliary space\n   */\n  isInPlace() {\n    return false; // Standard implementation requires O(n) auxiliary space\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add radix sort specific information\n    info.optimization = {\n      variant: this.options.variant,\n      radix: this.options.radix,\n      useCountingSort: this.options.useCountingSort,\n      inPlace: this.options.inPlace,\n      stable: this.options.stable\n    };\n    \n    info.properties = {\n      comparisonBased: false,\n      stable: this.isStable(),\n      inPlace: this.isInPlace(),\n      online: false,\n      divideAndConquer: this.options.variant === 'msd'\n    };\n    \n    info.suitable = {\n      smallArrays: false,\n      integerData: true,\n      fixedLengthKeys: true,\n      limitedRange: true,\n      stringData: true\n    };\n    \n    info.variants = [\n      'Least Significant Digit (LSD) Radix Sort',\n      'Most Significant Digit (MSD) Radix Sort',\n      'American Flag Sort (more efficient MSD variant)',\n      'Flashsort (MSD variant)',\n      'In-place MSD Radix Sort'\n    ];\n    \n    info.advantages = [\n      'Linear time complexity O(w * n) independent of input distribution',\n      'Can be faster than O(n log n) comparison sorts for fixed-length keys',\n      'Stable (for LSD variant)',\n      'Suitable for parallel implementation',\n      'Good for string/integer sorting with fixed-length keys'\n    ];\n    \n    info.disadvantages = [\n      'Limited to integers and strings (lexicographical ordering)',\n      'Space intensive due to auxiliary memory requirements',\n      'Performance highly dependent on key length and distribution',\n      'Often slower than quicksort for general purpose sorting',\n      'Complex implementation for variable-length keys'\n    ];\n    \n    return info;\n  }\n}\n\nexport default RadixSort;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}