{"ast":null,"code":"var _jsxFileName = \"/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/visualization/components/heap-visualizer.js\";\n// src/visualization/components/heap-visualizer.js\n\nimport React, { useRef, useEffect } from 'react';\n\n/**\n * HeapVisualizer Component\n * \n * A specialized visualization component that renders a binary heap structure as a tree,\n * allowing for intuitive understanding of the implicit tree structure used in heap sort.\n * \n * The component uses canvas-based rendering for maximum performance and supports:\n * - Visual representation of the binary tree structure\n * - Node highlighting for active operations\n * - Distinction between internal nodes and leaf nodes\n * - Proper mathematical positioning of nodes based on level\n * \n * @param {Object} heapStructure - Binary heap representation data\n * @param {number} width - Canvas width\n * @param {number} height - Canvas height\n * @param {number} nodeRadius - Radius of tree nodes in pixels\n * @param {string} highlightColor - Color for highlighted nodes\n * @param {string} nodeColor - Color for regular internal nodes\n * @param {string} leafColor - Color for leaf nodes\n * @param {string} textColor - Color for node text\n */\nconst HeapVisualizer = ({\n  heapStructure,\n  width = 600,\n  height = 400,\n  nodeRadius = 25,\n  highlightColor = '#FF5722',\n  nodeColor = '#3F51B5',\n  leafColor = '#4CAF50',\n  textColor = '#FFFFFF'\n}) => {\n  const canvasRef = useRef(null);\n\n  /**\n   * Canvas rendering effect that executes whenever the heap structure\n   * or rendering parameters change\n   */\n  useEffect(() => {\n    if (!heapStructure || !canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Clear canvas with high-performance method\n    ctx.clearRect(0, 0, width, height);\n\n    // Calculate max depth of the heap for level positioning\n    const maxLevel = Math.max(...heapStructure.nodes.map(node => node.level), 0);\n\n    // Calculate layout parameters with mathematical precision\n    const levelHeight = height / (maxLevel + 2); // Vertical distance between levels\n    const xPadding = 20; // Horizontal padding\n    const availableWidth = width - 2 * xPadding; // Available width for nodes\n\n    // Draw edges first (so they're behind nodes)\n    renderEdges(ctx, heapStructure, maxLevel, levelHeight, xPadding, availableWidth);\n\n    // Draw nodes with proper level-based positioning\n    renderNodes(ctx, heapStructure, maxLevel, levelHeight, xPadding, availableWidth);\n\n    // Draw informational elements\n    renderInformation(ctx, heapStructure);\n  }, [heapStructure, width, height, nodeRadius, highlightColor, nodeColor, leafColor, textColor]);\n\n  /**\n   * Renders the edges connecting nodes in the binary heap\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {Object} heapStructure - Heap structure data\n   * @param {number} maxLevel - Maximum tree depth\n   * @param {number} levelHeight - Vertical distance between levels\n   * @param {number} xPadding - Horizontal padding\n   * @param {number} availableWidth - Available width for rendering\n   */\n  const renderEdges = (ctx, heapStructure, maxLevel, levelHeight, xPadding, availableWidth) => {\n    ctx.strokeStyle = '#888888';\n    ctx.lineWidth = 2;\n    heapStructure.edges.forEach(edge => {\n      const fromNode = heapStructure.nodes.find(n => n.id === edge.from);\n      const toNode = heapStructure.nodes.find(n => n.id === edge.to);\n      if (!fromNode || !toNode) return;\n\n      // Calculate node positions using mathematical formula for complete binary tree\n      // This ensures proper node distribution at each level\n      const fromX = xPadding + (fromNode.id + 1) * availableWidth / Math.pow(2, fromNode.level + 1);\n      const fromY = (fromNode.level + 1) * levelHeight;\n      const toX = xPadding + (toNode.id + 1) * availableWidth / Math.pow(2, toNode.level + 1);\n      const toY = (toNode.level + 1) * levelHeight;\n\n      // Draw edge with anti-aliasing\n      ctx.beginPath();\n      ctx.moveTo(fromX, fromY);\n      ctx.lineTo(toX, toY);\n      ctx.stroke();\n\n      // Draw small label for edge type (left/right)\n      const midX = (fromX + toX) / 2;\n      const midY = (fromY + toY) / 2;\n      ctx.fillStyle = '#888888';\n      ctx.font = '10px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(edge.type, midX, midY - 8);\n    });\n  };\n\n  /**\n   * Renders the nodes of the binary heap\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {Object} heapStructure - Heap structure data\n   * @param {number} maxLevel - Maximum tree depth\n   * @param {number} levelHeight - Vertical distance between levels\n   * @param {number} xPadding - Horizontal padding\n   * @param {number} availableWidth - Available width for rendering\n   */\n  const renderNodes = (ctx, heapStructure, maxLevel, levelHeight, xPadding, availableWidth) => {\n    heapStructure.nodes.forEach(node => {\n      // Calculate node position based on complete binary tree structure\n      const x = xPadding + (node.id + 1) * availableWidth / Math.pow(2, node.level + 1);\n      const y = (node.level + 1) * levelHeight;\n\n      // Determine node color based on node state and type\n      let fillColor = node.isLeaf ? leafColor : nodeColor;\n\n      // Highlight the focused node if specified\n      if (heapStructure.highlight !== undefined && node.id === heapStructure.highlight) {\n        fillColor = highlightColor;\n      }\n\n      // Draw node circle with anti-aliasing\n      ctx.beginPath();\n      ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n\n      // Draw node outline for definition\n      ctx.strokeStyle = '#000000';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      // Draw node value with appropriate font scaling\n      ctx.fillStyle = textColor;\n\n      // Scale font size based on content length\n      const valueText = node.value.toString();\n      const fontSize = valueText.length > 2 ? 14 : 16;\n      ctx.font = `bold ${fontSize}px Arial`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(valueText, x, y);\n\n      // Draw node index below (important for educational context)\n      ctx.fillStyle = '#000000';\n      ctx.font = '12px Arial';\n      ctx.fillText(`idx: ${node.id}`, x, y + nodeRadius + 15);\n    });\n  };\n\n  /**\n   * Renders informational elements like heap property explanation and legend\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   */\n  const renderInformation = ctx => {\n    ctx.fillStyle = '#333333';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    ctx.fillText('Binary Max Heap: parent â‰¥ children', 10, 10);\n\n    // Draw legend at bottom\n    const legendY = height - 40;\n\n    // Regular node\n    ctx.beginPath();\n    ctx.arc(30, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = nodeColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.textAlign = 'left';\n    ctx.fillText('Internal Node', 50, legendY - 5);\n\n    // Leaf node\n    ctx.beginPath();\n    ctx.arc(150, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = leafColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Leaf Node', 170, legendY - 5);\n\n    // Highlighted node\n    ctx.beginPath();\n    ctx.arc(270, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = highlightColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Current Node', 290, legendY - 5);\n  };\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"heap-visualizer\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 215,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: canvasRef,\n    width: width,\n    height: height,\n    className: \"heap-canvas\",\n    style: {\n      border: '1px solid #ddd',\n      borderRadius: '4px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 216,\n      columnNumber: 7\n    }\n  }), !heapStructure && /*#__PURE__*/React.createElement(\"div\", {\n    className: \"heap-placeholder\",\n    style: {\n      position: 'absolute',\n      top: '50%',\n      left: '50%',\n      transform: 'translate(-50%, -50%)',\n      color: '#888',\n      fontSize: '16px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 224,\n      columnNumber: 9\n    }\n  }, \"Waiting for heap structure data...\"));\n};\nexport default HeapVisualizer;","map":{"version":3,"names":["React","useRef","useEffect","HeapVisualizer","heapStructure","width","height","nodeRadius","highlightColor","nodeColor","leafColor","textColor","canvasRef","current","canvas","ctx","getContext","clearRect","maxLevel","Math","max","nodes","map","node","level","levelHeight","xPadding","availableWidth","renderEdges","renderNodes","renderInformation","strokeStyle","lineWidth","edges","forEach","edge","fromNode","find","n","id","from","toNode","to","fromX","pow","fromY","toX","toY","beginPath","moveTo","lineTo","stroke","midX","midY","fillStyle","font","textAlign","textBaseline","fillText","type","x","y","fillColor","isLeaf","highlight","undefined","arc","PI","fill","valueText","value","toString","fontSize","length","legendY","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","ref","style","border","borderRadius","position","top","left","transform","color"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/visualization/components/heap-visualizer.js"],"sourcesContent":["// src/visualization/components/heap-visualizer.js\n\nimport React, { useRef, useEffect } from 'react';\n\n/**\n * HeapVisualizer Component\n * \n * A specialized visualization component that renders a binary heap structure as a tree,\n * allowing for intuitive understanding of the implicit tree structure used in heap sort.\n * \n * The component uses canvas-based rendering for maximum performance and supports:\n * - Visual representation of the binary tree structure\n * - Node highlighting for active operations\n * - Distinction between internal nodes and leaf nodes\n * - Proper mathematical positioning of nodes based on level\n * \n * @param {Object} heapStructure - Binary heap representation data\n * @param {number} width - Canvas width\n * @param {number} height - Canvas height\n * @param {number} nodeRadius - Radius of tree nodes in pixels\n * @param {string} highlightColor - Color for highlighted nodes\n * @param {string} nodeColor - Color for regular internal nodes\n * @param {string} leafColor - Color for leaf nodes\n * @param {string} textColor - Color for node text\n */\nconst HeapVisualizer = ({ \n  heapStructure, \n  width = 600, \n  height = 400, \n  nodeRadius = 25,\n  highlightColor = '#FF5722',\n  nodeColor = '#3F51B5',\n  leafColor = '#4CAF50',\n  textColor = '#FFFFFF'\n}) => {\n  const canvasRef = useRef(null);\n  \n  /**\n   * Canvas rendering effect that executes whenever the heap structure\n   * or rendering parameters change\n   */\n  useEffect(() => {\n    if (!heapStructure || !canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    // Clear canvas with high-performance method\n    ctx.clearRect(0, 0, width, height);\n    \n    // Calculate max depth of the heap for level positioning\n    const maxLevel = Math.max(...heapStructure.nodes.map(node => node.level), 0);\n    \n    // Calculate layout parameters with mathematical precision\n    const levelHeight = height / (maxLevel + 2);  // Vertical distance between levels\n    const xPadding = 20;                         // Horizontal padding\n    const availableWidth = width - 2 * xPadding; // Available width for nodes\n    \n    // Draw edges first (so they're behind nodes)\n    renderEdges(ctx, heapStructure, maxLevel, levelHeight, xPadding, availableWidth);\n    \n    // Draw nodes with proper level-based positioning\n    renderNodes(ctx, heapStructure, maxLevel, levelHeight, xPadding, availableWidth);\n    \n    // Draw informational elements\n    renderInformation(ctx, heapStructure);\n    \n  }, [heapStructure, width, height, nodeRadius, highlightColor, nodeColor, leafColor, textColor]);\n  \n  /**\n   * Renders the edges connecting nodes in the binary heap\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {Object} heapStructure - Heap structure data\n   * @param {number} maxLevel - Maximum tree depth\n   * @param {number} levelHeight - Vertical distance between levels\n   * @param {number} xPadding - Horizontal padding\n   * @param {number} availableWidth - Available width for rendering\n   */\n  const renderEdges = (ctx, heapStructure, maxLevel, levelHeight, xPadding, availableWidth) => {\n    ctx.strokeStyle = '#888888';\n    ctx.lineWidth = 2;\n    \n    heapStructure.edges.forEach(edge => {\n      const fromNode = heapStructure.nodes.find(n => n.id === edge.from);\n      const toNode = heapStructure.nodes.find(n => n.id === edge.to);\n      \n      if (!fromNode || !toNode) return;\n      \n      // Calculate node positions using mathematical formula for complete binary tree\n      // This ensures proper node distribution at each level\n      const fromX = xPadding + (fromNode.id + 1) * availableWidth / Math.pow(2, fromNode.level + 1);\n      const fromY = (fromNode.level + 1) * levelHeight;\n      \n      const toX = xPadding + (toNode.id + 1) * availableWidth / Math.pow(2, toNode.level + 1);\n      const toY = (toNode.level + 1) * levelHeight;\n      \n      // Draw edge with anti-aliasing\n      ctx.beginPath();\n      ctx.moveTo(fromX, fromY);\n      ctx.lineTo(toX, toY);\n      ctx.stroke();\n      \n      // Draw small label for edge type (left/right)\n      const midX = (fromX + toX) / 2;\n      const midY = (fromY + toY) / 2;\n      \n      ctx.fillStyle = '#888888';\n      ctx.font = '10px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(edge.type, midX, midY - 8);\n    });\n  };\n  \n  /**\n   * Renders the nodes of the binary heap\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {Object} heapStructure - Heap structure data\n   * @param {number} maxLevel - Maximum tree depth\n   * @param {number} levelHeight - Vertical distance between levels\n   * @param {number} xPadding - Horizontal padding\n   * @param {number} availableWidth - Available width for rendering\n   */\n  const renderNodes = (ctx, heapStructure, maxLevel, levelHeight, xPadding, availableWidth) => {\n    heapStructure.nodes.forEach(node => {\n      // Calculate node position based on complete binary tree structure\n      const x = xPadding + (node.id + 1) * availableWidth / Math.pow(2, node.level + 1);\n      const y = (node.level + 1) * levelHeight;\n      \n      // Determine node color based on node state and type\n      let fillColor = node.isLeaf ? leafColor : nodeColor;\n      \n      // Highlight the focused node if specified\n      if (heapStructure.highlight !== undefined && node.id === heapStructure.highlight) {\n        fillColor = highlightColor;\n      }\n      \n      // Draw node circle with anti-aliasing\n      ctx.beginPath();\n      ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n      \n      // Draw node outline for definition\n      ctx.strokeStyle = '#000000';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      \n      // Draw node value with appropriate font scaling\n      ctx.fillStyle = textColor;\n      \n      // Scale font size based on content length\n      const valueText = node.value.toString();\n      const fontSize = valueText.length > 2 ? 14 : 16;\n      \n      ctx.font = `bold ${fontSize}px Arial`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(valueText, x, y);\n      \n      // Draw node index below (important for educational context)\n      ctx.fillStyle = '#000000';\n      ctx.font = '12px Arial';\n      ctx.fillText(`idx: ${node.id}`, x, y + nodeRadius + 15);\n    });\n  };\n  \n  /**\n   * Renders informational elements like heap property explanation and legend\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   */\n  const renderInformation = (ctx) => {\n    ctx.fillStyle = '#333333';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    ctx.fillText('Binary Max Heap: parent â‰¥ children', 10, 10);\n    \n    // Draw legend at bottom\n    const legendY = height - 40;\n    \n    // Regular node\n    ctx.beginPath();\n    ctx.arc(30, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = nodeColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.textAlign = 'left';\n    ctx.fillText('Internal Node', 50, legendY - 5);\n    \n    // Leaf node\n    ctx.beginPath();\n    ctx.arc(150, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = leafColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Leaf Node', 170, legendY - 5);\n    \n    // Highlighted node\n    ctx.beginPath();\n    ctx.arc(270, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = highlightColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Current Node', 290, legendY - 5);\n  };\n  \n  return (\n    <div className=\"heap-visualizer\">\n      <canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        className=\"heap-canvas\"\n        style={{ border: '1px solid #ddd', borderRadius: '4px' }}\n      />\n      {!heapStructure && (\n        <div className=\"heap-placeholder\" style={{ \n          position: 'absolute', \n          top: '50%', \n          left: '50%', \n          transform: 'translate(-50%, -50%)',\n          color: '#888',\n          fontSize: '16px'\n        }}>\n          Waiting for heap structure data...\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default HeapVisualizer;"],"mappings":";AAAA;;AAEA,OAAOA,KAAK,IAAIC,MAAM,EAAEC,SAAS,QAAQ,OAAO;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,GAAGA,CAAC;EACtBC,aAAa;EACbC,KAAK,GAAG,GAAG;EACXC,MAAM,GAAG,GAAG;EACZC,UAAU,GAAG,EAAE;EACfC,cAAc,GAAG,SAAS;EAC1BC,SAAS,GAAG,SAAS;EACrBC,SAAS,GAAG,SAAS;EACrBC,SAAS,GAAG;AACd,CAAC,KAAK;EACJ,MAAMC,SAAS,GAAGX,MAAM,CAAC,IAAI,CAAC;;EAE9B;AACF;AACA;AACA;EACEC,SAAS,CAAC,MAAM;IACd,IAAI,CAACE,aAAa,IAAI,CAACQ,SAAS,CAACC,OAAO,EAAE;IAE1C,MAAMC,MAAM,GAAGF,SAAS,CAACC,OAAO;IAChC,MAAME,GAAG,GAAGD,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;;IAEnC;IACAD,GAAG,CAACE,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEZ,KAAK,EAAEC,MAAM,CAAC;;IAElC;IACA,MAAMY,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAGhB,aAAa,CAACiB,KAAK,CAACC,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACC,KAAK,CAAC,EAAE,CAAC,CAAC;;IAE5E;IACA,MAAMC,WAAW,GAAGnB,MAAM,IAAIY,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAE;IAC9C,MAAMQ,QAAQ,GAAG,EAAE,CAAC,CAAyB;IAC7C,MAAMC,cAAc,GAAGtB,KAAK,GAAG,CAAC,GAAGqB,QAAQ,CAAC,CAAC;;IAE7C;IACAE,WAAW,CAACb,GAAG,EAAEX,aAAa,EAAEc,QAAQ,EAAEO,WAAW,EAAEC,QAAQ,EAAEC,cAAc,CAAC;;IAEhF;IACAE,WAAW,CAACd,GAAG,EAAEX,aAAa,EAAEc,QAAQ,EAAEO,WAAW,EAAEC,QAAQ,EAAEC,cAAc,CAAC;;IAEhF;IACAG,iBAAiB,CAACf,GAAG,EAAEX,aAAa,CAAC;EAEvC,CAAC,EAAE,CAACA,aAAa,EAAEC,KAAK,EAAEC,MAAM,EAAEC,UAAU,EAAEC,cAAc,EAAEC,SAAS,EAAEC,SAAS,EAAEC,SAAS,CAAC,CAAC;;EAE/F;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMiB,WAAW,GAAGA,CAACb,GAAG,EAAEX,aAAa,EAAEc,QAAQ,EAAEO,WAAW,EAAEC,QAAQ,EAAEC,cAAc,KAAK;IAC3FZ,GAAG,CAACgB,WAAW,GAAG,SAAS;IAC3BhB,GAAG,CAACiB,SAAS,GAAG,CAAC;IAEjB5B,aAAa,CAAC6B,KAAK,CAACC,OAAO,CAACC,IAAI,IAAI;MAClC,MAAMC,QAAQ,GAAGhC,aAAa,CAACiB,KAAK,CAACgB,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKJ,IAAI,CAACK,IAAI,CAAC;MAClE,MAAMC,MAAM,GAAGrC,aAAa,CAACiB,KAAK,CAACgB,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKJ,IAAI,CAACO,EAAE,CAAC;MAE9D,IAAI,CAACN,QAAQ,IAAI,CAACK,MAAM,EAAE;;MAE1B;MACA;MACA,MAAME,KAAK,GAAGjB,QAAQ,GAAG,CAACU,QAAQ,CAACG,EAAE,GAAG,CAAC,IAAIZ,cAAc,GAAGR,IAAI,CAACyB,GAAG,CAAC,CAAC,EAAER,QAAQ,CAACZ,KAAK,GAAG,CAAC,CAAC;MAC7F,MAAMqB,KAAK,GAAG,CAACT,QAAQ,CAACZ,KAAK,GAAG,CAAC,IAAIC,WAAW;MAEhD,MAAMqB,GAAG,GAAGpB,QAAQ,GAAG,CAACe,MAAM,CAACF,EAAE,GAAG,CAAC,IAAIZ,cAAc,GAAGR,IAAI,CAACyB,GAAG,CAAC,CAAC,EAAEH,MAAM,CAACjB,KAAK,GAAG,CAAC,CAAC;MACvF,MAAMuB,GAAG,GAAG,CAACN,MAAM,CAACjB,KAAK,GAAG,CAAC,IAAIC,WAAW;;MAE5C;MACAV,GAAG,CAACiC,SAAS,CAAC,CAAC;MACfjC,GAAG,CAACkC,MAAM,CAACN,KAAK,EAAEE,KAAK,CAAC;MACxB9B,GAAG,CAACmC,MAAM,CAACJ,GAAG,EAAEC,GAAG,CAAC;MACpBhC,GAAG,CAACoC,MAAM,CAAC,CAAC;;MAEZ;MACA,MAAMC,IAAI,GAAG,CAACT,KAAK,GAAGG,GAAG,IAAI,CAAC;MAC9B,MAAMO,IAAI,GAAG,CAACR,KAAK,GAAGE,GAAG,IAAI,CAAC;MAE9BhC,GAAG,CAACuC,SAAS,GAAG,SAAS;MACzBvC,GAAG,CAACwC,IAAI,GAAG,YAAY;MACvBxC,GAAG,CAACyC,SAAS,GAAG,QAAQ;MACxBzC,GAAG,CAAC0C,YAAY,GAAG,QAAQ;MAC3B1C,GAAG,CAAC2C,QAAQ,CAACvB,IAAI,CAACwB,IAAI,EAAEP,IAAI,EAAEC,IAAI,GAAG,CAAC,CAAC;IACzC,CAAC,CAAC;EACJ,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMxB,WAAW,GAAGA,CAACd,GAAG,EAAEX,aAAa,EAAEc,QAAQ,EAAEO,WAAW,EAAEC,QAAQ,EAAEC,cAAc,KAAK;IAC3FvB,aAAa,CAACiB,KAAK,CAACa,OAAO,CAACX,IAAI,IAAI;MAClC;MACA,MAAMqC,CAAC,GAAGlC,QAAQ,GAAG,CAACH,IAAI,CAACgB,EAAE,GAAG,CAAC,IAAIZ,cAAc,GAAGR,IAAI,CAACyB,GAAG,CAAC,CAAC,EAAErB,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;MACjF,MAAMqC,CAAC,GAAG,CAACtC,IAAI,CAACC,KAAK,GAAG,CAAC,IAAIC,WAAW;;MAExC;MACA,IAAIqC,SAAS,GAAGvC,IAAI,CAACwC,MAAM,GAAGrD,SAAS,GAAGD,SAAS;;MAEnD;MACA,IAAIL,aAAa,CAAC4D,SAAS,KAAKC,SAAS,IAAI1C,IAAI,CAACgB,EAAE,KAAKnC,aAAa,CAAC4D,SAAS,EAAE;QAChFF,SAAS,GAAGtD,cAAc;MAC5B;;MAEA;MACAO,GAAG,CAACiC,SAAS,CAAC,CAAC;MACfjC,GAAG,CAACmD,GAAG,CAACN,CAAC,EAAEC,CAAC,EAAEtD,UAAU,EAAE,CAAC,EAAE,CAAC,GAAGY,IAAI,CAACgD,EAAE,CAAC;MACzCpD,GAAG,CAACuC,SAAS,GAAGQ,SAAS;MACzB/C,GAAG,CAACqD,IAAI,CAAC,CAAC;;MAEV;MACArD,GAAG,CAACgB,WAAW,GAAG,SAAS;MAC3BhB,GAAG,CAACiB,SAAS,GAAG,CAAC;MACjBjB,GAAG,CAACoC,MAAM,CAAC,CAAC;;MAEZ;MACApC,GAAG,CAACuC,SAAS,GAAG3C,SAAS;;MAEzB;MACA,MAAM0D,SAAS,GAAG9C,IAAI,CAAC+C,KAAK,CAACC,QAAQ,CAAC,CAAC;MACvC,MAAMC,QAAQ,GAAGH,SAAS,CAACI,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE;MAE/C1D,GAAG,CAACwC,IAAI,GAAG,QAAQiB,QAAQ,UAAU;MACrCzD,GAAG,CAACyC,SAAS,GAAG,QAAQ;MACxBzC,GAAG,CAAC0C,YAAY,GAAG,QAAQ;MAC3B1C,GAAG,CAAC2C,QAAQ,CAACW,SAAS,EAAET,CAAC,EAAEC,CAAC,CAAC;;MAE7B;MACA9C,GAAG,CAACuC,SAAS,GAAG,SAAS;MACzBvC,GAAG,CAACwC,IAAI,GAAG,YAAY;MACvBxC,GAAG,CAAC2C,QAAQ,CAAC,QAAQnC,IAAI,CAACgB,EAAE,EAAE,EAAEqB,CAAC,EAAEC,CAAC,GAAGtD,UAAU,GAAG,EAAE,CAAC;IACzD,CAAC,CAAC;EACJ,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,MAAMuB,iBAAiB,GAAIf,GAAG,IAAK;IACjCA,GAAG,CAACuC,SAAS,GAAG,SAAS;IACzBvC,GAAG,CAACwC,IAAI,GAAG,YAAY;IACvBxC,GAAG,CAACyC,SAAS,GAAG,MAAM;IACtBzC,GAAG,CAAC0C,YAAY,GAAG,KAAK;IACxB1C,GAAG,CAAC2C,QAAQ,CAAC,oCAAoC,EAAE,EAAE,EAAE,EAAE,CAAC;;IAE1D;IACA,MAAMgB,OAAO,GAAGpE,MAAM,GAAG,EAAE;;IAE3B;IACAS,GAAG,CAACiC,SAAS,CAAC,CAAC;IACfjC,GAAG,CAACmD,GAAG,CAAC,EAAE,EAAEQ,OAAO,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,GAAGvD,IAAI,CAACgD,EAAE,CAAC;IACxCpD,GAAG,CAACuC,SAAS,GAAG7C,SAAS;IACzBM,GAAG,CAACqD,IAAI,CAAC,CAAC;IACVrD,GAAG,CAACoC,MAAM,CAAC,CAAC;IACZpC,GAAG,CAACuC,SAAS,GAAG,SAAS;IACzBvC,GAAG,CAACyC,SAAS,GAAG,MAAM;IACtBzC,GAAG,CAAC2C,QAAQ,CAAC,eAAe,EAAE,EAAE,EAAEgB,OAAO,GAAG,CAAC,CAAC;;IAE9C;IACA3D,GAAG,CAACiC,SAAS,CAAC,CAAC;IACfjC,GAAG,CAACmD,GAAG,CAAC,GAAG,EAAEQ,OAAO,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,GAAGvD,IAAI,CAACgD,EAAE,CAAC;IACzCpD,GAAG,CAACuC,SAAS,GAAG5C,SAAS;IACzBK,GAAG,CAACqD,IAAI,CAAC,CAAC;IACVrD,GAAG,CAACoC,MAAM,CAAC,CAAC;IACZpC,GAAG,CAACuC,SAAS,GAAG,SAAS;IACzBvC,GAAG,CAAC2C,QAAQ,CAAC,WAAW,EAAE,GAAG,EAAEgB,OAAO,GAAG,CAAC,CAAC;;IAE3C;IACA3D,GAAG,CAACiC,SAAS,CAAC,CAAC;IACfjC,GAAG,CAACmD,GAAG,CAAC,GAAG,EAAEQ,OAAO,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,GAAGvD,IAAI,CAACgD,EAAE,CAAC;IACzCpD,GAAG,CAACuC,SAAS,GAAG9C,cAAc;IAC9BO,GAAG,CAACqD,IAAI,CAAC,CAAC;IACVrD,GAAG,CAACoC,MAAM,CAAC,CAAC;IACZpC,GAAG,CAACuC,SAAS,GAAG,SAAS;IACzBvC,GAAG,CAAC2C,QAAQ,CAAC,cAAc,EAAE,GAAG,EAAEgB,OAAO,GAAG,CAAC,CAAC;EAChD,CAAC;EAED,oBACE1E,KAAA,CAAA2E,aAAA;IAAKC,SAAS,EAAC,iBAAiB;IAAAC,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,gBAC9BlF,KAAA,CAAA2E,aAAA;IACEQ,GAAG,EAAEvE,SAAU;IACfP,KAAK,EAAEA,KAAM;IACbC,MAAM,EAAEA,MAAO;IACfsE,SAAS,EAAC,aAAa;IACvBQ,KAAK,EAAE;MAAEC,MAAM,EAAE,gBAAgB;MAAEC,YAAY,EAAE;IAAM,CAAE;IAAAT,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,CAC1D,CAAC,EACD,CAAC9E,aAAa,iBACbJ,KAAA,CAAA2E,aAAA;IAAKC,SAAS,EAAC,kBAAkB;IAACQ,KAAK,EAAE;MACvCG,QAAQ,EAAE,UAAU;MACpBC,GAAG,EAAE,KAAK;MACVC,IAAI,EAAE,KAAK;MACXC,SAAS,EAAE,uBAAuB;MAClCC,KAAK,EAAE,MAAM;MACbnB,QAAQ,EAAE;IACZ,CAAE;IAAAK,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,GAAC,oCAEE,CAEJ,CAAC;AAEV,CAAC;AAED,eAAe/E,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module"}