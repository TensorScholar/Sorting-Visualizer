{"ast":null,"code":"// src/algorithms/comparison/quick.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Quick Sort with multiple optimization strategies.\n * \n * Quick Sort is a divide-and-conquer algorithm that:\n * 1. Selects a 'pivot' element from the array\n * 2. Partitions the array around the pivot (elements < pivot on the left, elements > pivot on the right)\n * 3. Recursively applies the above steps to the sub-arrays\n * \n * This implementation includes sophisticated optimizations:\n * 1. Multiple pivot selection strategies (first, last, middle, random, median-of-three)\n * 2. Three-way partitioning (Dutch national flag algorithm) for handling duplicates efficiently\n * 3. Insertion sort for small subarrays to reduce recursion overhead\n * 4. Tail recursion elimination to reduce stack space requirements\n * 5. Adaptive pivot selection based on array characteristics\n * \n * Time Complexity:\n * - Best:    O(n log n) when partitions are balanced\n * - Average: O(n log n)\n * - Worst:   O(n²) with pathological pivot choices, but mitigated by our optimizations\n * \n * Space Complexity:\n * - O(log n) average case for recursion stack\n * - O(n) worst case with unbalanced partitions\n * \n * @class QuickSort\n * @extends Algorithm\n */\nclass QuickSort extends Algorithm {\n  /**\n   * Create a new QuickSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {string} [options.pivotStrategy='median-of-three'] - Strategy for selecting pivot\n   * @param {number} [options.insertionThreshold=16] - Threshold for switching to insertion sort\n   * @param {boolean} [options.threeWayPartition=true] - Use three-way partitioning for duplicates\n   * @param {boolean} [options.tailRecursion=true] - Use tail recursion optimization\n   * @param {boolean} [options.adaptivePivot=true] - Adapt pivot strategy based on array characteristics\n   */\n  constructor(options = {}) {\n    super('Quick Sort', 'comparison', options);\n\n    // Default options with carefully chosen values based on empirical performance data\n    this.options = {\n      pivotStrategy: 'median-of-three',\n      // Strategy for selecting pivot\n      insertionThreshold: 16,\n      // Switch to insertion sort for small arrays\n      threeWayPartition: true,\n      // Use three-way partitioning for handling duplicates\n      tailRecursion: true,\n      // Use tail recursion optimization\n      adaptivePivot: true,\n      // Adapt pivot strategy based on array characteristics\n      ...options\n    };\n  }\n\n  /**\n   * Execute Quick Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Create a copy to avoid modifying the original array\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for edge cases\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('sorting');\n\n    // Start the quicksort process\n    this.quickSort(result, 0, n - 1, options);\n    this.setPhase('completed');\n    return result;\n  }\n\n  /**\n   * Main recursive Quick Sort function\n   * \n   * @param {Array} array - The array being sorted\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {Object} options - Runtime options\n   */\n  quickSort(array, low, high, options) {\n    // Record the current recursive call\n    this.recordState(array, {\n      type: 'recursive-call',\n      section: [low, high],\n      message: `Sorting section from index ${low} to ${high}`\n    });\n\n    // Base case: If the partition size is below threshold, use insertion sort\n    if (high - low < options.insertionThreshold) {\n      this.insertionSort(array, low, high);\n      return;\n    }\n\n    // Base case: If the partition is empty or has only one element\n    if (low >= high) {\n      return;\n    }\n\n    // Choose the partitioning algorithm based on options\n    if (options.threeWayPartition) {\n      // Three-way partitioning for arrays with potential duplicates\n      const [lt, gt] = this.threeWayPartition(array, low, high, options);\n\n      // Record completed partitioning\n      this.recordState(array, {\n        type: 'partition-complete',\n        lt: lt,\n        gt: gt,\n        message: `Three-way partition: [${low}...${lt - 1}] < pivot, [${lt}...${gt}] = pivot, [${gt + 1}...${high}] > pivot`\n      });\n\n      // Recursively sort left partition\n      this.quickSort(array, low, lt - 1, options);\n\n      // Recursively sort right partition using tail recursion optimization if enabled\n      if (options.tailRecursion) {\n        // Instead of recursing, prepare for next iteration\n        low = gt + 1;\n        // Continue the loop (implicit tail recursion)\n        if (low < high) {\n          this.quickSort(array, low, high, options);\n        }\n      } else {\n        // Standard recursive call for right partition\n        this.quickSort(array, gt + 1, high, options);\n      }\n    } else {\n      // Standard partitioning\n      const pivotIndex = this.partition(array, low, high, options);\n\n      // Record completed partitioning\n      this.recordState(array, {\n        type: 'partition-complete',\n        pivotIndex: pivotIndex,\n        message: `Standard partition: pivot at index ${pivotIndex}`\n      });\n\n      // Recursively sort left partition\n      this.quickSort(array, low, pivotIndex - 1, options);\n\n      // Recursively sort right partition using tail recursion optimization if enabled\n      if (options.tailRecursion) {\n        // Instead of recursing, prepare for next iteration\n        low = pivotIndex + 1;\n        // Continue the loop (implicit tail recursion)\n        if (low < high) {\n          this.quickSort(array, low, high, options);\n        }\n      } else {\n        // Standard recursive call for right partition\n        this.quickSort(array, pivotIndex + 1, high, options);\n      }\n    }\n  }\n\n  /**\n   * Standard partition scheme (Lomuto's partition)\n   * \n   * @param {Array} array - The array to partition\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {Object} options - Runtime options\n   * @returns {number} - Final position of the pivot\n   */\n  partition(array, low, high, options) {\n    // Select a pivot based on the chosen strategy\n    const pivotIndex = this.selectPivot(array, low, high, options.pivotStrategy, options.adaptivePivot);\n\n    // Record pivot selection\n    this.recordState(array, {\n      type: 'pivot-selection',\n      pivotIndex: pivotIndex,\n      value: array[pivotIndex],\n      strategy: options.adaptivePivot ? 'adaptive' : options.pivotStrategy,\n      message: `Selected pivot ${array[pivotIndex]} at index ${pivotIndex}`\n    });\n\n    // Move pivot to the end temporarily\n    this.swap(array, pivotIndex, high);\n\n    // Record pivot movement\n    this.recordState(array, {\n      type: 'pivot-movement',\n      indices: [pivotIndex, high],\n      message: `Moved pivot to index ${high} for partitioning`\n    });\n    const pivotValue = this.read(array, high);\n\n    // Initialize partition index\n    let i = low;\n\n    // Partition the array\n    for (let j = low; j < high; j++) {\n      // Compare current element with pivot\n      const comparison = this.compare(this.read(array, j), pivotValue);\n\n      // Record comparison\n      this.recordState(array, {\n        type: 'comparison',\n        indices: [j, high],\n        result: comparison,\n        message: `Comparing element at index ${j} with pivot`\n      });\n\n      // If current element is less than pivot, move it to the left side\n      if (comparison < 0) {\n        // Swap elements\n        if (i !== j) {\n          this.swap(array, i, j);\n\n          // Record the swap\n          this.recordState(array, {\n            type: 'partition-swap',\n            indices: [i, j],\n            message: `Moved smaller element from index ${j} to ${i}`\n          });\n        }\n\n        // Increment partition index\n        i++;\n      }\n    }\n\n    // Move pivot to its final position\n    this.swap(array, i, high);\n\n    // Record final pivot position\n    this.recordState(array, {\n      type: 'pivot-final',\n      pivotIndex: i,\n      message: `Placed pivot ${pivotValue} at final position ${i}`\n    });\n    return i;\n  }\n\n  /**\n   * Three-way partitioning (Dutch national flag algorithm)\n   * Handles duplicates efficiently by creating three partitions:\n   * - Elements less than pivot\n   * - Elements equal to pivot\n   * - Elements greater than pivot\n   * \n   * @param {Array} array - The array to partition\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {Object} options - Runtime options\n   * @returns {Array} - [lt, gt] indices where lt is the first element equal to pivot and gt is the last\n   */\n  threeWayPartition(array, low, high, options) {\n    // Select a pivot based on the chosen strategy\n    const pivotIndex = this.selectPivot(array, low, high, options.pivotStrategy, options.adaptivePivot);\n\n    // Record pivot selection\n    this.recordState(array, {\n      type: 'pivot-selection',\n      pivotIndex: pivotIndex,\n      value: array[pivotIndex],\n      strategy: options.adaptivePivot ? 'adaptive' : options.pivotStrategy,\n      message: `Selected pivot ${array[pivotIndex]} at index ${pivotIndex} for three-way partition`\n    });\n    const pivotValue = this.read(array, pivotIndex);\n\n    // Initialize pointers for the three sections\n    let lt = low; // Elements < pivot will be to the left of lt\n    let gt = high; // Elements > pivot will be to the right of gt\n    let i = low; // Current element being examined\n\n    // Partition the array\n    while (i <= gt) {\n      // Compare current element with pivot\n      const comparison = this.compare(this.read(array, i), pivotValue);\n\n      // Record comparison\n      this.recordState(array, {\n        type: 'comparison',\n        indices: [i, pivotIndex],\n        result: comparison,\n        message: `Comparing element at index ${i} with pivot`\n      });\n      if (comparison < 0) {\n        // Element is less than pivot, move to the left section\n        this.swap(array, lt, i);\n\n        // Record the swap\n        this.recordState(array, {\n          type: 'partition-swap',\n          indices: [lt, i],\n          message: `Moved smaller element from index ${i} to ${lt}`\n        });\n        lt++;\n        i++;\n      } else if (comparison > 0) {\n        // Element is greater than pivot, move to the right section\n        this.swap(array, i, gt);\n\n        // Record the swap\n        this.recordState(array, {\n          type: 'partition-swap',\n          indices: [i, gt],\n          message: `Moved larger element from index ${i} to ${gt}`\n        });\n        gt--;\n        // Don't increment i since we need to examine the element we just swapped in\n      } else {\n        // Element is equal to pivot, keep in the middle section\n        i++;\n      }\n    }\n\n    // Record final partitioning\n    this.recordState(array, {\n      type: 'three-way-partition',\n      lt: lt,\n      gt: gt,\n      message: `Three-way partition complete: [${low}...${lt - 1}] < pivot, [${lt}...${gt}] = pivot, [${gt + 1}...${high}] > pivot`\n    });\n    return [lt, gt];\n  }\n\n  /**\n   * Insertion sort for small subarrays\n   * \n   * @param {Array} array - The array to sort\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   */\n  insertionSort(array, low, high) {\n    // Record switch to insertion sort\n    this.recordState(array, {\n      type: 'algorithm-switch',\n      section: [low, high],\n      message: `Switching to insertion sort for small subarray [${low}...${high}]`\n    });\n    for (let i = low + 1; i <= high; i++) {\n      const key = this.read(array, i);\n      let j = i - 1;\n\n      // Find the correct position for the key\n      while (j >= low && this.compare(this.read(array, j), key) > 0) {\n        // Shift elements to the right\n        this.write(array, j + 1, this.read(array, j));\n        j--;\n      }\n\n      // Insert the key in its correct position\n      if (j + 1 !== i) {\n        this.write(array, j + 1, key);\n\n        // Record insertion\n        this.recordState(array, {\n          type: 'insertion',\n          index: j + 1,\n          value: key,\n          message: `Inserted ${key} at position ${j + 1}`\n        });\n      }\n    }\n\n    // Record completion of insertion sort\n    this.recordState(array, {\n      type: 'subarray-sorted',\n      section: [low, high],\n      message: `Insertion sort complete for subarray [${low}...${high}]`\n    });\n  }\n\n  /**\n   * Select a pivot element using the specified strategy\n   * \n   * @param {Array} array - The array\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {string} strategy - Pivot selection strategy\n   * @param {boolean} adaptive - Whether to use adaptive pivot selection\n   * @returns {number} - Index of the selected pivot\n   */\n  selectPivot(array, low, high, strategy, adaptive) {\n    // Early return for single-element arrays\n    if (low === high) {\n      return low;\n    }\n\n    // Adaptive pivot selection based on array characteristics\n    if (adaptive) {\n      // Examine a sample of elements to determine the best strategy\n      const size = high - low + 1;\n      if (size >= 16) {\n        // For larger arrays, check if the array might be partially sorted\n        const samples = [low, Math.floor(low + size * 0.25), Math.floor(low + size * 0.5), Math.floor(low + size * 0.75), high];\n        let ascending = 0;\n        let descending = 0;\n\n        // Check for ascending or descending patterns\n        for (let i = 1; i < samples.length; i++) {\n          const comparison = this.compare(array[samples[i - 1]], array[samples[i]]);\n          if (comparison <= 0) ascending++;\n          if (comparison >= 0) descending++;\n        }\n\n        // If the array appears to be partially sorted, use median-of-three\n        if (ascending >= 3 || descending >= 3) {\n          return this.medianOfThree(array, low, high);\n        }\n\n        // Otherwise, use a strategy appropriate for the array size\n        if (size > 100) {\n          // For very large arrays, use median-of-medians (approximated with ninther)\n          return this.ninther(array, low, high);\n        }\n      }\n    }\n\n    // Standard pivot selection strategies\n    switch (strategy) {\n      case 'first':\n        return low;\n      case 'last':\n        return high;\n      case 'middle':\n        return Math.floor(low + (high - low) / 2);\n      case 'random':\n        return Math.floor(low + Math.random() * (high - low + 1));\n      case 'median-of-three':\n        return this.medianOfThree(array, low, high);\n      default:\n        // Default to median-of-three as it provides good general performance\n        return this.medianOfThree(array, low, high);\n    }\n  }\n\n  /**\n   * Find the median of three elements (first, middle, last)\n   * \n   * @param {Array} array - The array\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @returns {number} - Index of the median element\n   */\n  medianOfThree(array, low, high) {\n    const mid = Math.floor(low + (high - low) / 2);\n\n    // Compare the three elements\n    if (this.compare(array[low], array[mid]) > 0) {\n      if (this.compare(array[mid], array[high]) > 0) {\n        return mid; // mid is the median\n      } else if (this.compare(array[low], array[high]) > 0) {\n        return high; // high is the median\n      } else {\n        return low; // low is the median\n      }\n    } else {\n      if (this.compare(array[low], array[high]) > 0) {\n        return low; // low is the median\n      } else if (this.compare(array[mid], array[high]) > 0) {\n        return high; // high is the median\n      } else {\n        return mid; // mid is the median\n      }\n    }\n  }\n\n  /**\n   * Find the \"ninther\" - the median of medians of three samples of three elements\n   * This is a good approximation of the true median with minimal overhead\n   * \n   * @param {Array} array - The array\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @returns {number} - Index of the selected pivot\n   */\n  ninther(array, low, high) {\n    const size = high - low + 1;\n    const step = Math.floor(size / 8);\n\n    // Select three points for each of three sections\n    const sections = [[low, low + step, low + 2 * step], [Math.floor(low + (high - low) / 2) - step, Math.floor(low + (high - low) / 2), Math.floor(low + (high - low) / 2) + step], [high - 2 * step, high - step, high]];\n\n    // Find the median of each section\n    const medians = [];\n    for (const section of sections) {\n      medians.push(this.medianOfThree(array, section[0], section[2]));\n    }\n\n    // Return the median of the three medians\n    return this.medianOfThree(array, medians[0], medians[2]);\n  }\n\n  /**\n   * Get the time and space complexity of Quick Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(n log n)',\n        average: 'O(n log n)',\n        worst: 'O(n²)' // Although our optimizations mitigate this in practice\n      },\n      space: {\n        best: 'O(log n)',\n        average: 'O(log n)',\n        worst: 'O(n)'\n      }\n    };\n  }\n\n  /**\n   * Whether Quick Sort is stable (preserves relative order of equal elements)\n   * \n   * @returns {boolean} - False as standard Quick Sort is not stable\n   */\n  isStable() {\n    return false;\n  }\n\n  /**\n   * Whether Quick Sort is in-place (uses minimal auxiliary space)\n   * \n   * @returns {boolean} - True as Quick Sort is generally considered in-place\n   */\n  isInPlace() {\n    return true;\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add quicksort specific information\n    info.optimization = {\n      pivotStrategy: this.options.pivotStrategy,\n      adaptivePivot: this.options.adaptivePivot,\n      insertionThreshold: this.options.insertionThreshold,\n      threeWayPartition: this.options.threeWayPartition,\n      tailRecursion: this.options.tailRecursion\n    };\n    info.properties = {\n      comparisonBased: true,\n      stable: false,\n      inPlace: true,\n      online: false,\n      divideAndConquer: true,\n      adaptive: this.options.adaptivePivot\n    };\n    info.suitable = {\n      smallArrays: true,\n      // With insertion sort optimization\n      nearlySortedArrays: this.options.adaptivePivot,\n      // If using adaptive pivot\n      largeArrays: true,\n      duplicateElements: this.options.threeWayPartition // Especially with three-way partitioning\n    };\n    info.variants = ['Lomuto partition scheme', 'Hoare partition scheme', 'Three-way partitioning (Dutch national flag)', 'Dual-pivot Quick Sort', 'Introsort (hybrid with Heap Sort)', 'Quick Sort with median-of-medians'];\n    info.pivotStrategies = {\n      first: 'Simple but performs poorly on sorted arrays',\n      last: 'Simple but performs poorly on reverse-sorted arrays',\n      middle: 'Good for partially sorted arrays',\n      random: 'Probabilistic protection against worst-case inputs',\n      'median-of-three': 'Good general-purpose strategy, helps with partially sorted arrays',\n      adaptive: 'Dynamically chooses strategy based on array characteristics',\n      ninther: 'Good approximation of true median for large arrays'\n    };\n    info.advantages = ['Fast in-place sorting with excellent average-case performance', 'Good cache locality for in-memory sorting', 'Low overhead with minimal memory usage', 'Can be optimized for different types of input data', 'Outperforms other O(n log n) algorithms in practice for random data'];\n    info.disadvantages = ['Not stable (does not preserve order of equal elements)', 'Vulnerable to worst-case O(n²) behavior without proper pivot selection', 'Requires careful optimization to handle corner cases efficiently', 'Recursive implementation can cause stack overflow for large arrays without tail recursion optimization'];\n    info.performance = {\n      bestCase: 'Random data with balanced partitioning',\n      worstCase: 'Sorted or reverse-sorted arrays with poor pivot selection strategy',\n      averageCase: 'Random data with occasional skewed partitions'\n    };\n    return info;\n  }\n}\nexport default QuickSort;","map":{"version":3,"names":["Algorithm","QuickSort","constructor","options","pivotStrategy","insertionThreshold","threeWayPartition","tailRecursion","adaptivePivot","run","array","result","n","length","setPhase","quickSort","low","high","recordState","type","section","message","insertionSort","lt","gt","pivotIndex","partition","selectPivot","value","strategy","swap","indices","pivotValue","read","i","j","comparison","compare","key","write","index","adaptive","size","samples","Math","floor","ascending","descending","medianOfThree","ninther","random","mid","step","sections","medians","push","getComplexity","time","best","average","worst","space","isStable","isInPlace","getInfo","info","optimization","properties","comparisonBased","stable","inPlace","online","divideAndConquer","suitable","smallArrays","nearlySortedArrays","largeArrays","duplicateElements","variants","pivotStrategies","first","last","middle","advantages","disadvantages","performance","bestCase","worstCase","averageCase"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/comparison/quick.js"],"sourcesContent":["// src/algorithms/comparison/quick.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Quick Sort with multiple optimization strategies.\n * \n * Quick Sort is a divide-and-conquer algorithm that:\n * 1. Selects a 'pivot' element from the array\n * 2. Partitions the array around the pivot (elements < pivot on the left, elements > pivot on the right)\n * 3. Recursively applies the above steps to the sub-arrays\n * \n * This implementation includes sophisticated optimizations:\n * 1. Multiple pivot selection strategies (first, last, middle, random, median-of-three)\n * 2. Three-way partitioning (Dutch national flag algorithm) for handling duplicates efficiently\n * 3. Insertion sort for small subarrays to reduce recursion overhead\n * 4. Tail recursion elimination to reduce stack space requirements\n * 5. Adaptive pivot selection based on array characteristics\n * \n * Time Complexity:\n * - Best:    O(n log n) when partitions are balanced\n * - Average: O(n log n)\n * - Worst:   O(n²) with pathological pivot choices, but mitigated by our optimizations\n * \n * Space Complexity:\n * - O(log n) average case for recursion stack\n * - O(n) worst case with unbalanced partitions\n * \n * @class QuickSort\n * @extends Algorithm\n */\nclass QuickSort extends Algorithm {\n  /**\n   * Create a new QuickSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {string} [options.pivotStrategy='median-of-three'] - Strategy for selecting pivot\n   * @param {number} [options.insertionThreshold=16] - Threshold for switching to insertion sort\n   * @param {boolean} [options.threeWayPartition=true] - Use three-way partitioning for duplicates\n   * @param {boolean} [options.tailRecursion=true] - Use tail recursion optimization\n   * @param {boolean} [options.adaptivePivot=true] - Adapt pivot strategy based on array characteristics\n   */\n  constructor(options = {}) {\n    super('Quick Sort', 'comparison', options);\n    \n    // Default options with carefully chosen values based on empirical performance data\n    this.options = {\n      pivotStrategy: 'median-of-three', // Strategy for selecting pivot\n      insertionThreshold: 16,           // Switch to insertion sort for small arrays\n      threeWayPartition: true,          // Use three-way partitioning for handling duplicates\n      tailRecursion: true,              // Use tail recursion optimization\n      adaptivePivot: true,              // Adapt pivot strategy based on array characteristics\n      ...options\n    };\n  }\n  \n  /**\n   * Execute Quick Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Create a copy to avoid modifying the original array\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for edge cases\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('sorting');\n    \n    // Start the quicksort process\n    this.quickSort(result, 0, n - 1, options);\n    \n    this.setPhase('completed');\n    return result;\n  }\n  \n  /**\n   * Main recursive Quick Sort function\n   * \n   * @param {Array} array - The array being sorted\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {Object} options - Runtime options\n   */\n  quickSort(array, low, high, options) {\n    // Record the current recursive call\n    this.recordState(array, {\n      type: 'recursive-call',\n      section: [low, high],\n      message: `Sorting section from index ${low} to ${high}`\n    });\n    \n    // Base case: If the partition size is below threshold, use insertion sort\n    if (high - low < options.insertionThreshold) {\n      this.insertionSort(array, low, high);\n      return;\n    }\n    \n    // Base case: If the partition is empty or has only one element\n    if (low >= high) {\n      return;\n    }\n    \n    // Choose the partitioning algorithm based on options\n    if (options.threeWayPartition) {\n      // Three-way partitioning for arrays with potential duplicates\n      const [lt, gt] = this.threeWayPartition(array, low, high, options);\n      \n      // Record completed partitioning\n      this.recordState(array, {\n        type: 'partition-complete',\n        lt: lt,\n        gt: gt,\n        message: `Three-way partition: [${low}...${lt-1}] < pivot, [${lt}...${gt}] = pivot, [${gt+1}...${high}] > pivot`\n      });\n      \n      // Recursively sort left partition\n      this.quickSort(array, low, lt - 1, options);\n      \n      // Recursively sort right partition using tail recursion optimization if enabled\n      if (options.tailRecursion) {\n        // Instead of recursing, prepare for next iteration\n        low = gt + 1;\n        // Continue the loop (implicit tail recursion)\n        if (low < high) {\n          this.quickSort(array, low, high, options);\n        }\n      } else {\n        // Standard recursive call for right partition\n        this.quickSort(array, gt + 1, high, options);\n      }\n    } else {\n      // Standard partitioning\n      const pivotIndex = this.partition(array, low, high, options);\n      \n      // Record completed partitioning\n      this.recordState(array, {\n        type: 'partition-complete',\n        pivotIndex: pivotIndex,\n        message: `Standard partition: pivot at index ${pivotIndex}`\n      });\n      \n      // Recursively sort left partition\n      this.quickSort(array, low, pivotIndex - 1, options);\n      \n      // Recursively sort right partition using tail recursion optimization if enabled\n      if (options.tailRecursion) {\n        // Instead of recursing, prepare for next iteration\n        low = pivotIndex + 1;\n        // Continue the loop (implicit tail recursion)\n        if (low < high) {\n          this.quickSort(array, low, high, options);\n        }\n      } else {\n        // Standard recursive call for right partition\n        this.quickSort(array, pivotIndex + 1, high, options);\n      }\n    }\n  }\n  \n  /**\n   * Standard partition scheme (Lomuto's partition)\n   * \n   * @param {Array} array - The array to partition\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {Object} options - Runtime options\n   * @returns {number} - Final position of the pivot\n   */\n  partition(array, low, high, options) {\n    // Select a pivot based on the chosen strategy\n    const pivotIndex = this.selectPivot(array, low, high, options.pivotStrategy, options.adaptivePivot);\n    \n    // Record pivot selection\n    this.recordState(array, {\n      type: 'pivot-selection',\n      pivotIndex: pivotIndex,\n      value: array[pivotIndex],\n      strategy: options.adaptivePivot ? 'adaptive' : options.pivotStrategy,\n      message: `Selected pivot ${array[pivotIndex]} at index ${pivotIndex}`\n    });\n    \n    // Move pivot to the end temporarily\n    this.swap(array, pivotIndex, high);\n    \n    // Record pivot movement\n    this.recordState(array, {\n      type: 'pivot-movement',\n      indices: [pivotIndex, high],\n      message: `Moved pivot to index ${high} for partitioning`\n    });\n    \n    const pivotValue = this.read(array, high);\n    \n    // Initialize partition index\n    let i = low;\n    \n    // Partition the array\n    for (let j = low; j < high; j++) {\n      // Compare current element with pivot\n      const comparison = this.compare(this.read(array, j), pivotValue);\n      \n      // Record comparison\n      this.recordState(array, {\n        type: 'comparison',\n        indices: [j, high],\n        result: comparison,\n        message: `Comparing element at index ${j} with pivot`\n      });\n      \n      // If current element is less than pivot, move it to the left side\n      if (comparison < 0) {\n        // Swap elements\n        if (i !== j) {\n          this.swap(array, i, j);\n          \n          // Record the swap\n          this.recordState(array, {\n            type: 'partition-swap',\n            indices: [i, j],\n            message: `Moved smaller element from index ${j} to ${i}`\n          });\n        }\n        \n        // Increment partition index\n        i++;\n      }\n    }\n    \n    // Move pivot to its final position\n    this.swap(array, i, high);\n    \n    // Record final pivot position\n    this.recordState(array, {\n      type: 'pivot-final',\n      pivotIndex: i,\n      message: `Placed pivot ${pivotValue} at final position ${i}`\n    });\n    \n    return i;\n  }\n  \n  /**\n   * Three-way partitioning (Dutch national flag algorithm)\n   * Handles duplicates efficiently by creating three partitions:\n   * - Elements less than pivot\n   * - Elements equal to pivot\n   * - Elements greater than pivot\n   * \n   * @param {Array} array - The array to partition\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {Object} options - Runtime options\n   * @returns {Array} - [lt, gt] indices where lt is the first element equal to pivot and gt is the last\n   */\n  threeWayPartition(array, low, high, options) {\n    // Select a pivot based on the chosen strategy\n    const pivotIndex = this.selectPivot(array, low, high, options.pivotStrategy, options.adaptivePivot);\n    \n    // Record pivot selection\n    this.recordState(array, {\n      type: 'pivot-selection',\n      pivotIndex: pivotIndex,\n      value: array[pivotIndex],\n      strategy: options.adaptivePivot ? 'adaptive' : options.pivotStrategy,\n      message: `Selected pivot ${array[pivotIndex]} at index ${pivotIndex} for three-way partition`\n    });\n    \n    const pivotValue = this.read(array, pivotIndex);\n    \n    // Initialize pointers for the three sections\n    let lt = low;      // Elements < pivot will be to the left of lt\n    let gt = high;     // Elements > pivot will be to the right of gt\n    let i = low;       // Current element being examined\n    \n    // Partition the array\n    while (i <= gt) {\n      // Compare current element with pivot\n      const comparison = this.compare(this.read(array, i), pivotValue);\n      \n      // Record comparison\n      this.recordState(array, {\n        type: 'comparison',\n        indices: [i, pivotIndex],\n        result: comparison,\n        message: `Comparing element at index ${i} with pivot`\n      });\n      \n      if (comparison < 0) {\n        // Element is less than pivot, move to the left section\n        this.swap(array, lt, i);\n        \n        // Record the swap\n        this.recordState(array, {\n          type: 'partition-swap',\n          indices: [lt, i],\n          message: `Moved smaller element from index ${i} to ${lt}`\n        });\n        \n        lt++;\n        i++;\n      } else if (comparison > 0) {\n        // Element is greater than pivot, move to the right section\n        this.swap(array, i, gt);\n        \n        // Record the swap\n        this.recordState(array, {\n          type: 'partition-swap',\n          indices: [i, gt],\n          message: `Moved larger element from index ${i} to ${gt}`\n        });\n        \n        gt--;\n        // Don't increment i since we need to examine the element we just swapped in\n      } else {\n        // Element is equal to pivot, keep in the middle section\n        i++;\n      }\n    }\n    \n    // Record final partitioning\n    this.recordState(array, {\n      type: 'three-way-partition',\n      lt: lt,\n      gt: gt,\n      message: `Three-way partition complete: [${low}...${lt-1}] < pivot, [${lt}...${gt}] = pivot, [${gt+1}...${high}] > pivot`\n    });\n    \n    return [lt, gt];\n  }\n  \n  /**\n   * Insertion sort for small subarrays\n   * \n   * @param {Array} array - The array to sort\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   */\n  insertionSort(array, low, high) {\n    // Record switch to insertion sort\n    this.recordState(array, {\n      type: 'algorithm-switch',\n      section: [low, high],\n      message: `Switching to insertion sort for small subarray [${low}...${high}]`\n    });\n    \n    for (let i = low + 1; i <= high; i++) {\n      const key = this.read(array, i);\n      let j = i - 1;\n      \n      // Find the correct position for the key\n      while (j >= low && this.compare(this.read(array, j), key) > 0) {\n        // Shift elements to the right\n        this.write(array, j + 1, this.read(array, j));\n        j--;\n      }\n      \n      // Insert the key in its correct position\n      if (j + 1 !== i) {\n        this.write(array, j + 1, key);\n        \n        // Record insertion\n        this.recordState(array, {\n          type: 'insertion',\n          index: j + 1,\n          value: key,\n          message: `Inserted ${key} at position ${j + 1}`\n        });\n      }\n    }\n    \n    // Record completion of insertion sort\n    this.recordState(array, {\n      type: 'subarray-sorted',\n      section: [low, high],\n      message: `Insertion sort complete for subarray [${low}...${high}]`\n    });\n  }\n  \n  /**\n   * Select a pivot element using the specified strategy\n   * \n   * @param {Array} array - The array\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {string} strategy - Pivot selection strategy\n   * @param {boolean} adaptive - Whether to use adaptive pivot selection\n   * @returns {number} - Index of the selected pivot\n   */\n  selectPivot(array, low, high, strategy, adaptive) {\n    // Early return for single-element arrays\n    if (low === high) {\n      return low;\n    }\n    \n    // Adaptive pivot selection based on array characteristics\n    if (adaptive) {\n      // Examine a sample of elements to determine the best strategy\n      const size = high - low + 1;\n      \n      if (size >= 16) {\n        // For larger arrays, check if the array might be partially sorted\n        const samples = [\n          low, \n          Math.floor(low + size * 0.25), \n          Math.floor(low + size * 0.5),\n          Math.floor(low + size * 0.75),\n          high\n        ];\n        \n        let ascending = 0;\n        let descending = 0;\n        \n        // Check for ascending or descending patterns\n        for (let i = 1; i < samples.length; i++) {\n          const comparison = this.compare(array[samples[i-1]], array[samples[i]]);\n          if (comparison <= 0) ascending++;\n          if (comparison >= 0) descending++;\n        }\n        \n        // If the array appears to be partially sorted, use median-of-three\n        if (ascending >= 3 || descending >= 3) {\n          return this.medianOfThree(array, low, high);\n        }\n        \n        // Otherwise, use a strategy appropriate for the array size\n        if (size > 100) {\n          // For very large arrays, use median-of-medians (approximated with ninther)\n          return this.ninther(array, low, high);\n        }\n      }\n    }\n    \n    // Standard pivot selection strategies\n    switch (strategy) {\n      case 'first':\n        return low;\n        \n      case 'last':\n        return high;\n        \n      case 'middle':\n        return Math.floor(low + (high - low) / 2);\n        \n      case 'random':\n        return Math.floor(low + Math.random() * (high - low + 1));\n        \n      case 'median-of-three':\n        return this.medianOfThree(array, low, high);\n        \n      default:\n        // Default to median-of-three as it provides good general performance\n        return this.medianOfThree(array, low, high);\n    }\n  }\n  \n  /**\n   * Find the median of three elements (first, middle, last)\n   * \n   * @param {Array} array - The array\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @returns {number} - Index of the median element\n   */\n  medianOfThree(array, low, high) {\n    const mid = Math.floor(low + (high - low) / 2);\n    \n    // Compare the three elements\n    if (this.compare(array[low], array[mid]) > 0) {\n      if (this.compare(array[mid], array[high]) > 0) {\n        return mid; // mid is the median\n      } else if (this.compare(array[low], array[high]) > 0) {\n        return high; // high is the median\n      } else {\n        return low; // low is the median\n      }\n    } else {\n      if (this.compare(array[low], array[high]) > 0) {\n        return low; // low is the median\n      } else if (this.compare(array[mid], array[high]) > 0) {\n        return high; // high is the median\n      } else {\n        return mid; // mid is the median\n      }\n    }\n  }\n  \n  /**\n   * Find the \"ninther\" - the median of medians of three samples of three elements\n   * This is a good approximation of the true median with minimal overhead\n   * \n   * @param {Array} array - The array\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @returns {number} - Index of the selected pivot\n   */\n  ninther(array, low, high) {\n    const size = high - low + 1;\n    const step = Math.floor(size / 8);\n    \n    // Select three points for each of three sections\n    const sections = [\n      [low, low + step, low + 2 * step],\n      [Math.floor(low + (high - low) / 2) - step, Math.floor(low + (high - low) / 2), Math.floor(low + (high - low) / 2) + step],\n      [high - 2 * step, high - step, high]\n    ];\n    \n    // Find the median of each section\n    const medians = [];\n    for (const section of sections) {\n      medians.push(this.medianOfThree(array, section[0], section[2]));\n    }\n    \n    // Return the median of the three medians\n    return this.medianOfThree(array, medians[0], medians[2]);\n  }\n  \n  /**\n   * Get the time and space complexity of Quick Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(n log n)',\n        average: 'O(n log n)',\n        worst: 'O(n²)' // Although our optimizations mitigate this in practice\n      },\n      space: {\n        best: 'O(log n)',\n        average: 'O(log n)',\n        worst: 'O(n)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Quick Sort is stable (preserves relative order of equal elements)\n   * \n   * @returns {boolean} - False as standard Quick Sort is not stable\n   */\n  isStable() {\n    return false;\n  }\n  \n  /**\n   * Whether Quick Sort is in-place (uses minimal auxiliary space)\n   * \n   * @returns {boolean} - True as Quick Sort is generally considered in-place\n   */\n  isInPlace() {\n    return true;\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add quicksort specific information\n    info.optimization = {\n      pivotStrategy: this.options.pivotStrategy,\n      adaptivePivot: this.options.adaptivePivot,\n      insertionThreshold: this.options.insertionThreshold,\n      threeWayPartition: this.options.threeWayPartition,\n      tailRecursion: this.options.tailRecursion\n    };\n    \n    info.properties = {\n      comparisonBased: true,\n      stable: false,\n      inPlace: true,\n      online: false,\n      divideAndConquer: true,\n      adaptive: this.options.adaptivePivot\n    };\n    \n    info.suitable = {\n      smallArrays: true, // With insertion sort optimization\n      nearlySortedArrays: this.options.adaptivePivot, // If using adaptive pivot\n      largeArrays: true,\n      duplicateElements: this.options.threeWayPartition // Especially with three-way partitioning\n    };\n    \n    info.variants = [\n      'Lomuto partition scheme',\n      'Hoare partition scheme',\n      'Three-way partitioning (Dutch national flag)',\n      'Dual-pivot Quick Sort',\n      'Introsort (hybrid with Heap Sort)',\n      'Quick Sort with median-of-medians'\n    ];\n    \n    info.pivotStrategies = {\n      first: 'Simple but performs poorly on sorted arrays',\n      last: 'Simple but performs poorly on reverse-sorted arrays',\n      middle: 'Good for partially sorted arrays',\n      random: 'Probabilistic protection against worst-case inputs',\n      'median-of-three': 'Good general-purpose strategy, helps with partially sorted arrays',\n      adaptive: 'Dynamically chooses strategy based on array characteristics',\n      ninther: 'Good approximation of true median for large arrays'\n    };\n    \n    info.advantages = [\n      'Fast in-place sorting with excellent average-case performance',\n      'Good cache locality for in-memory sorting',\n      'Low overhead with minimal memory usage',\n      'Can be optimized for different types of input data',\n      'Outperforms other O(n log n) algorithms in practice for random data'\n    ];\n    \n    info.disadvantages = [\n      'Not stable (does not preserve order of equal elements)',\n      'Vulnerable to worst-case O(n²) behavior without proper pivot selection',\n      'Requires careful optimization to handle corner cases efficiently',\n      'Recursive implementation can cause stack overflow for large arrays without tail recursion optimization'\n    ];\n    \n    info.performance = {\n      bestCase: 'Random data with balanced partitioning',\n      worstCase: 'Sorted or reverse-sorted arrays with poor pivot selection strategy',\n      averageCase: 'Random data with occasional skewed partitions'\n    };\n    \n    return info;\n  }\n}\n\nexport default QuickSort;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}