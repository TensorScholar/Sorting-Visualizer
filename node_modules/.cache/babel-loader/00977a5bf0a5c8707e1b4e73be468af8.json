{"ast":null,"code":"// src/algorithms/comparison/shell.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Shell Sort with multiple gap sequence strategies and optimizations.\n * \n * Shell Sort is a generalization of insertion sort that allows the exchange of items that are\n * far apart. The algorithm sorts elements that are distant from each other, gradually reducing\n * the gap between elements to be compared until the gap is 1 (regular insertion sort).\n * \n * This implementation includes multiple gap sequences and optimizations:\n * - Original Shell sequence: N/2, N/4, ..., 1\n * - Knuth sequence: (3^k - 1)/2, where k ≥ 1 and (3^k - 1)/2 < N\n * - Sedgewick sequence: 1, 8, 23, 77, 281, 1073, 4193, 16577, ...\n * - Hibbard sequence: 2^k - 1, where k ≥ 1\n * - Pratt sequence: 2^i * 3^j, where i,j ≥ 0\n * \n * Time Complexity:\n * - Best:    O(n log n) - Depends on gap sequence\n * - Average: O(n log² n) to O(n^(4/3)) depending on gap sequence\n * - Worst:   O(n²) for original Shell sequence, O(n^(3/2)) for Hibbard\n * \n * Space Complexity: O(1) - In-place sorting algorithm\n * \n * @class ShellSort\n * @extends Algorithm\n */\nclass ShellSort extends Algorithm {\n  /**\n   * Create a new ShellSort instance with configurable options\n   * \n   * @param {Object} options - Configuration options\n   * @param {string} [options.gapSequence='sedgewick'] - Gap sequence to use\n   * @param {boolean} [options.optimizedComparisons=true] - Use binary search for large gaps\n   * @param {boolean} [options.visualizeGaps=true] - Visualize gap sequences\n   * @param {boolean} [options.enhancedInstrumentation=true] - Use enhanced operation instrumentation\n   */\n  constructor(options = {}) {\n    super('Shell Sort', 'comparison', options);\n\n    // Default options\n    this.options = {\n      gapSequence: 'sedgewick',\n      // Gap sequence strategy\n      optimizedComparisons: true,\n      // Use optimized comparisons\n      visualizeGaps: true,\n      // Visualize gap sequences\n      enhancedInstrumentation: true,\n      // Enhanced operation instrumentation\n      ...options\n    };\n\n    // Gap sequence generators\n    this.gapGenerators = {\n      'shell': this.shellSequence,\n      'knuth': this.knuthSequence,\n      'sedgewick': this.sedgewickSequence,\n      'hibbard': this.hibbardSequence,\n      'pratt': this.prattSequence\n    };\n  }\n\n  /**\n   * Execute Shell Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('sorting');\n\n    // Get gap sequence\n    const gapSequenceName = options.gapSequence || 'sedgewick';\n    const gapGenerator = this.gapGenerators[gapSequenceName.toLowerCase()] || this.gapGenerators.sedgewick;\n\n    // Generate gaps\n    const gaps = gapGenerator(n);\n\n    // Record the selected gap sequence\n    this.recordState(result, {\n      type: 'gap-sequence-selected',\n      sequence: gapSequenceName,\n      gaps: gaps,\n      message: `Using ${gapSequenceName} gap sequence: [${gaps.join(', ')}]`\n    });\n\n    // For each gap in the sequence\n    for (let g = 0; g < gaps.length; g++) {\n      const gap = gaps[g];\n\n      // Record current gap\n      if (options.visualizeGaps) {\n        this.recordState(result, {\n          type: 'gap-change',\n          gap: gap,\n          message: `Processing elements with gap ${gap}`\n        });\n      }\n\n      // Perform an insertion sort for elements at the current gap\n      for (let i = gap; i < n; i++) {\n        // Store current element\n        const temp = this.read(result, i);\n        let j = i;\n\n        // Optimization: Use binary search for finding insertion position for large gaps\n        if (options.optimizedComparisons && gap > 10) {\n          // Find insertion position with binary search\n          const insertPos = this.binarySearchInsertionPos(result, temp, i - gap, gap);\n\n          // Shift elements to the right\n          if (insertPos < i) {\n            for (let k = i; k >= insertPos + gap; k -= gap) {\n              this.write(result, k, this.read(result, k - gap));\n\n              // Record shift with large gap\n              if (options.enhancedInstrumentation) {\n                this.recordState(result, {\n                  type: 'gap-shift',\n                  source: k - gap,\n                  target: k,\n                  gap: gap,\n                  message: `Shifted element ${result[k]} from position ${k - gap} to ${k} (gap = ${gap})`\n                });\n              }\n            }\n\n            // Insert at correct position\n            this.write(result, insertPos, temp);\n\n            // Record insertion\n            this.recordState(result, {\n              type: 'gap-insert',\n              position: insertPos,\n              value: temp,\n              gap: gap,\n              message: `Inserted element ${temp} at position ${insertPos} (gap = ${gap})`\n            });\n          }\n        } else {\n          // Standard comparison-based gap insertion\n          while (j >= gap && this.compare(this.read(result, j - gap), temp) > 0) {\n            // Record comparison\n            if (options.enhancedInstrumentation) {\n              this.recordState(result, {\n                type: 'gap-comparison',\n                indices: [j - gap, i],\n                values: [result[j - gap], temp],\n                gap: gap,\n                message: `Comparing elements at positions ${j - gap} and ${i} with gap ${gap}`\n              });\n            }\n\n            // Shift element right by gap\n            this.write(result, j, this.read(result, j - gap));\n\n            // Record shift\n            if (options.enhancedInstrumentation) {\n              this.recordState(result, {\n                type: 'gap-shift',\n                source: j - gap,\n                target: j,\n                gap: gap,\n                message: `Shifted element ${result[j]} from position ${j - gap} to ${j} (gap = ${gap})`\n              });\n            }\n            j -= gap;\n          }\n\n          // Put temp in its correct position\n          if (j !== i) {\n            this.write(result, j, temp);\n\n            // Record insertion\n            this.recordState(result, {\n              type: 'gap-insert',\n              position: j,\n              value: temp,\n              gap: gap,\n              message: `Inserted element ${temp} at position ${j} (gap = ${gap})`\n            });\n          }\n        }\n      }\n\n      // Record completion of current gap phase\n      this.recordState(result, {\n        type: 'gap-complete',\n        gap: gap,\n        message: `Completed sorting with gap ${gap}`\n      });\n    }\n    this.setPhase('completed');\n    return result;\n  }\n\n  /**\n   * Find insertion position using binary search for a given gap\n   * This optimization reduces comparisons for large gaps\n   * \n   * @param {Array} array - Array to search\n   * @param {*} key - Value to insert\n   * @param {number} end - End index (inclusive)\n   * @param {number} gap - Current gap\n   * @returns {number} - Index where key should be inserted\n   */\n  binarySearchInsertionPos(array, key, end, gap) {\n    let start = 0;\n\n    // Binary search on the gap-separated subarray\n    while (start <= end) {\n      const mid = Math.floor((start + end) / 2);\n      const midIndex = mid * gap;\n      const cmp = this.compare(array[midIndex], key);\n      if (cmp < 0) {\n        start = mid + 1;\n      } else if (cmp > 0) {\n        end = mid - 1;\n      } else {\n        // Found an equal element, insert after it (stable)\n        return midIndex + gap;\n      }\n    }\n    return start * gap;\n  }\n\n  /**\n   * Generate Shell's original gap sequence: N/2, N/4, ..., 1\n   * \n   * @param {number} n - Array length\n   * @returns {Array} - Gap sequence\n   */\n  shellSequence(n) {\n    const gaps = [];\n    let gap = Math.floor(n / 2);\n    while (gap > 0) {\n      gaps.push(gap);\n      gap = Math.floor(gap / 2);\n    }\n    return gaps;\n  }\n\n  /**\n   * Generate Knuth's gap sequence: (3^k - 1)/2, where k ≥ 1 and (3^k - 1)/2 < N\n   * \n   * @param {number} n - Array length\n   * @returns {Array} - Gap sequence\n   */\n  knuthSequence(n) {\n    const gaps = [];\n    let gap = 1;\n\n    // Generate sequence in ascending order first\n    while (gap < n / 3) {\n      gap = 3 * gap + 1;\n    }\n\n    // Add in descending order\n    while (gap > 0) {\n      gaps.push(gap);\n      gap = Math.floor(gap / 3);\n    }\n    return gaps;\n  }\n\n  /**\n   * Generate Sedgewick's gap sequence\n   * 1, 8, 23, 77, 281, 1073, 4193, 16577, ...\n   * \n   * @param {number} n - Array length\n   * @returns {Array} - Gap sequence\n   */\n  sedgewickSequence(n) {\n    const gaps = [];\n    let k = 0;\n    let gap = 0;\n\n    // Generate sequence in ascending order first\n    do {\n      if (k % 2 === 0) {\n        gap = 9 * Math.pow(4, Math.floor(k / 2)) - 9 * Math.pow(2, Math.floor(k / 2)) + 1;\n      } else {\n        gap = Math.pow(4, Math.floor(k / 2 + 1)) - 3 * Math.pow(2, Math.floor(k / 2)) + 1;\n      }\n      if (gap < n) {\n        gaps.push(gap);\n      }\n      k++;\n    } while (gap < n);\n\n    // Reverse to get descending sequence\n    return gaps.reverse();\n  }\n\n  /**\n   * Generate Hibbard's gap sequence: 2^k - 1, where k ≥ 1\n   * 1, 3, 7, 15, 31, 63, 127, 255, ...\n   * \n   * @param {number} n - Array length\n   * @returns {Array} - Gap sequence\n   */\n  hibbardSequence(n) {\n    const gaps = [];\n    let k = 1;\n    let gap = Math.pow(2, k) - 1;\n\n    // Generate sequence in ascending order first\n    while (gap < n) {\n      gaps.push(gap);\n      k++;\n      gap = Math.pow(2, k) - 1;\n    }\n\n    // Reverse to get descending sequence\n    return gaps.reverse();\n  }\n\n  /**\n   * Generate Pratt's gap sequence: 2^i * 3^j, where i,j ≥ 0\n   * 1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 27, ...\n   * \n   * @param {number} n - Array length\n   * @returns {Array} - Gap sequence\n   */\n  prattSequence(n) {\n    const gaps = new Set([1]); // Use Set to avoid duplicates\n\n    // Generate all possible 2^i * 3^j combinations\n    for (let i = 0; i < 20; i++) {\n      const powI = Math.pow(2, i);\n      if (powI >= n) break;\n      for (let j = 0; j < 15; j++) {\n        const powJ = Math.pow(3, j);\n        const gap = powI * powJ;\n        if (gap < n) {\n          gaps.add(gap);\n        } else {\n          break;\n        }\n      }\n    }\n\n    // Convert to array, sort, and reverse\n    return Array.from(gaps).sort((a, b) => b - a);\n  }\n\n  /**\n   * Get the time and space complexity of Shell Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    let timeWorst;\n    let timeAverage;\n\n    // Complexity depends on gap sequence\n    switch (this.options.gapSequence.toLowerCase()) {\n      case 'shell':\n        timeWorst = 'O(n²)';\n        timeAverage = 'O(n²)';\n        break;\n      case 'hibbard':\n        timeWorst = 'O(n^(3/2))';\n        timeAverage = 'O(n^(5/4))';\n        break;\n      case 'sedgewick':\n        timeWorst = 'O(n^(4/3))';\n        timeAverage = 'O(n^(4/3))';\n        break;\n      case 'knuth':\n        timeWorst = 'O(n^(3/2))';\n        timeAverage = 'O(n^(3/2))';\n        break;\n      case 'pratt':\n        timeWorst = 'O(n log² n)';\n        timeAverage = 'O(n log² n)';\n        break;\n      default:\n        timeWorst = 'O(n²)';\n        timeAverage = 'O(n log² n)';\n    }\n    return {\n      time: {\n        best: 'O(n log n)',\n        average: timeAverage,\n        worst: timeWorst\n      },\n      space: {\n        best: 'O(1)',\n        average: 'O(1)',\n        worst: 'O(1)'\n      }\n    };\n  }\n\n  /**\n   * Whether Shell Sort is stable\n   * \n   * @returns {boolean} - False as Shell Sort is not stable\n   */\n  isStable() {\n    return false;\n  }\n\n  /**\n   * Whether Shell Sort is in-place\n   * \n   * @returns {boolean} - True as Shell Sort is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add shell sort specific information\n    info.optimization = {\n      gapSequence: this.options.gapSequence,\n      optimizedComparisons: this.options.optimizedComparisons,\n      visualizeGaps: this.options.visualizeGaps,\n      enhancedInstrumentation: this.options.enhancedInstrumentation\n    };\n    info.properties = {\n      comparisonBased: true,\n      stable: false,\n      inPlace: true,\n      adaptive: true,\n      online: false\n    };\n    info.suitable = {\n      smallArrays: true,\n      mediumArrays: true,\n      nearlySortedArrays: true,\n      largeArrays: false,\n      limitedMemory: true\n    };\n    info.gapSequences = {\n      shell: {\n        description: \"Original Shell sequence: N/2, N/4, ..., 1\",\n        complexity: \"O(n²)\",\n        formula: \"floor(n/2^k)\"\n      },\n      knuth: {\n        description: \"Knuth sequence: (3^k - 1)/2\",\n        complexity: \"O(n^(3/2))\",\n        formula: \"floor((3^k - 1) / 2)\"\n      },\n      sedgewick: {\n        description: \"Sedgewick's sequence: 1, 8, 23, 77, 281, 1073, ...\",\n        complexity: \"O(n^(4/3))\",\n        formula: \"4^k + 3*2^(k-1) + 1 or 9*4^k - 9*2^k + 1\"\n      },\n      hibbard: {\n        description: \"Hibbard's sequence: 2^k - 1\",\n        complexity: \"O(n^(3/2))\",\n        formula: \"2^k - 1\"\n      },\n      pratt: {\n        description: \"Pratt's sequence: 2^i * 3^j where i,j ≥ 0\",\n        complexity: \"O(n log² n)\",\n        formula: \"2^i * 3^j\"\n      }\n    };\n    info.advantages = [\"Improved version of insertion sort with better performance\", \"In-place algorithm with O(1) space complexity\", \"Simple implementation with few lines of code\", \"Excellent for medium-sized arrays (few hundred to few thousand elements)\", \"Adaptive to partially sorted arrays\", \"Performs well on arrays that are already partially sorted\"];\n    info.disadvantages = [\"Not stable (does not preserve order of equal elements)\", \"Complexity heavily depends on gap sequence chosen\", \"Performance not competitive with quicksort or mergesort for large arrays\", \"Gap sequence selection requires careful consideration\"];\n    info.historyAndContext = {\n      inventor: \"Donald Shell\",\n      year: 1959,\n      significance: \"First algorithm to improve insertion sort from O(n²) complexity\",\n      developmentContext: \"Shell published the algorithm in the Communications of the ACM, \" + \"proposing it as a significant improvement over existing sorting methods\"\n    };\n    return info;\n  }\n}\nexport default ShellSort;","map":{"version":3,"names":["Algorithm","ShellSort","constructor","options","gapSequence","optimizedComparisons","visualizeGaps","enhancedInstrumentation","gapGenerators","shellSequence","knuthSequence","sedgewickSequence","hibbardSequence","prattSequence","run","array","result","n","length","setPhase","gapSequenceName","gapGenerator","toLowerCase","sedgewick","gaps","recordState","type","sequence","message","join","g","gap","i","temp","read","j","insertPos","binarySearchInsertionPos","k","write","source","target","position","value","compare","indices","values","key","end","start","mid","Math","floor","midIndex","cmp","push","pow","reverse","Set","powI","powJ","add","Array","from","sort","a","b","getComplexity","timeWorst","timeAverage","time","best","average","worst","space","isStable","isInPlace","getInfo","info","optimization","properties","comparisonBased","stable","inPlace","adaptive","online","suitable","smallArrays","mediumArrays","nearlySortedArrays","largeArrays","limitedMemory","gapSequences","shell","description","complexity","formula","knuth","hibbard","pratt","advantages","disadvantages","historyAndContext","inventor","year","significance","developmentContext"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/comparison/shell.js"],"sourcesContent":["// src/algorithms/comparison/shell.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Shell Sort with multiple gap sequence strategies and optimizations.\n * \n * Shell Sort is a generalization of insertion sort that allows the exchange of items that are\n * far apart. The algorithm sorts elements that are distant from each other, gradually reducing\n * the gap between elements to be compared until the gap is 1 (regular insertion sort).\n * \n * This implementation includes multiple gap sequences and optimizations:\n * - Original Shell sequence: N/2, N/4, ..., 1\n * - Knuth sequence: (3^k - 1)/2, where k ≥ 1 and (3^k - 1)/2 < N\n * - Sedgewick sequence: 1, 8, 23, 77, 281, 1073, 4193, 16577, ...\n * - Hibbard sequence: 2^k - 1, where k ≥ 1\n * - Pratt sequence: 2^i * 3^j, where i,j ≥ 0\n * \n * Time Complexity:\n * - Best:    O(n log n) - Depends on gap sequence\n * - Average: O(n log² n) to O(n^(4/3)) depending on gap sequence\n * - Worst:   O(n²) for original Shell sequence, O(n^(3/2)) for Hibbard\n * \n * Space Complexity: O(1) - In-place sorting algorithm\n * \n * @class ShellSort\n * @extends Algorithm\n */\nclass ShellSort extends Algorithm {\n  /**\n   * Create a new ShellSort instance with configurable options\n   * \n   * @param {Object} options - Configuration options\n   * @param {string} [options.gapSequence='sedgewick'] - Gap sequence to use\n   * @param {boolean} [options.optimizedComparisons=true] - Use binary search for large gaps\n   * @param {boolean} [options.visualizeGaps=true] - Visualize gap sequences\n   * @param {boolean} [options.enhancedInstrumentation=true] - Use enhanced operation instrumentation\n   */\n  constructor(options = {}) {\n    super('Shell Sort', 'comparison', options);\n    \n    // Default options\n    this.options = {\n      gapSequence: 'sedgewick',     // Gap sequence strategy\n      optimizedComparisons: true,   // Use optimized comparisons\n      visualizeGaps: true,          // Visualize gap sequences\n      enhancedInstrumentation: true, // Enhanced operation instrumentation\n      ...options\n    };\n    \n    // Gap sequence generators\n    this.gapGenerators = {\n      'shell': this.shellSequence,\n      'knuth': this.knuthSequence,\n      'sedgewick': this.sedgewickSequence,\n      'hibbard': this.hibbardSequence,\n      'pratt': this.prattSequence\n    };\n  }\n  \n  /**\n   * Execute Shell Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('sorting');\n    \n    // Get gap sequence\n    const gapSequenceName = options.gapSequence || 'sedgewick';\n    const gapGenerator = this.gapGenerators[gapSequenceName.toLowerCase()] || this.gapGenerators.sedgewick;\n    \n    // Generate gaps\n    const gaps = gapGenerator(n);\n    \n    // Record the selected gap sequence\n    this.recordState(result, {\n      type: 'gap-sequence-selected',\n      sequence: gapSequenceName,\n      gaps: gaps,\n      message: `Using ${gapSequenceName} gap sequence: [${gaps.join(', ')}]`\n    });\n    \n    // For each gap in the sequence\n    for (let g = 0; g < gaps.length; g++) {\n      const gap = gaps[g];\n      \n      // Record current gap\n      if (options.visualizeGaps) {\n        this.recordState(result, {\n          type: 'gap-change',\n          gap: gap,\n          message: `Processing elements with gap ${gap}`\n        });\n      }\n      \n      // Perform an insertion sort for elements at the current gap\n      for (let i = gap; i < n; i++) {\n        // Store current element\n        const temp = this.read(result, i);\n        let j = i;\n        \n        // Optimization: Use binary search for finding insertion position for large gaps\n        if (options.optimizedComparisons && gap > 10) {\n          // Find insertion position with binary search\n          const insertPos = this.binarySearchInsertionPos(result, temp, i - gap, gap);\n          \n          // Shift elements to the right\n          if (insertPos < i) {\n            for (let k = i; k >= insertPos + gap; k -= gap) {\n              this.write(result, k, this.read(result, k - gap));\n              \n              // Record shift with large gap\n              if (options.enhancedInstrumentation) {\n                this.recordState(result, {\n                  type: 'gap-shift',\n                  source: k - gap,\n                  target: k,\n                  gap: gap,\n                  message: `Shifted element ${result[k]} from position ${k-gap} to ${k} (gap = ${gap})`\n                });\n              }\n            }\n            \n            // Insert at correct position\n            this.write(result, insertPos, temp);\n            \n            // Record insertion\n            this.recordState(result, {\n              type: 'gap-insert',\n              position: insertPos,\n              value: temp,\n              gap: gap,\n              message: `Inserted element ${temp} at position ${insertPos} (gap = ${gap})`\n            });\n          }\n        } else {\n          // Standard comparison-based gap insertion\n          while (j >= gap && this.compare(this.read(result, j - gap), temp) > 0) {\n            // Record comparison\n            if (options.enhancedInstrumentation) {\n              this.recordState(result, {\n                type: 'gap-comparison',\n                indices: [j - gap, i],\n                values: [result[j - gap], temp],\n                gap: gap,\n                message: `Comparing elements at positions ${j-gap} and ${i} with gap ${gap}`\n              });\n            }\n            \n            // Shift element right by gap\n            this.write(result, j, this.read(result, j - gap));\n            \n            // Record shift\n            if (options.enhancedInstrumentation) {\n              this.recordState(result, {\n                type: 'gap-shift',\n                source: j - gap,\n                target: j,\n                gap: gap,\n                message: `Shifted element ${result[j]} from position ${j-gap} to ${j} (gap = ${gap})`\n              });\n            }\n            \n            j -= gap;\n          }\n          \n          // Put temp in its correct position\n          if (j !== i) {\n            this.write(result, j, temp);\n            \n            // Record insertion\n            this.recordState(result, {\n              type: 'gap-insert',\n              position: j,\n              value: temp,\n              gap: gap,\n              message: `Inserted element ${temp} at position ${j} (gap = ${gap})`\n            });\n          }\n        }\n      }\n      \n      // Record completion of current gap phase\n      this.recordState(result, {\n        type: 'gap-complete',\n        gap: gap,\n        message: `Completed sorting with gap ${gap}`\n      });\n    }\n    \n    this.setPhase('completed');\n    return result;\n  }\n  \n  /**\n   * Find insertion position using binary search for a given gap\n   * This optimization reduces comparisons for large gaps\n   * \n   * @param {Array} array - Array to search\n   * @param {*} key - Value to insert\n   * @param {number} end - End index (inclusive)\n   * @param {number} gap - Current gap\n   * @returns {number} - Index where key should be inserted\n   */\n  binarySearchInsertionPos(array, key, end, gap) {\n    let start = 0;\n    \n    // Binary search on the gap-separated subarray\n    while (start <= end) {\n      const mid = Math.floor((start + end) / 2);\n      const midIndex = mid * gap;\n      \n      const cmp = this.compare(array[midIndex], key);\n      \n      if (cmp < 0) {\n        start = mid + 1;\n      } else if (cmp > 0) {\n        end = mid - 1;\n      } else {\n        // Found an equal element, insert after it (stable)\n        return midIndex + gap;\n      }\n    }\n    \n    return start * gap;\n  }\n  \n  /**\n   * Generate Shell's original gap sequence: N/2, N/4, ..., 1\n   * \n   * @param {number} n - Array length\n   * @returns {Array} - Gap sequence\n   */\n  shellSequence(n) {\n    const gaps = [];\n    let gap = Math.floor(n / 2);\n    \n    while (gap > 0) {\n      gaps.push(gap);\n      gap = Math.floor(gap / 2);\n    }\n    \n    return gaps;\n  }\n  \n  /**\n   * Generate Knuth's gap sequence: (3^k - 1)/2, where k ≥ 1 and (3^k - 1)/2 < N\n   * \n   * @param {number} n - Array length\n   * @returns {Array} - Gap sequence\n   */\n  knuthSequence(n) {\n    const gaps = [];\n    let gap = 1;\n    \n    // Generate sequence in ascending order first\n    while (gap < n / 3) {\n      gap = 3 * gap + 1;\n    }\n    \n    // Add in descending order\n    while (gap > 0) {\n      gaps.push(gap);\n      gap = Math.floor(gap / 3);\n    }\n    \n    return gaps;\n  }\n  \n  /**\n   * Generate Sedgewick's gap sequence\n   * 1, 8, 23, 77, 281, 1073, 4193, 16577, ...\n   * \n   * @param {number} n - Array length\n   * @returns {Array} - Gap sequence\n   */\n  sedgewickSequence(n) {\n    const gaps = [];\n    let k = 0;\n    let gap = 0;\n    \n    // Generate sequence in ascending order first\n    do {\n      if (k % 2 === 0) {\n        gap = 9 * Math.pow(4, Math.floor(k / 2)) - 9 * Math.pow(2, Math.floor(k / 2)) + 1;\n      } else {\n        gap = Math.pow(4, Math.floor(k / 2 + 1)) - 3 * Math.pow(2, Math.floor(k / 2)) + 1;\n      }\n      \n      if (gap < n) {\n        gaps.push(gap);\n      }\n      \n      k++;\n    } while (gap < n);\n    \n    // Reverse to get descending sequence\n    return gaps.reverse();\n  }\n  \n  /**\n   * Generate Hibbard's gap sequence: 2^k - 1, where k ≥ 1\n   * 1, 3, 7, 15, 31, 63, 127, 255, ...\n   * \n   * @param {number} n - Array length\n   * @returns {Array} - Gap sequence\n   */\n  hibbardSequence(n) {\n    const gaps = [];\n    let k = 1;\n    let gap = Math.pow(2, k) - 1;\n    \n    // Generate sequence in ascending order first\n    while (gap < n) {\n      gaps.push(gap);\n      k++;\n      gap = Math.pow(2, k) - 1;\n    }\n    \n    // Reverse to get descending sequence\n    return gaps.reverse();\n  }\n  \n  /**\n   * Generate Pratt's gap sequence: 2^i * 3^j, where i,j ≥ 0\n   * 1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 27, ...\n   * \n   * @param {number} n - Array length\n   * @returns {Array} - Gap sequence\n   */\n  prattSequence(n) {\n    const gaps = new Set([1]); // Use Set to avoid duplicates\n    \n    // Generate all possible 2^i * 3^j combinations\n    for (let i = 0; i < 20; i++) {\n      const powI = Math.pow(2, i);\n      if (powI >= n) break;\n      \n      for (let j = 0; j < 15; j++) {\n        const powJ = Math.pow(3, j);\n        const gap = powI * powJ;\n        \n        if (gap < n) {\n          gaps.add(gap);\n        } else {\n          break;\n        }\n      }\n    }\n    \n    // Convert to array, sort, and reverse\n    return Array.from(gaps).sort((a, b) => b - a);\n  }\n  \n  /**\n   * Get the time and space complexity of Shell Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    let timeWorst;\n    let timeAverage;\n    \n    // Complexity depends on gap sequence\n    switch (this.options.gapSequence.toLowerCase()) {\n      case 'shell':\n        timeWorst = 'O(n²)';\n        timeAverage = 'O(n²)';\n        break;\n      case 'hibbard':\n        timeWorst = 'O(n^(3/2))';\n        timeAverage = 'O(n^(5/4))';\n        break;\n      case 'sedgewick':\n        timeWorst = 'O(n^(4/3))';\n        timeAverage = 'O(n^(4/3))';\n        break;\n      case 'knuth':\n        timeWorst = 'O(n^(3/2))';\n        timeAverage = 'O(n^(3/2))';\n        break;\n      case 'pratt':\n        timeWorst = 'O(n log² n)';\n        timeAverage = 'O(n log² n)';\n        break;\n      default:\n        timeWorst = 'O(n²)';\n        timeAverage = 'O(n log² n)';\n    }\n    \n    return {\n      time: {\n        best: 'O(n log n)',\n        average: timeAverage,\n        worst: timeWorst\n      },\n      space: {\n        best: 'O(1)',\n        average: 'O(1)',\n        worst: 'O(1)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Shell Sort is stable\n   * \n   * @returns {boolean} - False as Shell Sort is not stable\n   */\n  isStable() {\n    return false;\n  }\n  \n  /**\n   * Whether Shell Sort is in-place\n   * \n   * @returns {boolean} - True as Shell Sort is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add shell sort specific information\n    info.optimization = {\n      gapSequence: this.options.gapSequence,\n      optimizedComparisons: this.options.optimizedComparisons,\n      visualizeGaps: this.options.visualizeGaps,\n      enhancedInstrumentation: this.options.enhancedInstrumentation\n    };\n    \n    info.properties = {\n      comparisonBased: true,\n      stable: false,\n      inPlace: true,\n      adaptive: true,\n      online: false\n    };\n    \n    info.suitable = {\n      smallArrays: true,\n      mediumArrays: true,\n      nearlySortedArrays: true,\n      largeArrays: false,\n      limitedMemory: true\n    };\n    \n    info.gapSequences = {\n      shell: {\n        description: \"Original Shell sequence: N/2, N/4, ..., 1\",\n        complexity: \"O(n²)\",\n        formula: \"floor(n/2^k)\"\n      },\n      knuth: {\n        description: \"Knuth sequence: (3^k - 1)/2\",\n        complexity: \"O(n^(3/2))\",\n        formula: \"floor((3^k - 1) / 2)\"\n      },\n      sedgewick: {\n        description: \"Sedgewick's sequence: 1, 8, 23, 77, 281, 1073, ...\",\n        complexity: \"O(n^(4/3))\",\n        formula: \"4^k + 3*2^(k-1) + 1 or 9*4^k - 9*2^k + 1\"\n      },\n      hibbard: {\n        description: \"Hibbard's sequence: 2^k - 1\",\n        complexity: \"O(n^(3/2))\",\n        formula: \"2^k - 1\"\n      },\n      pratt: {\n        description: \"Pratt's sequence: 2^i * 3^j where i,j ≥ 0\",\n        complexity: \"O(n log² n)\",\n        formula: \"2^i * 3^j\"\n      }\n    };\n    \n    info.advantages = [\n      \"Improved version of insertion sort with better performance\",\n      \"In-place algorithm with O(1) space complexity\",\n      \"Simple implementation with few lines of code\",\n      \"Excellent for medium-sized arrays (few hundred to few thousand elements)\",\n      \"Adaptive to partially sorted arrays\",\n      \"Performs well on arrays that are already partially sorted\"\n    ];\n    \n    info.disadvantages = [\n      \"Not stable (does not preserve order of equal elements)\",\n      \"Complexity heavily depends on gap sequence chosen\",\n      \"Performance not competitive with quicksort or mergesort for large arrays\",\n      \"Gap sequence selection requires careful consideration\"\n    ];\n    \n    info.historyAndContext = {\n      inventor: \"Donald Shell\",\n      year: 1959,\n      significance: \"First algorithm to improve insertion sort from O(n²) complexity\",\n      developmentContext: \"Shell published the algorithm in the Communications of the ACM, \" +\n        \"proposing it as a significant improvement over existing sorting methods\"\n    };\n    \n    return info;\n  }\n}\n\nexport default ShellSort;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}