{"ast":null,"code":"// src/algorithms/selection/quick-select.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Quick Select algorithm with multiple optimization strategies.\n * \n * Quick Select is an efficient selection algorithm to find the k-th smallest element\n * in an unordered list. It's based on the partitioning method from QuickSort but\n * only recursively processes one side of the partition.\n * \n * This implementation includes optimizations:\n * - Multiple pivot selection strategies\n * - Small array optimization with insertion sort\n * - Deterministic selection with median-of-medians option\n * - Detailed visualization of partitioning process\n * \n * Average-case time complexity: O(n)\n * Worst-case time complexity: O(n²) with basic implementation, O(n) with median-of-medians\n * \n * @class QuickSelect\n * @extends Algorithm\n */\nclass QuickSelect extends Algorithm {\n  /**\n   * Create a new QuickSelect instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {string} [options.pivotStrategy='median-of-three'] - Strategy for selecting pivot\n   * @param {boolean} [options.useMedianOfMedians=false] - Use deterministic median-of-medians approach\n   * @param {number} [options.insertionThreshold=10] - Threshold for switching to insertion sort\n   * @param {boolean} [options.visualizePartitioning=true] - Show detailed partitioning steps\n   */\n  constructor(options = {}) {\n    super('Quick Select', 'selection', options);\n\n    // Default options\n    this.options = {\n      pivotStrategy: 'median-of-three',\n      // Strategy for selecting pivot\n      useMedianOfMedians: false,\n      // Use deterministic median-of-medians approach\n      insertionThreshold: 10,\n      // Threshold for switching to insertion sort\n      visualizePartitioning: true,\n      // Show detailed partitioning steps\n      ...options\n    };\n  }\n\n  /**\n   * Execute Quick Select to find the k-th smallest element\n   * \n   * @param {Array} array - Input array\n   * @param {Object} options - Runtime options including k (element to select)\n   * @returns {*} - The k-th smallest element\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n\n    // Get k (1-based index of element to find)\n    const k = options.k || 1;\n\n    // Validate k\n    if (k < 1 || k > n) {\n      throw new Error(`Invalid value of k: ${k}. Must be between 1 and ${n}`);\n    }\n\n    // Convert to 0-based index\n    const index = k - 1;\n    this.setPhase('selection');\n\n    // Find the k-th element\n    const kthElement = this.options.useMedianOfMedians ? this.medianOfMediansSelect(result, 0, n - 1, index, options) : this.quickSelect(result, 0, n - 1, index, options);\n    this.setPhase('completed');\n\n    // For visualization purposes, mark the k-th element\n    this.recordState(result, {\n      type: 'final-selection',\n      selectedIndex: index,\n      selectedValue: kthElement,\n      message: `Found the ${k}-th smallest element: ${kthElement}`\n    });\n    return kthElement;\n  }\n\n  /**\n   * Standard Quick Select implementation\n   * \n   * @param {Array} array - Array to search in\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {number} k - Index of element to find (0-based)\n   * @param {Object} options - Runtime options\n   * @returns {*} - The k-th element\n   */\n  quickSelect(array, low, high, k, options) {\n    // Record the current state\n    this.recordState(array, {\n      type: 'selection-step',\n      range: [low, high],\n      target: k,\n      message: `Looking for element at position ${k} in range [${low}...${high}]`\n    });\n\n    // Base case: small array, find element by sorting\n    if (high - low < this.options.insertionThreshold) {\n      this.insertionSort(array, low, high);\n      return array[k];\n    }\n\n    // Select pivot using chosen strategy\n    const pivotIdx = this.selectPivot(array, low, high, this.options.pivotStrategy);\n\n    // Record pivot selection\n    this.recordState(array, {\n      type: 'pivot-selection',\n      pivot: pivotIdx,\n      pivotValue: array[pivotIdx],\n      message: `Selected pivot at index ${pivotIdx} with value ${array[pivotIdx]}`\n    });\n\n    // Partition the array and get the final position of the pivot\n    const pivotPos = this.partition(array, low, high, pivotIdx, options);\n\n    // Record partition completion\n    this.recordState(array, {\n      type: 'partition-complete',\n      pivot: pivotPos,\n      pivotValue: array[pivotPos],\n      message: `Partition complete. Pivot value ${array[pivotPos]} is now at position ${pivotPos}`\n    });\n\n    // If pivot is at k, we found our element\n    if (pivotPos === k) {\n      return array[pivotPos];\n    }\n\n    // Recursively search in the appropriate partition\n    if (pivotPos > k) {\n      // The k-th element is in the left partition\n      return this.quickSelect(array, low, pivotPos - 1, k, options);\n    } else {\n      // The k-th element is in the right partition\n      return this.quickSelect(array, pivotPos + 1, high, k, options);\n    }\n  }\n\n  /**\n   * Deterministic median-of-medians selection algorithm\n   * Guarantees O(n) worst-case time complexity\n   * \n   * @param {Array} array - Array to search in\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {number} k - Index of element to find (0-based)\n   * @param {Object} options - Runtime options\n   * @returns {*} - The k-th element\n   */\n  medianOfMediansSelect(array, low, high, k, options) {\n    const size = high - low + 1;\n\n    // Base case: small array, use insertion sort\n    if (size <= this.options.insertionThreshold) {\n      this.insertionSort(array, low, high);\n      return array[k];\n    }\n\n    // Record the current state\n    this.recordState(array, {\n      type: 'median-step',\n      range: [low, high],\n      target: k,\n      message: `Using median-of-medians to find element at position ${k} in range [${low}...${high}]`\n    });\n\n    // Divide array into groups of 5 and find median of each group\n    const numGroups = Math.ceil(size / 5);\n    const medians = [];\n    for (let i = 0; i < numGroups; i++) {\n      const groupStart = low + i * 5;\n      const groupEnd = Math.min(groupStart + 4, high);\n\n      // Find median of this group\n      this.insertionSort(array, groupStart, groupEnd);\n      const medianIdx = groupStart + Math.floor((groupEnd - groupStart) / 2);\n      medians.push(array[medianIdx]);\n\n      // Record group median identification\n      if (this.options.visualizePartitioning) {\n        this.recordState(array, {\n          type: 'group-median',\n          group: [groupStart, groupEnd],\n          median: medianIdx,\n          medianValue: array[medianIdx],\n          message: `Found median of group [${groupStart}...${groupEnd}]: ${array[medianIdx]}`\n        });\n      }\n    }\n\n    // Find the median of medians recursively\n    const medianOfMedians = medians.length === 1 ? medians[0] : this.medianOfMediansSelect(medians, 0, medians.length - 1, Math.floor(medians.length / 2), options);\n\n    // Record median of medians\n    this.recordState(array, {\n      type: 'median-of-medians',\n      medianValue: medianOfMedians,\n      message: `Found median of medians: ${medianOfMedians}`\n    });\n\n    // Find the index of the median of medians in the original array\n    let pivotIdx = low;\n    for (let i = low; i <= high; i++) {\n      if (array[i] === medianOfMedians) {\n        pivotIdx = i;\n        break;\n      }\n    }\n\n    // Partition around the median of medians\n    const pivotPos = this.partition(array, low, high, pivotIdx, options);\n\n    // Record partition completion\n    this.recordState(array, {\n      type: 'partition-complete',\n      pivot: pivotPos,\n      pivotValue: array[pivotPos],\n      message: `Partition complete. Pivot value ${array[pivotPos]} is now at position ${pivotPos}`\n    });\n\n    // If pivot is at k, we found our element\n    if (pivotPos === k) {\n      return array[pivotPos];\n    }\n\n    // Recursively search in the appropriate partition\n    if (pivotPos > k) {\n      // The k-th element is in the left partition\n      return this.medianOfMediansSelect(array, low, pivotPos - 1, k, options);\n    } else {\n      // The k-th element is in the right partition\n      return this.medianOfMediansSelect(array, pivotPos + 1, high, k, options);\n    }\n  }\n\n  /**\n   * Partition the array around a pivot\n   * \n   * @param {Array} array - Array to partition\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {number} pivotIdx - Index of the pivot element\n   * @param {Object} options - Runtime options\n   * @returns {number} - Final position of the pivot\n   */\n  partition(array, low, high, pivotIdx, options) {\n    // Move pivot to the end temporarily\n    this.swap(array, pivotIdx, high);\n\n    // Record pivot movement\n    if (this.options.visualizePartitioning) {\n      this.recordState(array, {\n        type: 'pivot-move',\n        from: pivotIdx,\n        to: high,\n        message: `Moving pivot from index ${pivotIdx} to ${high}`\n      });\n    }\n\n    // Get pivot value\n    const pivot = this.read(array, high);\n\n    // Partition the array\n    let i = low; // Position for elements less than pivot\n\n    for (let j = low; j < high; j++) {\n      // Compare current element with pivot\n      if (this.compare(this.read(array, j), pivot) < 0) {\n        // Element is less than pivot, move to left partition\n        this.swap(array, i, j);\n\n        // Record the swap for visualization\n        if (this.options.visualizePartitioning) {\n          this.recordState(array, {\n            type: 'partition-swap',\n            indices: [i, j],\n            message: `Moving element ${array[i]} (< pivot) to left partition`\n          });\n        }\n        i++;\n      } else {\n        // Element stays in right partition\n        if (this.options.visualizePartitioning) {\n          this.recordState(array, {\n            type: 'partition-compare',\n            index: j,\n            message: `Element ${array[j]} ≥ pivot, stays in right partition`\n          });\n        }\n      }\n    }\n\n    // Move pivot to its final position\n    this.swap(array, i, high);\n\n    // Record final pivot position\n    this.recordState(array, {\n      type: 'pivot-final',\n      index: i,\n      message: `Placed pivot ${array[i]} at its final position ${i}`\n    });\n    return i;\n  }\n\n  /**\n   * Select a pivot index based on the specified strategy\n   * \n   * @param {Array} array - The array\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {string} strategy - Pivot selection strategy\n   * @returns {number} - Index of the selected pivot\n   */\n  selectPivot(array, low, high, strategy) {\n    if (low === high) {\n      return low;\n    }\n    switch (strategy) {\n      case 'first':\n        return low;\n      case 'last':\n        return high;\n      case 'middle':\n        return Math.floor((low + high) / 2);\n      case 'random':\n        return low + Math.floor(Math.random() * (high - low + 1));\n      case 'median-of-three':\n        // Select median of first, middle, and last elements\n        const mid = Math.floor((low + high) / 2);\n\n        // Find median directly\n        if (this.compare(array[low], array[mid]) > 0) {\n          if (this.compare(array[low], array[high]) <= 0) {\n            return low;\n          } else if (this.compare(array[mid], array[high]) > 0) {\n            return mid;\n          } else {\n            return high;\n          }\n        } else {\n          if (this.compare(array[mid], array[high]) <= 0) {\n            return mid;\n          } else if (this.compare(array[low], array[high]) > 0) {\n            return low;\n          } else {\n            return high;\n          }\n        }\n      default:\n        console.warn(`Unknown pivot strategy: ${strategy}, using median-of-three`);\n        return this.selectPivot(array, low, high, 'median-of-three');\n    }\n  }\n\n  /**\n   * Insertion sort for small subarrays\n   * \n   * @param {Array} array - The array to sort\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   */\n  insertionSort(array, low, high) {\n    for (let i = low + 1; i <= high; i++) {\n      const key = this.read(array, i);\n      let j = i - 1;\n      while (j >= low && this.compare(this.read(array, j), key) > 0) {\n        this.write(array, j + 1, this.read(array, j));\n        j--;\n      }\n      if (j + 1 !== i) {\n        this.write(array, j + 1, key);\n      }\n    }\n  }\n\n  /**\n   * Get the time and space complexity of Quick Select\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    const worstTime = this.options.useMedianOfMedians ? 'O(n)' : 'O(n²)';\n    return {\n      time: {\n        best: 'O(n)',\n        average: 'O(n)',\n        worst: worstTime\n      },\n      space: {\n        best: 'O(log n)',\n        average: 'O(log n)',\n        worst: 'O(n)'\n      }\n    };\n  }\n\n  /**\n   * Whether the algorithm is stable\n   * \n   * @returns {boolean} - Always false as QuickSelect isn't stable\n   */\n  isStable() {\n    return false;\n  }\n\n  /**\n   * Whether the algorithm is in-place\n   * \n   * @returns {boolean} - True as QuickSelect is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add QuickSelect specific information\n    info.optimization = {\n      pivotStrategy: this.options.pivotStrategy,\n      useMedianOfMedians: this.options.useMedianOfMedians,\n      insertionThreshold: this.options.insertionThreshold,\n      visualizePartitioning: this.options.visualizePartitioning\n    };\n    info.properties = {\n      selectionAlgorithm: true,\n      inPlace: true,\n      stable: false,\n      deterministic: this.options.useMedianOfMedians\n    };\n    info.applications = ['Finding k-th smallest/largest element', 'Computing medians and quantiles', 'Order statistics', 'Nearest neighbor search', 'Data stream processing'];\n    info.variants = ['Basic Quick Select', 'Median-of-Medians (BFPRT algorithm)', 'Introselect (hybrid algorithm)', 'Dual-pivot Quick Select'];\n    info.advantages = ['Average O(n) time complexity', 'In-place algorithm with low memory usage', 'Can be made deterministic with median-of-medians approach', 'Efficient for finding order statistics', 'Works well with virtual memory systems'];\n    info.disadvantages = ['Not stable (doesn\\'t preserve relative order of equal elements)', 'Basic version has O(n²) worst-case time complexity', 'Median-of-medians variant has higher overhead', 'Randomized version lacks guarantees for critical applications'];\n    return info;\n  }\n}\nexport default QuickSelect;","map":{"version":3,"names":["Algorithm","QuickSelect","constructor","options","pivotStrategy","useMedianOfMedians","insertionThreshold","visualizePartitioning","run","array","result","n","length","k","Error","index","setPhase","kthElement","medianOfMediansSelect","quickSelect","recordState","type","selectedIndex","selectedValue","message","low","high","range","target","insertionSort","pivotIdx","selectPivot","pivot","pivotValue","pivotPos","partition","size","numGroups","Math","ceil","medians","i","groupStart","groupEnd","min","medianIdx","floor","push","group","median","medianValue","medianOfMedians","swap","from","to","read","j","compare","indices","strategy","random","mid","console","warn","key","write","getComplexity","worstTime","time","best","average","worst","space","isStable","isInPlace","getInfo","info","optimization","properties","selectionAlgorithm","inPlace","stable","deterministic","applications","variants","advantages","disadvantages"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/selection/quick-select.js"],"sourcesContent":["// src/algorithms/selection/quick-select.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Quick Select algorithm with multiple optimization strategies.\n * \n * Quick Select is an efficient selection algorithm to find the k-th smallest element\n * in an unordered list. It's based on the partitioning method from QuickSort but\n * only recursively processes one side of the partition.\n * \n * This implementation includes optimizations:\n * - Multiple pivot selection strategies\n * - Small array optimization with insertion sort\n * - Deterministic selection with median-of-medians option\n * - Detailed visualization of partitioning process\n * \n * Average-case time complexity: O(n)\n * Worst-case time complexity: O(n²) with basic implementation, O(n) with median-of-medians\n * \n * @class QuickSelect\n * @extends Algorithm\n */\nclass QuickSelect extends Algorithm {\n  /**\n   * Create a new QuickSelect instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {string} [options.pivotStrategy='median-of-three'] - Strategy for selecting pivot\n   * @param {boolean} [options.useMedianOfMedians=false] - Use deterministic median-of-medians approach\n   * @param {number} [options.insertionThreshold=10] - Threshold for switching to insertion sort\n   * @param {boolean} [options.visualizePartitioning=true] - Show detailed partitioning steps\n   */\n  constructor(options = {}) {\n    super('Quick Select', 'selection', options);\n    \n    // Default options\n    this.options = {\n      pivotStrategy: 'median-of-three',  // Strategy for selecting pivot\n      useMedianOfMedians: false,         // Use deterministic median-of-medians approach\n      insertionThreshold: 10,            // Threshold for switching to insertion sort\n      visualizePartitioning: true,       // Show detailed partitioning steps\n      ...options\n    };\n  }\n  \n  /**\n   * Execute Quick Select to find the k-th smallest element\n   * \n   * @param {Array} array - Input array\n   * @param {Object} options - Runtime options including k (element to select)\n   * @returns {*} - The k-th smallest element\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n    \n    // Get k (1-based index of element to find)\n    const k = options.k || 1;\n    \n    // Validate k\n    if (k < 1 || k > n) {\n      throw new Error(`Invalid value of k: ${k}. Must be between 1 and ${n}`);\n    }\n    \n    // Convert to 0-based index\n    const index = k - 1;\n    \n    this.setPhase('selection');\n    \n    // Find the k-th element\n    const kthElement = this.options.useMedianOfMedians \n      ? this.medianOfMediansSelect(result, 0, n - 1, index, options)\n      : this.quickSelect(result, 0, n - 1, index, options);\n    \n    this.setPhase('completed');\n    \n    // For visualization purposes, mark the k-th element\n    this.recordState(result, {\n      type: 'final-selection',\n      selectedIndex: index,\n      selectedValue: kthElement,\n      message: `Found the ${k}-th smallest element: ${kthElement}`\n    });\n    \n    return kthElement;\n  }\n  \n  /**\n   * Standard Quick Select implementation\n   * \n   * @param {Array} array - Array to search in\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {number} k - Index of element to find (0-based)\n   * @param {Object} options - Runtime options\n   * @returns {*} - The k-th element\n   */\n  quickSelect(array, low, high, k, options) {\n    // Record the current state\n    this.recordState(array, {\n      type: 'selection-step',\n      range: [low, high],\n      target: k,\n      message: `Looking for element at position ${k} in range [${low}...${high}]`\n    });\n    \n    // Base case: small array, find element by sorting\n    if (high - low < this.options.insertionThreshold) {\n      this.insertionSort(array, low, high);\n      return array[k];\n    }\n    \n    // Select pivot using chosen strategy\n    const pivotIdx = this.selectPivot(array, low, high, this.options.pivotStrategy);\n    \n    // Record pivot selection\n    this.recordState(array, {\n      type: 'pivot-selection',\n      pivot: pivotIdx,\n      pivotValue: array[pivotIdx],\n      message: `Selected pivot at index ${pivotIdx} with value ${array[pivotIdx]}`\n    });\n    \n    // Partition the array and get the final position of the pivot\n    const pivotPos = this.partition(array, low, high, pivotIdx, options);\n    \n    // Record partition completion\n    this.recordState(array, {\n      type: 'partition-complete',\n      pivot: pivotPos,\n      pivotValue: array[pivotPos],\n      message: `Partition complete. Pivot value ${array[pivotPos]} is now at position ${pivotPos}`\n    });\n    \n    // If pivot is at k, we found our element\n    if (pivotPos === k) {\n      return array[pivotPos];\n    }\n    \n    // Recursively search in the appropriate partition\n    if (pivotPos > k) {\n      // The k-th element is in the left partition\n      return this.quickSelect(array, low, pivotPos - 1, k, options);\n    } else {\n      // The k-th element is in the right partition\n      return this.quickSelect(array, pivotPos + 1, high, k, options);\n    }\n  }\n  \n  /**\n   * Deterministic median-of-medians selection algorithm\n   * Guarantees O(n) worst-case time complexity\n   * \n   * @param {Array} array - Array to search in\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {number} k - Index of element to find (0-based)\n   * @param {Object} options - Runtime options\n   * @returns {*} - The k-th element\n   */\n  medianOfMediansSelect(array, low, high, k, options) {\n    const size = high - low + 1;\n    \n    // Base case: small array, use insertion sort\n    if (size <= this.options.insertionThreshold) {\n      this.insertionSort(array, low, high);\n      return array[k];\n    }\n    \n    // Record the current state\n    this.recordState(array, {\n      type: 'median-step',\n      range: [low, high],\n      target: k,\n      message: `Using median-of-medians to find element at position ${k} in range [${low}...${high}]`\n    });\n    \n    // Divide array into groups of 5 and find median of each group\n    const numGroups = Math.ceil(size / 5);\n    const medians = [];\n    \n    for (let i = 0; i < numGroups; i++) {\n      const groupStart = low + i * 5;\n      const groupEnd = Math.min(groupStart + 4, high);\n      \n      // Find median of this group\n      this.insertionSort(array, groupStart, groupEnd);\n      const medianIdx = groupStart + Math.floor((groupEnd - groupStart) / 2);\n      medians.push(array[medianIdx]);\n      \n      // Record group median identification\n      if (this.options.visualizePartitioning) {\n        this.recordState(array, {\n          type: 'group-median',\n          group: [groupStart, groupEnd],\n          median: medianIdx,\n          medianValue: array[medianIdx],\n          message: `Found median of group [${groupStart}...${groupEnd}]: ${array[medianIdx]}`\n        });\n      }\n    }\n    \n    // Find the median of medians recursively\n    const medianOfMedians = medians.length === 1 \n      ? medians[0] \n      : this.medianOfMediansSelect(medians, 0, medians.length - 1, Math.floor(medians.length / 2), options);\n    \n    // Record median of medians\n    this.recordState(array, {\n      type: 'median-of-medians',\n      medianValue: medianOfMedians,\n      message: `Found median of medians: ${medianOfMedians}`\n    });\n    \n    // Find the index of the median of medians in the original array\n    let pivotIdx = low;\n    for (let i = low; i <= high; i++) {\n      if (array[i] === medianOfMedians) {\n        pivotIdx = i;\n        break;\n      }\n    }\n    \n    // Partition around the median of medians\n    const pivotPos = this.partition(array, low, high, pivotIdx, options);\n    \n    // Record partition completion\n    this.recordState(array, {\n      type: 'partition-complete',\n      pivot: pivotPos,\n      pivotValue: array[pivotPos],\n      message: `Partition complete. Pivot value ${array[pivotPos]} is now at position ${pivotPos}`\n    });\n    \n    // If pivot is at k, we found our element\n    if (pivotPos === k) {\n      return array[pivotPos];\n    }\n    \n    // Recursively search in the appropriate partition\n    if (pivotPos > k) {\n      // The k-th element is in the left partition\n      return this.medianOfMediansSelect(array, low, pivotPos - 1, k, options);\n    } else {\n      // The k-th element is in the right partition\n      return this.medianOfMediansSelect(array, pivotPos + 1, high, k, options);\n    }\n  }\n  \n  /**\n   * Partition the array around a pivot\n   * \n   * @param {Array} array - Array to partition\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {number} pivotIdx - Index of the pivot element\n   * @param {Object} options - Runtime options\n   * @returns {number} - Final position of the pivot\n   */\n  partition(array, low, high, pivotIdx, options) {\n    // Move pivot to the end temporarily\n    this.swap(array, pivotIdx, high);\n    \n    // Record pivot movement\n    if (this.options.visualizePartitioning) {\n      this.recordState(array, {\n        type: 'pivot-move',\n        from: pivotIdx,\n        to: high,\n        message: `Moving pivot from index ${pivotIdx} to ${high}`\n      });\n    }\n    \n    // Get pivot value\n    const pivot = this.read(array, high);\n    \n    // Partition the array\n    let i = low; // Position for elements less than pivot\n    \n    for (let j = low; j < high; j++) {\n      // Compare current element with pivot\n      if (this.compare(this.read(array, j), pivot) < 0) {\n        // Element is less than pivot, move to left partition\n        this.swap(array, i, j);\n        \n        // Record the swap for visualization\n        if (this.options.visualizePartitioning) {\n          this.recordState(array, {\n            type: 'partition-swap',\n            indices: [i, j],\n            message: `Moving element ${array[i]} (< pivot) to left partition`\n          });\n        }\n        \n        i++;\n      } else {\n        // Element stays in right partition\n        if (this.options.visualizePartitioning) {\n          this.recordState(array, {\n            type: 'partition-compare',\n            index: j,\n            message: `Element ${array[j]} ≥ pivot, stays in right partition`\n          });\n        }\n      }\n    }\n    \n    // Move pivot to its final position\n    this.swap(array, i, high);\n    \n    // Record final pivot position\n    this.recordState(array, {\n      type: 'pivot-final',\n      index: i,\n      message: `Placed pivot ${array[i]} at its final position ${i}`\n    });\n    \n    return i;\n  }\n  \n  /**\n   * Select a pivot index based on the specified strategy\n   * \n   * @param {Array} array - The array\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {string} strategy - Pivot selection strategy\n   * @returns {number} - Index of the selected pivot\n   */\n  selectPivot(array, low, high, strategy) {\n    if (low === high) {\n      return low;\n    }\n    \n    switch (strategy) {\n      case 'first':\n        return low;\n      \n      case 'last':\n        return high;\n      \n      case 'middle':\n        return Math.floor((low + high) / 2);\n      \n      case 'random':\n        return low + Math.floor(Math.random() * (high - low + 1));\n      \n      case 'median-of-three':\n        // Select median of first, middle, and last elements\n        const mid = Math.floor((low + high) / 2);\n        \n        // Find median directly\n        if (this.compare(array[low], array[mid]) > 0) {\n          if (this.compare(array[low], array[high]) <= 0) {\n            return low;\n          } else if (this.compare(array[mid], array[high]) > 0) {\n            return mid;\n          } else {\n            return high;\n          }\n        } else {\n          if (this.compare(array[mid], array[high]) <= 0) {\n            return mid;\n          } else if (this.compare(array[low], array[high]) > 0) {\n            return low;\n          } else {\n            return high;\n          }\n        }\n      \n      default:\n        console.warn(`Unknown pivot strategy: ${strategy}, using median-of-three`);\n        return this.selectPivot(array, low, high, 'median-of-three');\n    }\n  }\n  \n  /**\n   * Insertion sort for small subarrays\n   * \n   * @param {Array} array - The array to sort\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   */\n  insertionSort(array, low, high) {\n    for (let i = low + 1; i <= high; i++) {\n      const key = this.read(array, i);\n      let j = i - 1;\n      \n      while (j >= low && this.compare(this.read(array, j), key) > 0) {\n        this.write(array, j + 1, this.read(array, j));\n        j--;\n      }\n      \n      if (j + 1 !== i) {\n        this.write(array, j + 1, key);\n      }\n    }\n  }\n  \n  /**\n   * Get the time and space complexity of Quick Select\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    const worstTime = this.options.useMedianOfMedians ? 'O(n)' : 'O(n²)';\n    \n    return {\n      time: {\n        best: 'O(n)',\n        average: 'O(n)',\n        worst: worstTime\n      },\n      space: {\n        best: 'O(log n)',\n        average: 'O(log n)',\n        worst: 'O(n)'\n      }\n    };\n  }\n  \n  /**\n   * Whether the algorithm is stable\n   * \n   * @returns {boolean} - Always false as QuickSelect isn't stable\n   */\n  isStable() {\n    return false;\n  }\n  \n  /**\n   * Whether the algorithm is in-place\n   * \n   * @returns {boolean} - True as QuickSelect is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add QuickSelect specific information\n    info.optimization = {\n      pivotStrategy: this.options.pivotStrategy,\n      useMedianOfMedians: this.options.useMedianOfMedians,\n      insertionThreshold: this.options.insertionThreshold,\n      visualizePartitioning: this.options.visualizePartitioning\n    };\n    \n    info.properties = {\n      selectionAlgorithm: true,\n      inPlace: true,\n      stable: false,\n      deterministic: this.options.useMedianOfMedians\n    };\n    \n    info.applications = [\n      'Finding k-th smallest/largest element',\n      'Computing medians and quantiles',\n      'Order statistics',\n      'Nearest neighbor search',\n      'Data stream processing'\n    ];\n    \n    info.variants = [\n      'Basic Quick Select',\n      'Median-of-Medians (BFPRT algorithm)',\n      'Introselect (hybrid algorithm)',\n      'Dual-pivot Quick Select'\n    ];\n    \n    info.advantages = [\n      'Average O(n) time complexity',\n      'In-place algorithm with low memory usage',\n      'Can be made deterministic with median-of-medians approach',\n      'Efficient for finding order statistics',\n      'Works well with virtual memory systems'\n    ];\n    \n    info.disadvantages = [\n      'Not stable (doesn\\'t preserve relative order of equal elements)',\n      'Basic version has O(n²) worst-case time complexity',\n      'Median-of-medians variant has higher overhead',\n      'Randomized version lacks guarantees for critical applications'\n    ];\n    \n    return info;\n  }\n}\n\nexport default QuickSelect;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}