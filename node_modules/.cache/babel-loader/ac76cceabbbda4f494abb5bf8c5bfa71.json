{"ast":null,"code":"// src/algorithms/comparison/merge.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of the Merge Sort algorithm with multiple optimization variants.\n * \n * Merge Sort is a divide-and-conquer algorithm that:\n * 1. Divides the input array into two halves\n * 2. Recursively sorts the two halves\n * 3. Merges the sorted halves to produce the final sorted array\n * \n * This implementation includes several optimizations:\n * - Bottom-up iterative implementation to avoid recursion overhead\n * - Insertion sort for small subarrays\n * - Adaptive optimizations for already-sorted runs\n * - In-place merging option to reduce memory usage\n * - Enhanced sentinels for avoiding array bound checks during merge\n * \n * @class MergeSort\n * @extends Algorithm\n */\nclass MergeSort extends Algorithm {\n  /**\n   * Create a new MergeSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.bottomUp=false] - Use bottom-up (iterative) implementation\n   * @param {boolean} [options.adaptive=true] - Use adaptive optimization for partially sorted data\n   * @param {boolean} [options.inPlaceMerge=false] - Use in-place merging (trades speed for memory efficiency)\n   * @param {number} [options.insertionThreshold=10] - Threshold for switching to insertion sort\n   * @param {boolean} [options.optimizeMerge=true] - Use optimized merge implementation with sentinels\n   */\n  constructor(options = {}) {\n    super('Merge Sort', 'comparison', options);\n\n    // Default options\n    this.options = {\n      bottomUp: false,\n      // Use bottom-up (iterative) implementation\n      adaptive: true,\n      // Use adaptive optimization for partially sorted data\n      inPlaceMerge: false,\n      // Use in-place merging (trades speed for memory efficiency)\n      insertionThreshold: 10,\n      // Threshold for switching to insertion sort\n      optimizeMerge: true,\n      // Use optimized merge implementation with sentinels\n      ...options\n    };\n  }\n\n  /**\n   * Execute Merge Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone the array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('sorting');\n\n    // Choose implementation based on options\n    if (options.bottomUp) {\n      this.bottomUpMergeSort(result, options);\n    } else {\n      // Allocate auxiliary array once to avoid repeated allocations\n      const aux = new Array(n);\n      this.topDownMergeSort(result, 0, n - 1, aux, options);\n    }\n    this.setPhase('completed');\n    return result;\n  }\n\n  /**\n   * Top-down (recursive) Merge Sort implementation\n   * \n   * @param {Array} array - The array being sorted\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {Array} aux - Auxiliary array for merging\n   * @param {Object} options - Runtime options\n   */\n  topDownMergeSort(array, low, high, aux, options) {\n    // Record current recursive call\n    this.recordState(array, {\n      type: 'recursive_call',\n      section: [low, high],\n      message: `Sorting section from index ${low} to ${high}`\n    });\n\n    // Base case: Array of size 1 or smaller is already sorted\n    if (high <= low) return;\n\n    // Use insertion sort for small arrays\n    if (high - low < options.insertionThreshold) {\n      this.insertionSort(array, low, high);\n      return;\n    }\n\n    // Adaptive optimization: Check if the subarray is already sorted\n    if (options.adaptive && this.isAlreadySorted(array, low, high)) {\n      this.recordState(array, {\n        type: 'optimization',\n        section: [low, high],\n        message: `Subarray from ${low} to ${high} is already sorted`\n      });\n      return;\n    }\n\n    // Calculate middle point\n    const mid = Math.floor(low + (high - low) / 2);\n\n    // Record the division step\n    this.recordState(array, {\n      type: 'divide',\n      section: [low, high],\n      middle: mid,\n      message: `Dividing at index ${mid}`\n    });\n\n    // Recursively sort left and right halves\n    this.topDownMergeSort(array, low, mid, aux, options);\n    this.topDownMergeSort(array, mid + 1, high, aux, options);\n\n    // Adaptive optimization: Skip merge if largest element in first half\n    // is smaller than smallest element in second half\n    if (options.adaptive && this.compare(array[mid], array[mid + 1]) <= 0) {\n      this.recordState(array, {\n        type: 'optimization',\n        section: [low, high],\n        message: `Skipping merge because array[${mid}] <= array[${mid + 1}]`\n      });\n      return;\n    }\n\n    // Merge the two sorted halves\n    if (options.inPlaceMerge) {\n      this.mergeInPlace(array, low, mid, high);\n    } else if (options.optimizeMerge) {\n      this.mergeOptimized(array, low, mid, high, aux);\n    } else {\n      this.merge(array, low, mid, high, aux);\n    }\n  }\n\n  /**\n   * Bottom-up (iterative) Merge Sort implementation\n   * Avoids recursion overhead by using nested loops\n   * \n   * @param {Array} array - The array to sort\n   * @param {Object} options - Runtime options\n   */\n  bottomUpMergeSort(array, options) {\n    const n = array.length;\n    const aux = new Array(n);\n\n    // Record initial state\n    this.recordState(array, {\n      type: 'initialization',\n      message: 'Starting bottom-up merge sort'\n    });\n\n    // Start with subarrays of size 1, then 2, 4, 8, ...\n    for (let width = 1; width < n; width *= 2) {\n      // Record the current width\n      this.recordState(array, {\n        type: 'width_update',\n        width: width,\n        message: `Merging subarrays of width ${width}`\n      });\n\n      // Merge subarrays of size width\n      for (let i = 0; i < n - width; i += width * 2) {\n        // Calculate boundaries for merge\n        const low = i;\n        const mid = i + width - 1;\n        const high = Math.min(i + width * 2 - 1, n - 1);\n\n        // Use insertion sort for small subarrays\n        if (high - low < options.insertionThreshold) {\n          this.insertionSort(array, low, high);\n          continue;\n        }\n\n        // Adaptive optimization: Skip merge if already sorted\n        if (options.adaptive && this.compare(array[mid], array[mid + 1]) <= 0) {\n          continue;\n        }\n\n        // Record the merge step\n        this.recordState(array, {\n          type: 'merge_step',\n          section: [low, high],\n          middle: mid,\n          message: `Merging sections [${low}...${mid}] and [${mid + 1}...${high}]`\n        });\n\n        // Merge the two subarrays\n        if (options.inPlaceMerge) {\n          this.mergeInPlace(array, low, mid, high);\n        } else if (options.optimizeMerge) {\n          this.mergeOptimized(array, low, mid, high, aux);\n        } else {\n          this.merge(array, low, mid, high, aux);\n        }\n      }\n    }\n  }\n\n  /**\n   * Standard merge operation that combines two sorted subarrays\n   * \n   * @param {Array} array - The array containing subarrays to merge\n   * @param {number} low - Start index\n   * @param {number} mid - Middle index\n   * @param {number} high - End index\n   * @param {Array} aux - Auxiliary array for merging\n   */\n  merge(array, low, mid, high, aux) {\n    // Record merge operation start\n    this.recordState(array, {\n      type: 'merge_begin',\n      section: [low, high],\n      middle: mid,\n      message: `Beginning merge of [${low}...${mid}] and [${mid + 1}...${high}]`\n    });\n\n    // Copy elements to auxiliary array\n    for (let k = low; k <= high; k++) {\n      aux[k] = this.read(array, k);\n    }\n\n    // Merge back into original array\n    let i = low; // Index for left subarray\n    let j = mid + 1; // Index for right subarray\n\n    for (let k = low; k <= high; k++) {\n      // If left subarray is exhausted, take from right\n      if (i > mid) {\n        this.write(array, k, this.read(aux, j++));\n      }\n      // If right subarray is exhausted, take from left\n      else if (j > high) {\n        this.write(array, k, this.read(aux, i++));\n      }\n      // Compare elements and take smaller one\n      else if (this.compare(aux[i], aux[j]) <= 0) {\n        this.write(array, k, this.read(aux, i++));\n      } else {\n        this.write(array, k, this.read(aux, j++));\n      }\n\n      // Record merge progress periodically\n      if ((k - low) % 10 === 0 || k === high) {\n        this.recordState(array, {\n          type: 'merge_progress',\n          section: [low, high],\n          progress: (k - low) / (high - low),\n          message: `Merge progress: ${Math.floor((k - low) / (high - low) * 100)}%`\n        });\n      }\n    }\n\n    // Record merge completion\n    this.recordState(array, {\n      type: 'merge_complete',\n      section: [low, high],\n      message: `Completed merge for section [${low}...${high}]`\n    });\n  }\n\n  /**\n   * Optimized merge operation with sentinels to avoid bounds checking\n   * \n   * @param {Array} array - The array containing subarrays to merge\n   * @param {number} low - Start index\n   * @param {number} mid - Middle index\n   * @param {number} high - End index\n   * @param {Array} aux - Auxiliary array for merging\n   */\n  mergeOptimized(array, low, mid, high, aux) {\n    // Copy with sentinel values to avoid bounds checking\n    for (let i = low; i <= mid; i++) {\n      aux[i] = this.read(array, i);\n    }\n\n    // Copy right subarray in reverse order\n    for (let j = high; j > mid; j--) {\n      aux[j] = this.read(array, j);\n    }\n\n    // Merge with sentinels\n    let i = low; // Start of left subarray\n    let j = high; // Start of right subarray (in reverse)\n\n    for (let k = low; k <= high; k++) {\n      // Compare and take smaller element\n      if (this.compare(aux[i], aux[j]) <= 0) {\n        this.write(array, k, this.read(aux, i++));\n      } else {\n        this.write(array, k, this.read(aux, j--));\n      }\n\n      // Record merge progress periodically\n      if ((k - low) % 10 === 0 || k === high) {\n        this.recordState(array, {\n          type: 'merge_progress',\n          section: [low, high],\n          progress: (k - low) / (high - low),\n          message: `Merge progress: ${Math.floor((k - low) / (high - low) * 100)}%`\n        });\n      }\n    }\n  }\n\n  /**\n   * In-place merge operation that uses O(1) extra space\n   * Note: This is slower than standard merge but uses less memory\n   * \n   * @param {Array} array - The array containing subarrays to merge\n   * @param {number} low - Start index\n   * @param {number} mid - Middle index\n   * @param {number} high - End index\n   */\n  mergeInPlace(array, low, mid, high) {\n    // Record in-place merge start\n    this.recordState(array, {\n      type: 'merge_begin',\n      section: [low, high],\n      middle: mid,\n      message: `Beginning in-place merge of [${low}...${mid}] and [${mid + 1}...${high}]`\n    });\n\n    // Base case for already-sorted ranges\n    if (this.compare(array[mid], array[mid + 1]) <= 0) {\n      return;\n    }\n\n    // In-place merge using rotations\n    let first = low; // Current position in first subarray\n    let second = mid + 1; // Current position in second subarray\n\n    // Skip elements that are already in place\n    while (first <= mid && second <= high) {\n      // If element is already in place, move to next element\n      if (this.compare(array[first], array[second]) <= 0) {\n        first++;\n      } else {\n        // Save the value to insert\n        const value = this.read(array, second);\n        let index = second;\n\n        // Shift elements to make room for insertion\n        while (index > first) {\n          this.write(array, index, this.read(array, index - 1));\n          index--;\n        }\n\n        // Insert the value in the correct position\n        this.write(array, first, value);\n\n        // Adjust pointers\n        first++;\n        mid++;\n        second++;\n\n        // Record significant steps\n        this.recordState(array, {\n          type: 'merge_in_place',\n          section: [low, high],\n          insertion: first - 1,\n          value: value,\n          message: `Inserted element ${value} at position ${first - 1}`\n        });\n      }\n    }\n\n    // Record merge completion\n    this.recordState(array, {\n      type: 'merge_complete',\n      section: [low, high],\n      message: `Completed in-place merge for section [${low}...${high}]`\n    });\n  }\n\n  /**\n   * Insertion sort for small subarrays\n   * \n   * @param {Array} array - The array to sort\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   */\n  insertionSort(array, low, high) {\n    this.recordState(array, {\n      type: 'insertion_sort',\n      section: [low, high],\n      message: `Using insertion sort for small section [${low}...${high}]`\n    });\n    for (let i = low + 1; i <= high; i++) {\n      const key = this.read(array, i);\n      let j = i - 1;\n\n      // Find insertion position\n      while (j >= low && this.compare(this.read(array, j), key) > 0) {\n        this.write(array, j + 1, this.read(array, j));\n        j--;\n      }\n\n      // Insert element at correct position\n      if (j + 1 !== i) {\n        this.write(array, j + 1, key);\n\n        // Record insertion operation\n        this.recordState(array, {\n          type: 'insertion_step',\n          section: [low, high],\n          insertion: j + 1,\n          value: key,\n          message: `Inserted ${key} at position ${j + 1}`\n        });\n      }\n    }\n  }\n\n  /**\n   * Check if a subarray is already sorted\n   * \n   * @param {Array} array - The array to check\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @returns {boolean} - True if the subarray is sorted\n   */\n  isAlreadySorted(array, low, high) {\n    for (let i = low + 1; i <= high; i++) {\n      if (this.compare(array[i - 1], array[i]) > 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Get the time and space complexity of Merge Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: this.options.adaptive ? 'O(n)' : 'O(n log n)',\n        average: 'O(n log n)',\n        worst: 'O(n log n)'\n      },\n      space: {\n        best: this.options.inPlaceMerge ? 'O(1)' : 'O(n)',\n        average: this.options.inPlaceMerge ? 'O(1)' : 'O(n)',\n        worst: this.options.inPlaceMerge ? 'O(1)' : 'O(n)'\n      }\n    };\n  }\n\n  /**\n   * Whether Merge Sort is stable\n   * \n   * @returns {boolean} - True as Merge Sort is stable\n   */\n  isStable() {\n    return true;\n  }\n\n  /**\n   * Whether Merge Sort is in-place\n   * \n   * @returns {boolean} - True only if using in-place merge option\n   */\n  isInPlace() {\n    return this.options.inPlaceMerge;\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add merge sort specific information\n    info.optimization = {\n      bottomUp: this.options.bottomUp,\n      adaptive: this.options.adaptive,\n      inPlaceMerge: this.options.inPlaceMerge,\n      insertionThreshold: this.options.insertionThreshold,\n      optimizeMerge: this.options.optimizeMerge\n    };\n    info.properties = {\n      comparisonBased: true,\n      stable: true,\n      inPlace: this.options.inPlaceMerge,\n      online: false,\n      divideAndConquer: true\n    };\n    info.suitable = {\n      smallArrays: false,\n      nearlySortedArrays: true,\n      largeArrays: true,\n      linkedLists: true\n    };\n    info.variants = ['Top-down (recursive) Merge Sort', 'Bottom-up (iterative) Merge Sort', 'Natural Merge Sort (adaptive)', 'In-place Merge Sort', 'Timsort (hybrid with insertion sort)', 'Parallel Merge Sort'];\n    info.advantages = ['Guaranteed O(n log n) performance in worst case', 'Stable sorting (preserves order of equal elements)', 'Well-suited for external sorting (disk-based)', 'Parallelizes well for multi-threaded implementations', 'Excellent for linked lists (requires only pointer manipulation)'];\n    info.disadvantages = ['Requires O(n) extra space in standard implementation', 'Not cache-efficient due to non-local memory references', 'Slower than quicksort for in-memory sorting in many cases', 'In-place variants have significantly worse performance'];\n    return info;\n  }\n}\nexport default MergeSort;","map":{"version":3,"names":["Algorithm","MergeSort","constructor","options","bottomUp","adaptive","inPlaceMerge","insertionThreshold","optimizeMerge","run","array","result","n","length","setPhase","bottomUpMergeSort","aux","Array","topDownMergeSort","low","high","recordState","type","section","message","insertionSort","isAlreadySorted","mid","Math","floor","middle","compare","mergeInPlace","mergeOptimized","merge","width","i","min","k","read","j","write","progress","first","second","value","index","insertion","key","getComplexity","time","best","average","worst","space","isStable","isInPlace","getInfo","info","optimization","properties","comparisonBased","stable","inPlace","online","divideAndConquer","suitable","smallArrays","nearlySortedArrays","largeArrays","linkedLists","variants","advantages","disadvantages"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/comparison/merge.js"],"sourcesContent":["// src/algorithms/comparison/merge.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of the Merge Sort algorithm with multiple optimization variants.\n * \n * Merge Sort is a divide-and-conquer algorithm that:\n * 1. Divides the input array into two halves\n * 2. Recursively sorts the two halves\n * 3. Merges the sorted halves to produce the final sorted array\n * \n * This implementation includes several optimizations:\n * - Bottom-up iterative implementation to avoid recursion overhead\n * - Insertion sort for small subarrays\n * - Adaptive optimizations for already-sorted runs\n * - In-place merging option to reduce memory usage\n * - Enhanced sentinels for avoiding array bound checks during merge\n * \n * @class MergeSort\n * @extends Algorithm\n */\nclass MergeSort extends Algorithm {\n  /**\n   * Create a new MergeSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.bottomUp=false] - Use bottom-up (iterative) implementation\n   * @param {boolean} [options.adaptive=true] - Use adaptive optimization for partially sorted data\n   * @param {boolean} [options.inPlaceMerge=false] - Use in-place merging (trades speed for memory efficiency)\n   * @param {number} [options.insertionThreshold=10] - Threshold for switching to insertion sort\n   * @param {boolean} [options.optimizeMerge=true] - Use optimized merge implementation with sentinels\n   */\n  constructor(options = {}) {\n    super('Merge Sort', 'comparison', options);\n    \n    // Default options\n    this.options = {\n      bottomUp: false,          // Use bottom-up (iterative) implementation\n      adaptive: true,           // Use adaptive optimization for partially sorted data\n      inPlaceMerge: false,      // Use in-place merging (trades speed for memory efficiency)\n      insertionThreshold: 10,   // Threshold for switching to insertion sort\n      optimizeMerge: true,      // Use optimized merge implementation with sentinels\n      ...options\n    };\n  }\n  \n  /**\n   * Execute Merge Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone the array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('sorting');\n    \n    // Choose implementation based on options\n    if (options.bottomUp) {\n      this.bottomUpMergeSort(result, options);\n    } else {\n      // Allocate auxiliary array once to avoid repeated allocations\n      const aux = new Array(n);\n      this.topDownMergeSort(result, 0, n - 1, aux, options);\n    }\n    \n    this.setPhase('completed');\n    return result;\n  }\n  \n  /**\n   * Top-down (recursive) Merge Sort implementation\n   * \n   * @param {Array} array - The array being sorted\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @param {Array} aux - Auxiliary array for merging\n   * @param {Object} options - Runtime options\n   */\n  topDownMergeSort(array, low, high, aux, options) {\n    // Record current recursive call\n    this.recordState(array, {\n      type: 'recursive_call',\n      section: [low, high],\n      message: `Sorting section from index ${low} to ${high}`\n    });\n    \n    // Base case: Array of size 1 or smaller is already sorted\n    if (high <= low) return;\n    \n    // Use insertion sort for small arrays\n    if (high - low < options.insertionThreshold) {\n      this.insertionSort(array, low, high);\n      return;\n    }\n    \n    // Adaptive optimization: Check if the subarray is already sorted\n    if (options.adaptive && this.isAlreadySorted(array, low, high)) {\n      this.recordState(array, {\n        type: 'optimization',\n        section: [low, high],\n        message: `Subarray from ${low} to ${high} is already sorted`\n      });\n      return;\n    }\n    \n    // Calculate middle point\n    const mid = Math.floor(low + (high - low) / 2);\n    \n    // Record the division step\n    this.recordState(array, {\n      type: 'divide',\n      section: [low, high],\n      middle: mid,\n      message: `Dividing at index ${mid}`\n    });\n    \n    // Recursively sort left and right halves\n    this.topDownMergeSort(array, low, mid, aux, options);\n    this.topDownMergeSort(array, mid + 1, high, aux, options);\n    \n    // Adaptive optimization: Skip merge if largest element in first half\n    // is smaller than smallest element in second half\n    if (options.adaptive && this.compare(array[mid], array[mid + 1]) <= 0) {\n      this.recordState(array, {\n        type: 'optimization',\n        section: [low, high],\n        message: `Skipping merge because array[${mid}] <= array[${mid+1}]`\n      });\n      return;\n    }\n    \n    // Merge the two sorted halves\n    if (options.inPlaceMerge) {\n      this.mergeInPlace(array, low, mid, high);\n    } else if (options.optimizeMerge) {\n      this.mergeOptimized(array, low, mid, high, aux);\n    } else {\n      this.merge(array, low, mid, high, aux);\n    }\n  }\n  \n  /**\n   * Bottom-up (iterative) Merge Sort implementation\n   * Avoids recursion overhead by using nested loops\n   * \n   * @param {Array} array - The array to sort\n   * @param {Object} options - Runtime options\n   */\n  bottomUpMergeSort(array, options) {\n    const n = array.length;\n    const aux = new Array(n);\n    \n    // Record initial state\n    this.recordState(array, {\n      type: 'initialization',\n      message: 'Starting bottom-up merge sort'\n    });\n    \n    // Start with subarrays of size 1, then 2, 4, 8, ...\n    for (let width = 1; width < n; width *= 2) {\n      // Record the current width\n      this.recordState(array, {\n        type: 'width_update',\n        width: width,\n        message: `Merging subarrays of width ${width}`\n      });\n      \n      // Merge subarrays of size width\n      for (let i = 0; i < n - width; i += width * 2) {\n        // Calculate boundaries for merge\n        const low = i;\n        const mid = i + width - 1;\n        const high = Math.min(i + width * 2 - 1, n - 1);\n        \n        // Use insertion sort for small subarrays\n        if (high - low < options.insertionThreshold) {\n          this.insertionSort(array, low, high);\n          continue;\n        }\n        \n        // Adaptive optimization: Skip merge if already sorted\n        if (options.adaptive && this.compare(array[mid], array[mid + 1]) <= 0) {\n          continue;\n        }\n        \n        // Record the merge step\n        this.recordState(array, {\n          type: 'merge_step',\n          section: [low, high],\n          middle: mid,\n          message: `Merging sections [${low}...${mid}] and [${mid+1}...${high}]`\n        });\n        \n        // Merge the two subarrays\n        if (options.inPlaceMerge) {\n          this.mergeInPlace(array, low, mid, high);\n        } else if (options.optimizeMerge) {\n          this.mergeOptimized(array, low, mid, high, aux);\n        } else {\n          this.merge(array, low, mid, high, aux);\n        }\n      }\n    }\n  }\n  \n  /**\n   * Standard merge operation that combines two sorted subarrays\n   * \n   * @param {Array} array - The array containing subarrays to merge\n   * @param {number} low - Start index\n   * @param {number} mid - Middle index\n   * @param {number} high - End index\n   * @param {Array} aux - Auxiliary array for merging\n   */\n  merge(array, low, mid, high, aux) {\n    // Record merge operation start\n    this.recordState(array, {\n      type: 'merge_begin',\n      section: [low, high],\n      middle: mid,\n      message: `Beginning merge of [${low}...${mid}] and [${mid+1}...${high}]`\n    });\n    \n    // Copy elements to auxiliary array\n    for (let k = low; k <= high; k++) {\n      aux[k] = this.read(array, k);\n    }\n    \n    // Merge back into original array\n    let i = low;      // Index for left subarray\n    let j = mid + 1;  // Index for right subarray\n    \n    for (let k = low; k <= high; k++) {\n      // If left subarray is exhausted, take from right\n      if (i > mid) {\n        this.write(array, k, this.read(aux, j++));\n      }\n      // If right subarray is exhausted, take from left\n      else if (j > high) {\n        this.write(array, k, this.read(aux, i++));\n      }\n      // Compare elements and take smaller one\n      else if (this.compare(aux[i], aux[j]) <= 0) {\n        this.write(array, k, this.read(aux, i++));\n      } else {\n        this.write(array, k, this.read(aux, j++));\n      }\n      \n      // Record merge progress periodically\n      if ((k - low) % 10 === 0 || k === high) {\n        this.recordState(array, {\n          type: 'merge_progress',\n          section: [low, high],\n          progress: (k - low) / (high - low),\n          message: `Merge progress: ${Math.floor(((k - low) / (high - low)) * 100)}%`\n        });\n      }\n    }\n    \n    // Record merge completion\n    this.recordState(array, {\n      type: 'merge_complete',\n      section: [low, high],\n      message: `Completed merge for section [${low}...${high}]`\n    });\n  }\n  \n  /**\n   * Optimized merge operation with sentinels to avoid bounds checking\n   * \n   * @param {Array} array - The array containing subarrays to merge\n   * @param {number} low - Start index\n   * @param {number} mid - Middle index\n   * @param {number} high - End index\n   * @param {Array} aux - Auxiliary array for merging\n   */\n  mergeOptimized(array, low, mid, high, aux) {\n    // Copy with sentinel values to avoid bounds checking\n    for (let i = low; i <= mid; i++) {\n      aux[i] = this.read(array, i);\n    }\n    \n    // Copy right subarray in reverse order\n    for (let j = high; j > mid; j--) {\n      aux[j] = this.read(array, j);\n    }\n    \n    // Merge with sentinels\n    let i = low;      // Start of left subarray\n    let j = high;     // Start of right subarray (in reverse)\n    \n    for (let k = low; k <= high; k++) {\n      // Compare and take smaller element\n      if (this.compare(aux[i], aux[j]) <= 0) {\n        this.write(array, k, this.read(aux, i++));\n      } else {\n        this.write(array, k, this.read(aux, j--));\n      }\n      \n      // Record merge progress periodically\n      if ((k - low) % 10 === 0 || k === high) {\n        this.recordState(array, {\n          type: 'merge_progress',\n          section: [low, high],\n          progress: (k - low) / (high - low),\n          message: `Merge progress: ${Math.floor(((k - low) / (high - low)) * 100)}%`\n        });\n      }\n    }\n  }\n  \n  /**\n   * In-place merge operation that uses O(1) extra space\n   * Note: This is slower than standard merge but uses less memory\n   * \n   * @param {Array} array - The array containing subarrays to merge\n   * @param {number} low - Start index\n   * @param {number} mid - Middle index\n   * @param {number} high - End index\n   */\n  mergeInPlace(array, low, mid, high) {\n    // Record in-place merge start\n    this.recordState(array, {\n      type: 'merge_begin',\n      section: [low, high],\n      middle: mid,\n      message: `Beginning in-place merge of [${low}...${mid}] and [${mid+1}...${high}]`\n    });\n    \n    // Base case for already-sorted ranges\n    if (this.compare(array[mid], array[mid + 1]) <= 0) {\n      return;\n    }\n    \n    // In-place merge using rotations\n    let first = low;    // Current position in first subarray\n    let second = mid + 1; // Current position in second subarray\n    \n    // Skip elements that are already in place\n    while (first <= mid && second <= high) {\n      // If element is already in place, move to next element\n      if (this.compare(array[first], array[second]) <= 0) {\n        first++;\n      } else {\n        // Save the value to insert\n        const value = this.read(array, second);\n        let index = second;\n        \n        // Shift elements to make room for insertion\n        while (index > first) {\n          this.write(array, index, this.read(array, index - 1));\n          index--;\n        }\n        \n        // Insert the value in the correct position\n        this.write(array, first, value);\n        \n        // Adjust pointers\n        first++;\n        mid++;\n        second++;\n        \n        // Record significant steps\n        this.recordState(array, {\n          type: 'merge_in_place',\n          section: [low, high],\n          insertion: first - 1,\n          value: value,\n          message: `Inserted element ${value} at position ${first - 1}`\n        });\n      }\n    }\n    \n    // Record merge completion\n    this.recordState(array, {\n      type: 'merge_complete',\n      section: [low, high],\n      message: `Completed in-place merge for section [${low}...${high}]`\n    });\n  }\n  \n  /**\n   * Insertion sort for small subarrays\n   * \n   * @param {Array} array - The array to sort\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   */\n  insertionSort(array, low, high) {\n    this.recordState(array, {\n      type: 'insertion_sort',\n      section: [low, high],\n      message: `Using insertion sort for small section [${low}...${high}]`\n    });\n    \n    for (let i = low + 1; i <= high; i++) {\n      const key = this.read(array, i);\n      let j = i - 1;\n      \n      // Find insertion position\n      while (j >= low && this.compare(this.read(array, j), key) > 0) {\n        this.write(array, j + 1, this.read(array, j));\n        j--;\n      }\n      \n      // Insert element at correct position\n      if (j + 1 !== i) {\n        this.write(array, j + 1, key);\n        \n        // Record insertion operation\n        this.recordState(array, {\n          type: 'insertion_step',\n          section: [low, high],\n          insertion: j + 1,\n          value: key,\n          message: `Inserted ${key} at position ${j + 1}`\n        });\n      }\n    }\n  }\n  \n  /**\n   * Check if a subarray is already sorted\n   * \n   * @param {Array} array - The array to check\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @returns {boolean} - True if the subarray is sorted\n   */\n  isAlreadySorted(array, low, high) {\n    for (let i = low + 1; i <= high; i++) {\n      if (this.compare(array[i - 1], array[i]) > 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  /**\n   * Get the time and space complexity of Merge Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: this.options.adaptive ? 'O(n)' : 'O(n log n)',\n        average: 'O(n log n)',\n        worst: 'O(n log n)'\n      },\n      space: {\n        best: this.options.inPlaceMerge ? 'O(1)' : 'O(n)',\n        average: this.options.inPlaceMerge ? 'O(1)' : 'O(n)',\n        worst: this.options.inPlaceMerge ? 'O(1)' : 'O(n)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Merge Sort is stable\n   * \n   * @returns {boolean} - True as Merge Sort is stable\n   */\n  isStable() {\n    return true;\n  }\n  \n  /**\n   * Whether Merge Sort is in-place\n   * \n   * @returns {boolean} - True only if using in-place merge option\n   */\n  isInPlace() {\n    return this.options.inPlaceMerge;\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add merge sort specific information\n    info.optimization = {\n      bottomUp: this.options.bottomUp,\n      adaptive: this.options.adaptive,\n      inPlaceMerge: this.options.inPlaceMerge,\n      insertionThreshold: this.options.insertionThreshold,\n      optimizeMerge: this.options.optimizeMerge\n    };\n    \n    info.properties = {\n      comparisonBased: true,\n      stable: true,\n      inPlace: this.options.inPlaceMerge,\n      online: false,\n      divideAndConquer: true\n    };\n    \n    info.suitable = {\n      smallArrays: false,\n      nearlySortedArrays: true,\n      largeArrays: true,\n      linkedLists: true\n    };\n    \n    info.variants = [\n      'Top-down (recursive) Merge Sort',\n      'Bottom-up (iterative) Merge Sort',\n      'Natural Merge Sort (adaptive)',\n      'In-place Merge Sort',\n      'Timsort (hybrid with insertion sort)',\n      'Parallel Merge Sort'\n    ];\n    \n    info.advantages = [\n      'Guaranteed O(n log n) performance in worst case',\n      'Stable sorting (preserves order of equal elements)',\n      'Well-suited for external sorting (disk-based)',\n      'Parallelizes well for multi-threaded implementations',\n      'Excellent for linked lists (requires only pointer manipulation)'\n    ];\n    \n    info.disadvantages = [\n      'Requires O(n) extra space in standard implementation',\n      'Not cache-efficient due to non-local memory references',\n      'Slower than quicksort for in-memory sorting in many cases',\n      'In-place variants have significantly worse performance'\n    ];\n    \n    return info;\n  }\n}\n\nexport default MergeSort;"],"mappings":"AAAA;;AAEA,OAAOA,SAAS,MAAM,wBAAwB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,SAASD,SAAS,CAAC;EAChC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,WAAWA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IACxB,KAAK,CAAC,YAAY,EAAE,YAAY,EAAEA,OAAO,CAAC;;IAE1C;IACA,IAAI,CAACA,OAAO,GAAG;MACbC,QAAQ,EAAE,KAAK;MAAW;MAC1BC,QAAQ,EAAE,IAAI;MAAY;MAC1BC,YAAY,EAAE,KAAK;MAAO;MAC1BC,kBAAkB,EAAE,EAAE;MAAI;MAC1BC,aAAa,EAAE,IAAI;MAAO;MAC1B,GAAGL;IACL,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEM,GAAGA,CAACC,KAAK,EAAEP,OAAO,EAAE;IAClB;IACA,MAAMQ,MAAM,GAAG,CAAC,GAAGD,KAAK,CAAC;IACzB,MAAME,CAAC,GAAGD,MAAM,CAACE,MAAM;;IAEvB;IACA,IAAID,CAAC,IAAI,CAAC,EAAE;MACV,OAAOD,MAAM;IACf;IAEA,IAAI,CAACG,QAAQ,CAAC,SAAS,CAAC;;IAExB;IACA,IAAIX,OAAO,CAACC,QAAQ,EAAE;MACpB,IAAI,CAACW,iBAAiB,CAACJ,MAAM,EAAER,OAAO,CAAC;IACzC,CAAC,MAAM;MACL;MACA,MAAMa,GAAG,GAAG,IAAIC,KAAK,CAACL,CAAC,CAAC;MACxB,IAAI,CAACM,gBAAgB,CAACP,MAAM,EAAE,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEI,GAAG,EAAEb,OAAO,CAAC;IACvD;IAEA,IAAI,CAACW,QAAQ,CAAC,WAAW,CAAC;IAC1B,OAAOH,MAAM;EACf;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEO,gBAAgBA,CAACR,KAAK,EAAES,GAAG,EAAEC,IAAI,EAAEJ,GAAG,EAAEb,OAAO,EAAE;IAC/C;IACA,IAAI,CAACkB,WAAW,CAACX,KAAK,EAAE;MACtBY,IAAI,EAAE,gBAAgB;MACtBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;MACpBI,OAAO,EAAE,8BAA8BL,GAAG,OAAOC,IAAI;IACvD,CAAC,CAAC;;IAEF;IACA,IAAIA,IAAI,IAAID,GAAG,EAAE;;IAEjB;IACA,IAAIC,IAAI,GAAGD,GAAG,GAAGhB,OAAO,CAACI,kBAAkB,EAAE;MAC3C,IAAI,CAACkB,aAAa,CAACf,KAAK,EAAES,GAAG,EAAEC,IAAI,CAAC;MACpC;IACF;;IAEA;IACA,IAAIjB,OAAO,CAACE,QAAQ,IAAI,IAAI,CAACqB,eAAe,CAAChB,KAAK,EAAES,GAAG,EAAEC,IAAI,CAAC,EAAE;MAC9D,IAAI,CAACC,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,cAAc;QACpBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;QACpBI,OAAO,EAAE,iBAAiBL,GAAG,OAAOC,IAAI;MAC1C,CAAC,CAAC;MACF;IACF;;IAEA;IACA,MAAMO,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACV,GAAG,GAAG,CAACC,IAAI,GAAGD,GAAG,IAAI,CAAC,CAAC;;IAE9C;IACA,IAAI,CAACE,WAAW,CAACX,KAAK,EAAE;MACtBY,IAAI,EAAE,QAAQ;MACdC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;MACpBU,MAAM,EAAEH,GAAG;MACXH,OAAO,EAAE,qBAAqBG,GAAG;IACnC,CAAC,CAAC;;IAEF;IACA,IAAI,CAACT,gBAAgB,CAACR,KAAK,EAAES,GAAG,EAAEQ,GAAG,EAAEX,GAAG,EAAEb,OAAO,CAAC;IACpD,IAAI,CAACe,gBAAgB,CAACR,KAAK,EAAEiB,GAAG,GAAG,CAAC,EAAEP,IAAI,EAAEJ,GAAG,EAAEb,OAAO,CAAC;;IAEzD;IACA;IACA,IAAIA,OAAO,CAACE,QAAQ,IAAI,IAAI,CAAC0B,OAAO,CAACrB,KAAK,CAACiB,GAAG,CAAC,EAAEjB,KAAK,CAACiB,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;MACrE,IAAI,CAACN,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,cAAc;QACpBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;QACpBI,OAAO,EAAE,gCAAgCG,GAAG,cAAcA,GAAG,GAAC,CAAC;MACjE,CAAC,CAAC;MACF;IACF;;IAEA;IACA,IAAIxB,OAAO,CAACG,YAAY,EAAE;MACxB,IAAI,CAAC0B,YAAY,CAACtB,KAAK,EAAES,GAAG,EAAEQ,GAAG,EAAEP,IAAI,CAAC;IAC1C,CAAC,MAAM,IAAIjB,OAAO,CAACK,aAAa,EAAE;MAChC,IAAI,CAACyB,cAAc,CAACvB,KAAK,EAAES,GAAG,EAAEQ,GAAG,EAAEP,IAAI,EAAEJ,GAAG,CAAC;IACjD,CAAC,MAAM;MACL,IAAI,CAACkB,KAAK,CAACxB,KAAK,EAAES,GAAG,EAAEQ,GAAG,EAAEP,IAAI,EAAEJ,GAAG,CAAC;IACxC;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACED,iBAAiBA,CAACL,KAAK,EAAEP,OAAO,EAAE;IAChC,MAAMS,CAAC,GAAGF,KAAK,CAACG,MAAM;IACtB,MAAMG,GAAG,GAAG,IAAIC,KAAK,CAACL,CAAC,CAAC;;IAExB;IACA,IAAI,CAACS,WAAW,CAACX,KAAK,EAAE;MACtBY,IAAI,EAAE,gBAAgB;MACtBE,OAAO,EAAE;IACX,CAAC,CAAC;;IAEF;IACA,KAAK,IAAIW,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGvB,CAAC,EAAEuB,KAAK,IAAI,CAAC,EAAE;MACzC;MACA,IAAI,CAACd,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,cAAc;QACpBa,KAAK,EAAEA,KAAK;QACZX,OAAO,EAAE,8BAA8BW,KAAK;MAC9C,CAAC,CAAC;;MAEF;MACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxB,CAAC,GAAGuB,KAAK,EAAEC,CAAC,IAAID,KAAK,GAAG,CAAC,EAAE;QAC7C;QACA,MAAMhB,GAAG,GAAGiB,CAAC;QACb,MAAMT,GAAG,GAAGS,CAAC,GAAGD,KAAK,GAAG,CAAC;QACzB,MAAMf,IAAI,GAAGQ,IAAI,CAACS,GAAG,CAACD,CAAC,GAAGD,KAAK,GAAG,CAAC,GAAG,CAAC,EAAEvB,CAAC,GAAG,CAAC,CAAC;;QAE/C;QACA,IAAIQ,IAAI,GAAGD,GAAG,GAAGhB,OAAO,CAACI,kBAAkB,EAAE;UAC3C,IAAI,CAACkB,aAAa,CAACf,KAAK,EAAES,GAAG,EAAEC,IAAI,CAAC;UACpC;QACF;;QAEA;QACA,IAAIjB,OAAO,CAACE,QAAQ,IAAI,IAAI,CAAC0B,OAAO,CAACrB,KAAK,CAACiB,GAAG,CAAC,EAAEjB,KAAK,CAACiB,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;UACrE;QACF;;QAEA;QACA,IAAI,CAACN,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,YAAY;UAClBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;UACpBU,MAAM,EAAEH,GAAG;UACXH,OAAO,EAAE,qBAAqBL,GAAG,MAAMQ,GAAG,UAAUA,GAAG,GAAC,CAAC,MAAMP,IAAI;QACrE,CAAC,CAAC;;QAEF;QACA,IAAIjB,OAAO,CAACG,YAAY,EAAE;UACxB,IAAI,CAAC0B,YAAY,CAACtB,KAAK,EAAES,GAAG,EAAEQ,GAAG,EAAEP,IAAI,CAAC;QAC1C,CAAC,MAAM,IAAIjB,OAAO,CAACK,aAAa,EAAE;UAChC,IAAI,CAACyB,cAAc,CAACvB,KAAK,EAAES,GAAG,EAAEQ,GAAG,EAAEP,IAAI,EAAEJ,GAAG,CAAC;QACjD,CAAC,MAAM;UACL,IAAI,CAACkB,KAAK,CAACxB,KAAK,EAAES,GAAG,EAAEQ,GAAG,EAAEP,IAAI,EAAEJ,GAAG,CAAC;QACxC;MACF;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEkB,KAAKA,CAACxB,KAAK,EAAES,GAAG,EAAEQ,GAAG,EAAEP,IAAI,EAAEJ,GAAG,EAAE;IAChC;IACA,IAAI,CAACK,WAAW,CAACX,KAAK,EAAE;MACtBY,IAAI,EAAE,aAAa;MACnBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;MACpBU,MAAM,EAAEH,GAAG;MACXH,OAAO,EAAE,uBAAuBL,GAAG,MAAMQ,GAAG,UAAUA,GAAG,GAAC,CAAC,MAAMP,IAAI;IACvE,CAAC,CAAC;;IAEF;IACA,KAAK,IAAIkB,CAAC,GAAGnB,GAAG,EAAEmB,CAAC,IAAIlB,IAAI,EAAEkB,CAAC,EAAE,EAAE;MAChCtB,GAAG,CAACsB,CAAC,CAAC,GAAG,IAAI,CAACC,IAAI,CAAC7B,KAAK,EAAE4B,CAAC,CAAC;IAC9B;;IAEA;IACA,IAAIF,CAAC,GAAGjB,GAAG,CAAC,CAAM;IAClB,IAAIqB,CAAC,GAAGb,GAAG,GAAG,CAAC,CAAC,CAAE;;IAElB,KAAK,IAAIW,CAAC,GAAGnB,GAAG,EAAEmB,CAAC,IAAIlB,IAAI,EAAEkB,CAAC,EAAE,EAAE;MAChC;MACA,IAAIF,CAAC,GAAGT,GAAG,EAAE;QACX,IAAI,CAACc,KAAK,CAAC/B,KAAK,EAAE4B,CAAC,EAAE,IAAI,CAACC,IAAI,CAACvB,GAAG,EAAEwB,CAAC,EAAE,CAAC,CAAC;MAC3C;MACA;MAAA,KACK,IAAIA,CAAC,GAAGpB,IAAI,EAAE;QACjB,IAAI,CAACqB,KAAK,CAAC/B,KAAK,EAAE4B,CAAC,EAAE,IAAI,CAACC,IAAI,CAACvB,GAAG,EAAEoB,CAAC,EAAE,CAAC,CAAC;MAC3C;MACA;MAAA,KACK,IAAI,IAAI,CAACL,OAAO,CAACf,GAAG,CAACoB,CAAC,CAAC,EAAEpB,GAAG,CAACwB,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;QAC1C,IAAI,CAACC,KAAK,CAAC/B,KAAK,EAAE4B,CAAC,EAAE,IAAI,CAACC,IAAI,CAACvB,GAAG,EAAEoB,CAAC,EAAE,CAAC,CAAC;MAC3C,CAAC,MAAM;QACL,IAAI,CAACK,KAAK,CAAC/B,KAAK,EAAE4B,CAAC,EAAE,IAAI,CAACC,IAAI,CAACvB,GAAG,EAAEwB,CAAC,EAAE,CAAC,CAAC;MAC3C;;MAEA;MACA,IAAI,CAACF,CAAC,GAAGnB,GAAG,IAAI,EAAE,KAAK,CAAC,IAAImB,CAAC,KAAKlB,IAAI,EAAE;QACtC,IAAI,CAACC,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,gBAAgB;UACtBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;UACpBsB,QAAQ,EAAE,CAACJ,CAAC,GAAGnB,GAAG,KAAKC,IAAI,GAAGD,GAAG,CAAC;UAClCK,OAAO,EAAE,mBAAmBI,IAAI,CAACC,KAAK,CAAE,CAACS,CAAC,GAAGnB,GAAG,KAAKC,IAAI,GAAGD,GAAG,CAAC,GAAI,GAAG,CAAC;QAC1E,CAAC,CAAC;MACJ;IACF;;IAEA;IACA,IAAI,CAACE,WAAW,CAACX,KAAK,EAAE;MACtBY,IAAI,EAAE,gBAAgB;MACtBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;MACpBI,OAAO,EAAE,gCAAgCL,GAAG,MAAMC,IAAI;IACxD,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEa,cAAcA,CAACvB,KAAK,EAAES,GAAG,EAAEQ,GAAG,EAAEP,IAAI,EAAEJ,GAAG,EAAE;IACzC;IACA,KAAK,IAAIoB,CAAC,GAAGjB,GAAG,EAAEiB,CAAC,IAAIT,GAAG,EAAES,CAAC,EAAE,EAAE;MAC/BpB,GAAG,CAACoB,CAAC,CAAC,GAAG,IAAI,CAACG,IAAI,CAAC7B,KAAK,EAAE0B,CAAC,CAAC;IAC9B;;IAEA;IACA,KAAK,IAAII,CAAC,GAAGpB,IAAI,EAAEoB,CAAC,GAAGb,GAAG,EAAEa,CAAC,EAAE,EAAE;MAC/BxB,GAAG,CAACwB,CAAC,CAAC,GAAG,IAAI,CAACD,IAAI,CAAC7B,KAAK,EAAE8B,CAAC,CAAC;IAC9B;;IAEA;IACA,IAAIJ,CAAC,GAAGjB,GAAG,CAAC,CAAM;IAClB,IAAIqB,CAAC,GAAGpB,IAAI,CAAC,CAAK;;IAElB,KAAK,IAAIkB,CAAC,GAAGnB,GAAG,EAAEmB,CAAC,IAAIlB,IAAI,EAAEkB,CAAC,EAAE,EAAE;MAChC;MACA,IAAI,IAAI,CAACP,OAAO,CAACf,GAAG,CAACoB,CAAC,CAAC,EAAEpB,GAAG,CAACwB,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;QACrC,IAAI,CAACC,KAAK,CAAC/B,KAAK,EAAE4B,CAAC,EAAE,IAAI,CAACC,IAAI,CAACvB,GAAG,EAAEoB,CAAC,EAAE,CAAC,CAAC;MAC3C,CAAC,MAAM;QACL,IAAI,CAACK,KAAK,CAAC/B,KAAK,EAAE4B,CAAC,EAAE,IAAI,CAACC,IAAI,CAACvB,GAAG,EAAEwB,CAAC,EAAE,CAAC,CAAC;MAC3C;;MAEA;MACA,IAAI,CAACF,CAAC,GAAGnB,GAAG,IAAI,EAAE,KAAK,CAAC,IAAImB,CAAC,KAAKlB,IAAI,EAAE;QACtC,IAAI,CAACC,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,gBAAgB;UACtBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;UACpBsB,QAAQ,EAAE,CAACJ,CAAC,GAAGnB,GAAG,KAAKC,IAAI,GAAGD,GAAG,CAAC;UAClCK,OAAO,EAAE,mBAAmBI,IAAI,CAACC,KAAK,CAAE,CAACS,CAAC,GAAGnB,GAAG,KAAKC,IAAI,GAAGD,GAAG,CAAC,GAAI,GAAG,CAAC;QAC1E,CAAC,CAAC;MACJ;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEa,YAAYA,CAACtB,KAAK,EAAES,GAAG,EAAEQ,GAAG,EAAEP,IAAI,EAAE;IAClC;IACA,IAAI,CAACC,WAAW,CAACX,KAAK,EAAE;MACtBY,IAAI,EAAE,aAAa;MACnBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;MACpBU,MAAM,EAAEH,GAAG;MACXH,OAAO,EAAE,gCAAgCL,GAAG,MAAMQ,GAAG,UAAUA,GAAG,GAAC,CAAC,MAAMP,IAAI;IAChF,CAAC,CAAC;;IAEF;IACA,IAAI,IAAI,CAACW,OAAO,CAACrB,KAAK,CAACiB,GAAG,CAAC,EAAEjB,KAAK,CAACiB,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;MACjD;IACF;;IAEA;IACA,IAAIgB,KAAK,GAAGxB,GAAG,CAAC,CAAI;IACpB,IAAIyB,MAAM,GAAGjB,GAAG,GAAG,CAAC,CAAC,CAAC;;IAEtB;IACA,OAAOgB,KAAK,IAAIhB,GAAG,IAAIiB,MAAM,IAAIxB,IAAI,EAAE;MACrC;MACA,IAAI,IAAI,CAACW,OAAO,CAACrB,KAAK,CAACiC,KAAK,CAAC,EAAEjC,KAAK,CAACkC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE;QAClDD,KAAK,EAAE;MACT,CAAC,MAAM;QACL;QACA,MAAME,KAAK,GAAG,IAAI,CAACN,IAAI,CAAC7B,KAAK,EAAEkC,MAAM,CAAC;QACtC,IAAIE,KAAK,GAAGF,MAAM;;QAElB;QACA,OAAOE,KAAK,GAAGH,KAAK,EAAE;UACpB,IAAI,CAACF,KAAK,CAAC/B,KAAK,EAAEoC,KAAK,EAAE,IAAI,CAACP,IAAI,CAAC7B,KAAK,EAAEoC,KAAK,GAAG,CAAC,CAAC,CAAC;UACrDA,KAAK,EAAE;QACT;;QAEA;QACA,IAAI,CAACL,KAAK,CAAC/B,KAAK,EAAEiC,KAAK,EAAEE,KAAK,CAAC;;QAE/B;QACAF,KAAK,EAAE;QACPhB,GAAG,EAAE;QACLiB,MAAM,EAAE;;QAER;QACA,IAAI,CAACvB,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,gBAAgB;UACtBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;UACpB2B,SAAS,EAAEJ,KAAK,GAAG,CAAC;UACpBE,KAAK,EAAEA,KAAK;UACZrB,OAAO,EAAE,oBAAoBqB,KAAK,gBAAgBF,KAAK,GAAG,CAAC;QAC7D,CAAC,CAAC;MACJ;IACF;;IAEA;IACA,IAAI,CAACtB,WAAW,CAACX,KAAK,EAAE;MACtBY,IAAI,EAAE,gBAAgB;MACtBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;MACpBI,OAAO,EAAE,yCAAyCL,GAAG,MAAMC,IAAI;IACjE,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEK,aAAaA,CAACf,KAAK,EAAES,GAAG,EAAEC,IAAI,EAAE;IAC9B,IAAI,CAACC,WAAW,CAACX,KAAK,EAAE;MACtBY,IAAI,EAAE,gBAAgB;MACtBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;MACpBI,OAAO,EAAE,2CAA2CL,GAAG,MAAMC,IAAI;IACnE,CAAC,CAAC;IAEF,KAAK,IAAIgB,CAAC,GAAGjB,GAAG,GAAG,CAAC,EAAEiB,CAAC,IAAIhB,IAAI,EAAEgB,CAAC,EAAE,EAAE;MACpC,MAAMY,GAAG,GAAG,IAAI,CAACT,IAAI,CAAC7B,KAAK,EAAE0B,CAAC,CAAC;MAC/B,IAAII,CAAC,GAAGJ,CAAC,GAAG,CAAC;;MAEb;MACA,OAAOI,CAAC,IAAIrB,GAAG,IAAI,IAAI,CAACY,OAAO,CAAC,IAAI,CAACQ,IAAI,CAAC7B,KAAK,EAAE8B,CAAC,CAAC,EAAEQ,GAAG,CAAC,GAAG,CAAC,EAAE;QAC7D,IAAI,CAACP,KAAK,CAAC/B,KAAK,EAAE8B,CAAC,GAAG,CAAC,EAAE,IAAI,CAACD,IAAI,CAAC7B,KAAK,EAAE8B,CAAC,CAAC,CAAC;QAC7CA,CAAC,EAAE;MACL;;MAEA;MACA,IAAIA,CAAC,GAAG,CAAC,KAAKJ,CAAC,EAAE;QACf,IAAI,CAACK,KAAK,CAAC/B,KAAK,EAAE8B,CAAC,GAAG,CAAC,EAAEQ,GAAG,CAAC;;QAE7B;QACA,IAAI,CAAC3B,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,gBAAgB;UACtBC,OAAO,EAAE,CAACJ,GAAG,EAAEC,IAAI,CAAC;UACpB2B,SAAS,EAAEP,CAAC,GAAG,CAAC;UAChBK,KAAK,EAAEG,GAAG;UACVxB,OAAO,EAAE,YAAYwB,GAAG,gBAAgBR,CAAC,GAAG,CAAC;QAC/C,CAAC,CAAC;MACJ;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEd,eAAeA,CAAChB,KAAK,EAAES,GAAG,EAAEC,IAAI,EAAE;IAChC,KAAK,IAAIgB,CAAC,GAAGjB,GAAG,GAAG,CAAC,EAAEiB,CAAC,IAAIhB,IAAI,EAAEgB,CAAC,EAAE,EAAE;MACpC,IAAI,IAAI,CAACL,OAAO,CAACrB,KAAK,CAAC0B,CAAC,GAAG,CAAC,CAAC,EAAE1B,KAAK,CAAC0B,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;QAC5C,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACEa,aAAaA,CAAA,EAAG;IACd,OAAO;MACLC,IAAI,EAAE;QACJC,IAAI,EAAE,IAAI,CAAChD,OAAO,CAACE,QAAQ,GAAG,MAAM,GAAG,YAAY;QACnD+C,OAAO,EAAE,YAAY;QACrBC,KAAK,EAAE;MACT,CAAC;MACDC,KAAK,EAAE;QACLH,IAAI,EAAE,IAAI,CAAChD,OAAO,CAACG,YAAY,GAAG,MAAM,GAAG,MAAM;QACjD8C,OAAO,EAAE,IAAI,CAACjD,OAAO,CAACG,YAAY,GAAG,MAAM,GAAG,MAAM;QACpD+C,KAAK,EAAE,IAAI,CAAClD,OAAO,CAACG,YAAY,GAAG,MAAM,GAAG;MAC9C;IACF,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;EACEiD,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACEC,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAACrD,OAAO,CAACG,YAAY;EAClC;;EAEA;AACF;AACA;AACA;AACA;EACEmD,OAAOA,CAAA,EAAG;IACR,MAAMC,IAAI,GAAG,KAAK,CAACD,OAAO,CAAC,CAAC;;IAE5B;IACAC,IAAI,CAACC,YAAY,GAAG;MAClBvD,QAAQ,EAAE,IAAI,CAACD,OAAO,CAACC,QAAQ;MAC/BC,QAAQ,EAAE,IAAI,CAACF,OAAO,CAACE,QAAQ;MAC/BC,YAAY,EAAE,IAAI,CAACH,OAAO,CAACG,YAAY;MACvCC,kBAAkB,EAAE,IAAI,CAACJ,OAAO,CAACI,kBAAkB;MACnDC,aAAa,EAAE,IAAI,CAACL,OAAO,CAACK;IAC9B,CAAC;IAEDkD,IAAI,CAACE,UAAU,GAAG;MAChBC,eAAe,EAAE,IAAI;MACrBC,MAAM,EAAE,IAAI;MACZC,OAAO,EAAE,IAAI,CAAC5D,OAAO,CAACG,YAAY;MAClC0D,MAAM,EAAE,KAAK;MACbC,gBAAgB,EAAE;IACpB,CAAC;IAEDP,IAAI,CAACQ,QAAQ,GAAG;MACdC,WAAW,EAAE,KAAK;MAClBC,kBAAkB,EAAE,IAAI;MACxBC,WAAW,EAAE,IAAI;MACjBC,WAAW,EAAE;IACf,CAAC;IAEDZ,IAAI,CAACa,QAAQ,GAAG,CACd,iCAAiC,EACjC,kCAAkC,EAClC,+BAA+B,EAC/B,qBAAqB,EACrB,sCAAsC,EACtC,qBAAqB,CACtB;IAEDb,IAAI,CAACc,UAAU,GAAG,CAChB,iDAAiD,EACjD,oDAAoD,EACpD,+CAA+C,EAC/C,sDAAsD,EACtD,iEAAiE,CAClE;IAEDd,IAAI,CAACe,aAAa,GAAG,CACnB,sDAAsD,EACtD,wDAAwD,EACxD,2DAA2D,EAC3D,wDAAwD,CACzD;IAED,OAAOf,IAAI;EACb;AACF;AAEA,eAAezD,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module"}