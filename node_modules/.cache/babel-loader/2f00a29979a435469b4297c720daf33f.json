{"ast":null,"code":"// src/algorithms/distribution/bucket.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Bucket Sort with adaptive bucket sizing and multiple bucket variants.\n * \n * Bucket Sort is a distribution sort algorithm that:\n * 1. Distributes elements into a number of buckets based on their values\n * 2. Sorts each bucket individually (using another sorting algorithm)\n * 3. Concatenates the sorted buckets to produce the final sorted array\n * \n * Time Complexity:\n * - Best:    O(n + k) when elements uniformly distributed and insertion sort on small buckets\n * - Average: O(n + k) when elements uniformly distributed\n * - Worst:   O(nÂ²) when all elements fall into one bucket\n * \n * Space Complexity: O(n + k) where k is the number of buckets\n * \n * @class BucketSort\n * @extends Algorithm\n */\nclass BucketSort extends Algorithm {\n  /**\n   * Create a new BucketSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {number} [options.bucketCount=10] - Number of buckets to use\n   * @param {string} [options.bucketSizing='adaptive'] - Bucket sizing strategy ('uniform', 'adaptive', 'sqrt')\n   * @param {string} [options.bucketSort='insertion'] - Algorithm to sort individual buckets\n   * @param {boolean} [options.optimizeSingleton=true] - Skip sorting for buckets with 0-1 elements\n   * @param {boolean} [options.detectUniformity=true] - Detect and optimize for uniform distributions\n   */\n  constructor(options = {}) {\n    super('Bucket Sort', 'distribution', options);\n\n    // Default options\n    this.options = {\n      bucketCount: 10,\n      // Number of buckets to use\n      bucketSizing: 'adaptive',\n      // 'uniform', 'adaptive', or 'sqrt'\n      bucketSort: 'insertion',\n      // Algorithm to sort individual buckets\n      optimizeSingleton: true,\n      // Skip sorting for buckets with 0-1 elements\n      detectUniformity: true,\n      // Detect and optimize for uniform distributions\n      ...options\n    };\n  }\n\n  /**\n   * Execute Bucket Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('analysis');\n\n    // Analyze the array\n    const analysis = this.analyzeArray(result);\n    const {\n      min,\n      max,\n      range,\n      isInteger,\n      hasNegative\n    } = analysis;\n\n    // Record the analysis\n    this.recordState(result, {\n      type: 'array-analysis',\n      analysis,\n      message: `Analyzed array: range [${min} to ${max}], ${isInteger ? 'integer' : 'float'} values, negative numbers: ${hasNegative}`\n    });\n\n    // Handle negative numbers if present\n    if (hasNegative) {\n      return this.handleNegativeNumbers(result, analysis, options);\n    }\n\n    // Determine optimal bucket count\n    const bucketCount = this.determineBucketCount(n, range, options);\n    this.recordState(result, {\n      type: 'bucket-setup',\n      bucketCount,\n      message: `Using ${bucketCount} buckets with ${options.bucketSizing} sizing strategy`\n    });\n    this.setPhase('distribution');\n\n    // Create buckets\n    const buckets = Array.from({\n      length: bucketCount\n    }, () => []);\n\n    // Distribute elements into buckets\n    for (let i = 0; i < n; i++) {\n      const value = this.read(result, i);\n      const bucketIndex = this.getBucketIndex(value, min, max, bucketCount);\n      buckets[bucketIndex].push(value);\n\n      // Record significant distribution steps\n      if (i % Math.max(1, Math.floor(n / 20)) === 0 || i === n - 1) {\n        this.recordState(result, {\n          type: 'element-distribution',\n          index: i,\n          value,\n          bucketIndex,\n          message: `Placed element ${value} into bucket ${bucketIndex}`\n        });\n      }\n    }\n\n    // Record bucket distribution\n    const bucketSizes = buckets.map(b => b.length);\n    this.recordState(result, {\n      type: 'buckets-filled',\n      buckets: buckets.map(b => [...b]),\n      bucketSizes,\n      message: `Distributed elements into buckets: [${bucketSizes.join(', ')}]`\n    });\n    this.setPhase('bucket-sorting');\n\n    // Sort individual buckets\n    for (let i = 0; i < bucketCount; i++) {\n      const bucket = buckets[i];\n\n      // Skip empty buckets or singleton buckets if optimization enabled\n      if (bucket.length <= (options.optimizeSingleton ? 1 : 0)) {\n        if (bucket.length === 1) {\n          this.recordState(result, {\n            type: 'singleton-optimization',\n            bucketIndex: i,\n            message: `Skipped sorting bucket ${i} with single element`\n          });\n        }\n        continue;\n      }\n      this.recordState(result, {\n        type: 'bucket-sort-start',\n        bucketIndex: i,\n        bucketSize: bucket.length,\n        message: `Sorting bucket ${i} with ${bucket.length} elements`\n      });\n\n      // Choose sorting algorithm for this bucket\n      this.sortBucket(bucket, options);\n      this.recordState(result, {\n        type: 'bucket-sorted',\n        bucketIndex: i,\n        bucket: [...bucket],\n        message: `Completed sorting bucket ${i}`\n      });\n    }\n    this.setPhase('concatenation');\n\n    // Concatenate sorted buckets\n    let index = 0;\n    for (let i = 0; i < bucketCount; i++) {\n      const bucket = buckets[i];\n\n      // Record bucket concatenation\n      if (bucket.length > 0) {\n        this.recordState(result, {\n          type: 'bucket-concatenation',\n          bucketIndex: i,\n          bucketSize: bucket.length,\n          outputIndex: index,\n          message: `Concatenating bucket ${i} to positions ${index} through ${index + bucket.length - 1}`\n        });\n      }\n\n      // Copy bucket elements to the result array\n      for (let j = 0; j < bucket.length; j++) {\n        this.write(result, index++, bucket[j]);\n      }\n    }\n    this.setPhase('completed');\n    return result;\n  }\n\n  /**\n   * Analyze the array to determine key properties for sorting\n   * \n   * @param {Array} array - Array to analyze\n   * @returns {Object} - Analysis results\n   */\n  analyzeArray(array) {\n    const n = array.length;\n    let min = Infinity;\n    let max = -Infinity;\n    let sum = 0;\n    let isInteger = true;\n    let hasNegative = false;\n\n    // Scan array to find min, max, and detect if all elements are integers\n    for (let i = 0; i < n; i++) {\n      const value = array[i];\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n      sum += value;\n      if (value < 0) {\n        hasNegative = true;\n      }\n      if (isInteger && !Number.isInteger(value)) {\n        isInteger = false;\n      }\n    }\n    const range = max - min;\n    const average = sum / n;\n\n    // Calculate distribution properties\n    let variance = 0;\n    for (let i = 0; i < n; i++) {\n      variance += Math.pow(array[i] - average, 2);\n    }\n    variance /= n;\n    const standardDeviation = Math.sqrt(variance);\n    const coefficient = standardDeviation / average;\n\n    // Detect uniform distribution\n    const isUniform = coefficient < 0.25; // Heuristic for uniform-like distribution\n\n    return {\n      min,\n      max,\n      range,\n      average,\n      variance,\n      standardDeviation,\n      coefficient,\n      isInteger,\n      hasNegative,\n      isUniform\n    };\n  }\n\n  /**\n   * Determine the optimal number of buckets based on array properties\n   * \n   * @param {number} n - Array length\n   * @param {number} range - Range of values in the array\n   * @param {Object} options - Runtime options\n   * @returns {number} - Number of buckets to use\n   */\n  determineBucketCount(n, range, options) {\n    if (options.bucketSizing === 'sqrt') {\n      // Square root of array size - common heuristic\n      return Math.max(2, Math.floor(Math.sqrt(n)));\n    } else if (options.bucketSizing === 'adaptive') {\n      // Adaptive bucket count based on array size and range\n      if (n < 10) {\n        return Math.min(n, 5);\n      } else if (n < 100) {\n        return Math.min(n, 10);\n      } else if (n < 1000) {\n        return Math.min(n, Math.max(10, n / 50));\n      } else {\n        return Math.min(n, Math.max(20, Math.sqrt(n)));\n      }\n    } else {\n      // Default to fixed bucket count\n      return options.bucketCount;\n    }\n  }\n\n  /**\n   * Determine the bucket index for a given value\n   * \n   * @param {number} value - Value to place in a bucket\n   * @param {number} min - Minimum value in the array\n   * @param {number} max - Maximum value in the array\n   * @param {number} bucketCount - Number of buckets\n   * @returns {number} - Bucket index\n   */\n  getBucketIndex(value, min, max, bucketCount) {\n    // Handle edge case where all values are the same\n    if (max === min) {\n      return 0;\n    }\n\n    // Normalize the value to 0-1 range, then scale to bucket count\n    const normalizedValue = (value - min) / (max - min);\n    let bucketIndex = Math.floor(normalizedValue * bucketCount);\n\n    // Ensure index is within bounds (for floating point precision issues)\n    return Math.min(bucketCount - 1, Math.max(0, bucketIndex));\n  }\n\n  /**\n   * Sort elements within a bucket\n   * \n   * @param {Array} bucket - Bucket to sort\n   * @param {Object} options - Runtime options\n   */\n  sortBucket(bucket, options) {\n    switch (options.bucketSort) {\n      case 'insertion':\n        this.insertionSort(bucket);\n        break;\n      case 'quick':\n        this.quickSort(bucket, 0, bucket.length - 1);\n        break;\n      case 'merge':\n        this.mergeSort(bucket, 0, bucket.length - 1);\n        break;\n      default:\n        // Default to insertion sort for small buckets\n        this.insertionSort(bucket);\n    }\n  }\n\n  /**\n   * Insertion sort implementation for bucket sorting\n   * \n   * @param {Array} array - Array to sort\n   */\n  insertionSort(array) {\n    const n = array.length;\n    for (let i = 1; i < n; i++) {\n      const key = array[i];\n      let j = i - 1;\n      while (j >= 0 && array[j] > key) {\n        array[j + 1] = array[j];\n        j--;\n      }\n      array[j + 1] = key;\n    }\n  }\n\n  /**\n   * Quick sort implementation for bucket sorting\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   */\n  quickSort(array, low, high) {\n    if (low < high) {\n      const pivotIndex = this.partition(array, low, high);\n      this.quickSort(array, low, pivotIndex - 1);\n      this.quickSort(array, pivotIndex + 1, high);\n    }\n  }\n\n  /**\n   * Helper function for quicksort\n   * \n   * @param {Array} array - Array to partition\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @returns {number} - Pivot index\n   */\n  partition(array, low, high) {\n    // Use middle element as pivot to avoid worst case for sorted arrays\n    const mid = Math.floor((low + high) / 2);\n    const pivotValue = array[mid];\n\n    // Move pivot to end\n    [array[mid], array[high]] = [array[high], array[mid]];\n    let i = low;\n    for (let j = low; j < high; j++) {\n      if (array[j] < pivotValue) {\n        [array[i], array[j]] = [array[j], array[i]];\n        i++;\n      }\n    }\n    [array[i], array[high]] = [array[high], array[i]];\n    return i;\n  }\n\n  /**\n   * Merge sort implementation for bucket sorting\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} left - Start index\n   * @param {number} right - End index\n   */\n  mergeSort(array, left, right) {\n    if (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      this.mergeSort(array, left, mid);\n      this.mergeSort(array, mid + 1, right);\n      this.merge(array, left, mid, right);\n    }\n  }\n\n  /**\n   * Helper function for merge sort\n   * \n   * @param {Array} array - Array to merge\n   * @param {number} left - Left start index\n   * @param {number} mid - Middle index\n   * @param {number} right - Right end index\n   */\n  merge(array, left, mid, right) {\n    const n1 = mid - left + 1;\n    const n2 = right - mid;\n\n    // Create temporary arrays\n    const leftArray = new Array(n1);\n    const rightArray = new Array(n2);\n\n    // Copy data to temporary arrays\n    for (let i = 0; i < n1; i++) {\n      leftArray[i] = array[left + i];\n    }\n    for (let j = 0; j < n2; j++) {\n      rightArray[j] = array[mid + 1 + j];\n    }\n\n    // Merge the arrays back\n    let i = 0,\n      j = 0,\n      k = left;\n    while (i < n1 && j < n2) {\n      if (leftArray[i] <= rightArray[j]) {\n        array[k] = leftArray[i];\n        i++;\n      } else {\n        array[k] = rightArray[j];\n        j++;\n      }\n      k++;\n    }\n\n    // Copy remaining elements\n    while (i < n1) {\n      array[k] = leftArray[i];\n      i++;\n      k++;\n    }\n    while (j < n2) {\n      array[k] = rightArray[j];\n      j++;\n      k++;\n    }\n  }\n\n  /**\n   * Handle arrays with negative numbers by splitting and sorting separately\n   * \n   * @param {Array} array - Array with negative numbers\n   * @param {Object} analysis - Array analysis results\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  handleNegativeNumbers(array, analysis, options) {\n    this.setPhase('handling-negatives');\n    const n = array.length;\n    const positives = [];\n    const negatives = [];\n    const zeros = [];\n\n    // Separate positive, negative and zero values\n    for (let i = 0; i < n; i++) {\n      const value = this.read(array, i);\n      if (value < 0) {\n        negatives.push(-value); // Store as positive for sorting\n      } else if (value > 0) {\n        positives.push(value);\n      } else {\n        zeros.push(value); // Keep zeros separate\n      }\n    }\n    this.recordState(array, {\n      type: 'negative-handling',\n      positiveCount: positives.length,\n      negativeCount: negatives.length,\n      zeroCount: zeros.length,\n      message: `Separated into ${positives.length} positive, ${negatives.length} negative, and ${zeros.length} zero values`\n    });\n\n    // Create positive analysis\n    const positiveAnalysis = positives.length > 0 ? this.analyzeArray(positives) : null;\n\n    // Create negative analysis (using absolute values)\n    const negativeAnalysis = negatives.length > 0 ? this.analyzeArray(negatives) : null;\n\n    // Sort positive numbers if any\n    if (positives.length > 0) {\n      this.recordState(array, {\n        type: 'sorting-positives',\n        count: positives.length,\n        message: `Sorting ${positives.length} positive values`\n      });\n\n      // Determine bucket count for positives\n      const positiveBucketCount = this.determineBucketCount(positives.length, positiveAnalysis.range, options);\n\n      // Create buckets for positives\n      const positiveBuckets = Array.from({\n        length: positiveBucketCount\n      }, () => []);\n\n      // Distribute positive elements\n      for (let i = 0; i < positives.length; i++) {\n        const value = positives[i];\n        const bucketIndex = this.getBucketIndex(value, positiveAnalysis.min, positiveAnalysis.max, positiveBucketCount);\n        positiveBuckets[bucketIndex].push(value);\n      }\n\n      // Sort each positive bucket\n      for (let i = 0; i < positiveBucketCount; i++) {\n        if (positiveBuckets[i].length > 0) {\n          this.sortBucket(positiveBuckets[i], options);\n        }\n      }\n\n      // Concatenate positive buckets\n      positives.length = 0; // Clear array\n      for (let i = 0; i < positiveBucketCount; i++) {\n        positives.push(...positiveBuckets[i]);\n      }\n    }\n\n    // Sort negative numbers if any\n    if (negatives.length > 0) {\n      this.recordState(array, {\n        type: 'sorting-negatives',\n        count: negatives.length,\n        message: `Sorting ${negatives.length} negative values (as absolute values)`\n      });\n\n      // Determine bucket count for negatives\n      const negativeBucketCount = this.determineBucketCount(negatives.length, negativeAnalysis.range, options);\n\n      // Create buckets for negatives\n      const negativeBuckets = Array.from({\n        length: negativeBucketCount\n      }, () => []);\n\n      // Distribute negative elements (as positive values)\n      for (let i = 0; i < negatives.length; i++) {\n        const value = negatives[i];\n        const bucketIndex = this.getBucketIndex(value, negativeAnalysis.min, negativeAnalysis.max, negativeBucketCount);\n        negativeBuckets[bucketIndex].push(value);\n      }\n\n      // Sort each negative bucket\n      for (let i = 0; i < negativeBucketCount; i++) {\n        if (negativeBuckets[i].length > 0) {\n          this.sortBucket(negativeBuckets[i], options);\n        }\n      }\n\n      // Concatenate negative buckets and negate values\n      negatives.length = 0; // Clear array\n      for (let i = negativeBucketCount - 1; i >= 0; i--) {\n        for (let j = negativeBuckets[i].length - 1; j >= 0; j--) {\n          negatives.push(-negativeBuckets[i][j]);\n        }\n      }\n    }\n\n    // Combine results: negatives + zeros + positives\n    const result = [...negatives, ...zeros, ...positives];\n\n    // Copy back to original array\n    for (let i = 0; i < n; i++) {\n      this.write(array, i, result[i]);\n    }\n    this.recordState(array, {\n      type: 'combined-result',\n      message: 'Combined sorted negative, zero, and positive values'\n    });\n    return array;\n  }\n\n  /**\n   * Get the time and space complexity of Bucket Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(n + k)',\n        average: 'O(n + k)',\n        worst: 'O(nÂ²)'\n      },\n      space: {\n        best: 'O(n + k)',\n        average: 'O(n + k)',\n        worst: 'O(n + k)'\n      }\n    };\n  }\n\n  /**\n   * Whether Bucket Sort is stable\n   * \n   * @returns {boolean} - True if using stable sort for buckets\n   */\n  isStable() {\n    // Stability depends on the bucket sorting algorithm\n    return this.options.bucketSort === 'insertion' || this.options.bucketSort === 'merge';\n  }\n\n  /**\n   * Whether Bucket Sort is in-place\n   * \n   * @returns {boolean} - False as Bucket Sort requires auxiliary space\n   */\n  isInPlace() {\n    return false; // Requires O(n) auxiliary space\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add bucket sort specific information\n    info.optimization = {\n      bucketCount: this.options.bucketCount,\n      bucketSizing: this.options.bucketSizing,\n      bucketSort: this.options.bucketSort,\n      optimizeSingleton: this.options.optimizeSingleton,\n      detectUniformity: this.options.detectUniformity\n    };\n    info.properties = {\n      comparisonBased: false,\n      // The distribution phase is not comparison-based\n      stable: this.isStable(),\n      inPlace: this.isInPlace(),\n      online: false,\n      divideAndConquer: true // Splits problem into independent parts\n    };\n    info.suitable = {\n      smallArrays: false,\n      uniformDistribution: true,\n      floatingPointData: true,\n      limitedRange: true\n    };\n    info.variants = ['Standard Bucket Sort', 'Adaptive Bucket Sort (dynamic bucket sizing)', 'Proxmap Sort (specialized hash function)', 'Histogram Sort (counting-based variation)', 'Postman Sort (specialized for postal codes)'];\n    info.advantages = ['Linear time complexity O(n) for uniform distributions', 'Works well with floating-point numbers', 'Parallelizable across buckets', 'Adaptive to data distribution with proper bucket sizing', 'Can outperform comparison sorts for suitable data'];\n    info.disadvantages = ['Highly sensitive to data distribution (all elements in one bucket is worst case)', 'Requires additional space proportional to input size', 'Performance depends on efficiency of bucket sorting algorithm', 'Not suitable for linked lists or external sorting', 'Determining optimal bucket count requires data analysis'];\n    return info;\n  }\n}\nexport default BucketSort;","map":{"version":3,"names":["Algorithm","BucketSort","constructor","options","bucketCount","bucketSizing","bucketSort","optimizeSingleton","detectUniformity","run","array","result","n","length","setPhase","analysis","analyzeArray","min","max","range","isInteger","hasNegative","recordState","type","message","handleNegativeNumbers","determineBucketCount","buckets","Array","from","i","value","read","bucketIndex","getBucketIndex","push","Math","floor","index","bucketSizes","map","b","join","bucket","bucketSize","sortBucket","outputIndex","j","write","Infinity","sum","Number","average","variance","pow","standardDeviation","sqrt","coefficient","isUniform","normalizedValue","insertionSort","quickSort","mergeSort","key","low","high","pivotIndex","partition","mid","pivotValue","left","right","merge","n1","n2","leftArray","rightArray","k","positives","negatives","zeros","positiveCount","negativeCount","zeroCount","positiveAnalysis","negativeAnalysis","count","positiveBucketCount","positiveBuckets","negativeBucketCount","negativeBuckets","getComplexity","time","best","worst","space","isStable","isInPlace","getInfo","info","optimization","properties","comparisonBased","stable","inPlace","online","divideAndConquer","suitable","smallArrays","uniformDistribution","floatingPointData","limitedRange","variants","advantages","disadvantages"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/distribution/bucket.js"],"sourcesContent":["// src/algorithms/distribution/bucket.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Bucket Sort with adaptive bucket sizing and multiple bucket variants.\n * \n * Bucket Sort is a distribution sort algorithm that:\n * 1. Distributes elements into a number of buckets based on their values\n * 2. Sorts each bucket individually (using another sorting algorithm)\n * 3. Concatenates the sorted buckets to produce the final sorted array\n * \n * Time Complexity:\n * - Best:    O(n + k) when elements uniformly distributed and insertion sort on small buckets\n * - Average: O(n + k) when elements uniformly distributed\n * - Worst:   O(nÂ²) when all elements fall into one bucket\n * \n * Space Complexity: O(n + k) where k is the number of buckets\n * \n * @class BucketSort\n * @extends Algorithm\n */\nclass BucketSort extends Algorithm {\n  /**\n   * Create a new BucketSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {number} [options.bucketCount=10] - Number of buckets to use\n   * @param {string} [options.bucketSizing='adaptive'] - Bucket sizing strategy ('uniform', 'adaptive', 'sqrt')\n   * @param {string} [options.bucketSort='insertion'] - Algorithm to sort individual buckets\n   * @param {boolean} [options.optimizeSingleton=true] - Skip sorting for buckets with 0-1 elements\n   * @param {boolean} [options.detectUniformity=true] - Detect and optimize for uniform distributions\n   */\n  constructor(options = {}) {\n    super('Bucket Sort', 'distribution', options);\n    \n    // Default options\n    this.options = {\n      bucketCount: 10,               // Number of buckets to use\n      bucketSizing: 'adaptive',      // 'uniform', 'adaptive', or 'sqrt'\n      bucketSort: 'insertion',       // Algorithm to sort individual buckets\n      optimizeSingleton: true,       // Skip sorting for buckets with 0-1 elements\n      detectUniformity: true,        // Detect and optimize for uniform distributions\n      ...options\n    };\n  }\n  \n  /**\n   * Execute Bucket Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('analysis');\n    \n    // Analyze the array\n    const analysis = this.analyzeArray(result);\n    const { min, max, range, isInteger, hasNegative } = analysis;\n    \n    // Record the analysis\n    this.recordState(result, {\n      type: 'array-analysis',\n      analysis,\n      message: `Analyzed array: range [${min} to ${max}], ${isInteger ? 'integer' : 'float'} values, negative numbers: ${hasNegative}`\n    });\n    \n    // Handle negative numbers if present\n    if (hasNegative) {\n      return this.handleNegativeNumbers(result, analysis, options);\n    }\n    \n    // Determine optimal bucket count\n    const bucketCount = this.determineBucketCount(n, range, options);\n    \n    this.recordState(result, {\n      type: 'bucket-setup',\n      bucketCount,\n      message: `Using ${bucketCount} buckets with ${options.bucketSizing} sizing strategy`\n    });\n    \n    this.setPhase('distribution');\n    \n    // Create buckets\n    const buckets = Array.from({ length: bucketCount }, () => []);\n    \n    // Distribute elements into buckets\n    for (let i = 0; i < n; i++) {\n      const value = this.read(result, i);\n      const bucketIndex = this.getBucketIndex(value, min, max, bucketCount);\n      \n      buckets[bucketIndex].push(value);\n      \n      // Record significant distribution steps\n      if (i % Math.max(1, Math.floor(n / 20)) === 0 || i === n - 1) {\n        this.recordState(result, {\n          type: 'element-distribution',\n          index: i,\n          value,\n          bucketIndex,\n          message: `Placed element ${value} into bucket ${bucketIndex}`\n        });\n      }\n    }\n    \n    // Record bucket distribution\n    const bucketSizes = buckets.map(b => b.length);\n    this.recordState(result, {\n      type: 'buckets-filled',\n      buckets: buckets.map(b => [...b]),\n      bucketSizes,\n      message: `Distributed elements into buckets: [${bucketSizes.join(', ')}]`\n    });\n    \n    this.setPhase('bucket-sorting');\n    \n    // Sort individual buckets\n    for (let i = 0; i < bucketCount; i++) {\n      const bucket = buckets[i];\n      \n      // Skip empty buckets or singleton buckets if optimization enabled\n      if (bucket.length <= (options.optimizeSingleton ? 1 : 0)) {\n        if (bucket.length === 1) {\n          this.recordState(result, {\n            type: 'singleton-optimization',\n            bucketIndex: i,\n            message: `Skipped sorting bucket ${i} with single element`\n          });\n        }\n        continue;\n      }\n      \n      this.recordState(result, {\n        type: 'bucket-sort-start',\n        bucketIndex: i,\n        bucketSize: bucket.length,\n        message: `Sorting bucket ${i} with ${bucket.length} elements`\n      });\n      \n      // Choose sorting algorithm for this bucket\n      this.sortBucket(bucket, options);\n      \n      this.recordState(result, {\n        type: 'bucket-sorted',\n        bucketIndex: i,\n        bucket: [...bucket],\n        message: `Completed sorting bucket ${i}`\n      });\n    }\n    \n    this.setPhase('concatenation');\n    \n    // Concatenate sorted buckets\n    let index = 0;\n    for (let i = 0; i < bucketCount; i++) {\n      const bucket = buckets[i];\n      \n      // Record bucket concatenation\n      if (bucket.length > 0) {\n        this.recordState(result, {\n          type: 'bucket-concatenation',\n          bucketIndex: i,\n          bucketSize: bucket.length,\n          outputIndex: index,\n          message: `Concatenating bucket ${i} to positions ${index} through ${index + bucket.length - 1}`\n        });\n      }\n      \n      // Copy bucket elements to the result array\n      for (let j = 0; j < bucket.length; j++) {\n        this.write(result, index++, bucket[j]);\n      }\n    }\n    \n    this.setPhase('completed');\n    return result;\n  }\n  \n  /**\n   * Analyze the array to determine key properties for sorting\n   * \n   * @param {Array} array - Array to analyze\n   * @returns {Object} - Analysis results\n   */\n  analyzeArray(array) {\n    const n = array.length;\n    let min = Infinity;\n    let max = -Infinity;\n    let sum = 0;\n    let isInteger = true;\n    let hasNegative = false;\n    \n    // Scan array to find min, max, and detect if all elements are integers\n    for (let i = 0; i < n; i++) {\n      const value = array[i];\n      \n      min = Math.min(min, value);\n      max = Math.max(max, value);\n      sum += value;\n      \n      if (value < 0) {\n        hasNegative = true;\n      }\n      \n      if (isInteger && !Number.isInteger(value)) {\n        isInteger = false;\n      }\n    }\n    \n    const range = max - min;\n    const average = sum / n;\n    \n    // Calculate distribution properties\n    let variance = 0;\n    for (let i = 0; i < n; i++) {\n      variance += Math.pow(array[i] - average, 2);\n    }\n    variance /= n;\n    \n    const standardDeviation = Math.sqrt(variance);\n    const coefficient = standardDeviation / average;\n    \n    // Detect uniform distribution\n    const isUniform = coefficient < 0.25; // Heuristic for uniform-like distribution\n    \n    return {\n      min,\n      max,\n      range,\n      average,\n      variance,\n      standardDeviation,\n      coefficient,\n      isInteger,\n      hasNegative,\n      isUniform\n    };\n  }\n  \n  /**\n   * Determine the optimal number of buckets based on array properties\n   * \n   * @param {number} n - Array length\n   * @param {number} range - Range of values in the array\n   * @param {Object} options - Runtime options\n   * @returns {number} - Number of buckets to use\n   */\n  determineBucketCount(n, range, options) {\n    if (options.bucketSizing === 'sqrt') {\n      // Square root of array size - common heuristic\n      return Math.max(2, Math.floor(Math.sqrt(n)));\n    } else if (options.bucketSizing === 'adaptive') {\n      // Adaptive bucket count based on array size and range\n      if (n < 10) {\n        return Math.min(n, 5);\n      } else if (n < 100) {\n        return Math.min(n, 10);\n      } else if (n < 1000) {\n        return Math.min(n, Math.max(10, n / 50));\n      } else {\n        return Math.min(n, Math.max(20, Math.sqrt(n)));\n      }\n    } else {\n      // Default to fixed bucket count\n      return options.bucketCount;\n    }\n  }\n  \n  /**\n   * Determine the bucket index for a given value\n   * \n   * @param {number} value - Value to place in a bucket\n   * @param {number} min - Minimum value in the array\n   * @param {number} max - Maximum value in the array\n   * @param {number} bucketCount - Number of buckets\n   * @returns {number} - Bucket index\n   */\n  getBucketIndex(value, min, max, bucketCount) {\n    // Handle edge case where all values are the same\n    if (max === min) {\n      return 0;\n    }\n    \n    // Normalize the value to 0-1 range, then scale to bucket count\n    const normalizedValue = (value - min) / (max - min);\n    let bucketIndex = Math.floor(normalizedValue * bucketCount);\n    \n    // Ensure index is within bounds (for floating point precision issues)\n    return Math.min(bucketCount - 1, Math.max(0, bucketIndex));\n  }\n  \n  /**\n   * Sort elements within a bucket\n   * \n   * @param {Array} bucket - Bucket to sort\n   * @param {Object} options - Runtime options\n   */\n  sortBucket(bucket, options) {\n    switch (options.bucketSort) {\n      case 'insertion':\n        this.insertionSort(bucket);\n        break;\n      case 'quick':\n        this.quickSort(bucket, 0, bucket.length - 1);\n        break;\n      case 'merge':\n        this.mergeSort(bucket, 0, bucket.length - 1);\n        break;\n      default:\n        // Default to insertion sort for small buckets\n        this.insertionSort(bucket);\n    }\n  }\n  \n  /**\n   * Insertion sort implementation for bucket sorting\n   * \n   * @param {Array} array - Array to sort\n   */\n  insertionSort(array) {\n    const n = array.length;\n    \n    for (let i = 1; i < n; i++) {\n      const key = array[i];\n      let j = i - 1;\n      \n      while (j >= 0 && array[j] > key) {\n        array[j + 1] = array[j];\n        j--;\n      }\n      \n      array[j + 1] = key;\n    }\n  }\n  \n  /**\n   * Quick sort implementation for bucket sorting\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   */\n  quickSort(array, low, high) {\n    if (low < high) {\n      const pivotIndex = this.partition(array, low, high);\n      this.quickSort(array, low, pivotIndex - 1);\n      this.quickSort(array, pivotIndex + 1, high);\n    }\n  }\n  \n  /**\n   * Helper function for quicksort\n   * \n   * @param {Array} array - Array to partition\n   * @param {number} low - Start index\n   * @param {number} high - End index\n   * @returns {number} - Pivot index\n   */\n  partition(array, low, high) {\n    // Use middle element as pivot to avoid worst case for sorted arrays\n    const mid = Math.floor((low + high) / 2);\n    const pivotValue = array[mid];\n    \n    // Move pivot to end\n    [array[mid], array[high]] = [array[high], array[mid]];\n    \n    let i = low;\n    \n    for (let j = low; j < high; j++) {\n      if (array[j] < pivotValue) {\n        [array[i], array[j]] = [array[j], array[i]];\n        i++;\n      }\n    }\n    \n    [array[i], array[high]] = [array[high], array[i]];\n    return i;\n  }\n  \n  /**\n   * Merge sort implementation for bucket sorting\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} left - Start index\n   * @param {number} right - End index\n   */\n  mergeSort(array, left, right) {\n    if (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      \n      this.mergeSort(array, left, mid);\n      this.mergeSort(array, mid + 1, right);\n      \n      this.merge(array, left, mid, right);\n    }\n  }\n  \n  /**\n   * Helper function for merge sort\n   * \n   * @param {Array} array - Array to merge\n   * @param {number} left - Left start index\n   * @param {number} mid - Middle index\n   * @param {number} right - Right end index\n   */\n  merge(array, left, mid, right) {\n    const n1 = mid - left + 1;\n    const n2 = right - mid;\n    \n    // Create temporary arrays\n    const leftArray = new Array(n1);\n    const rightArray = new Array(n2);\n    \n    // Copy data to temporary arrays\n    for (let i = 0; i < n1; i++) {\n      leftArray[i] = array[left + i];\n    }\n    for (let j = 0; j < n2; j++) {\n      rightArray[j] = array[mid + 1 + j];\n    }\n    \n    // Merge the arrays back\n    let i = 0, j = 0, k = left;\n    \n    while (i < n1 && j < n2) {\n      if (leftArray[i] <= rightArray[j]) {\n        array[k] = leftArray[i];\n        i++;\n      } else {\n        array[k] = rightArray[j];\n        j++;\n      }\n      k++;\n    }\n    \n    // Copy remaining elements\n    while (i < n1) {\n      array[k] = leftArray[i];\n      i++;\n      k++;\n    }\n    \n    while (j < n2) {\n      array[k] = rightArray[j];\n      j++;\n      k++;\n    }\n  }\n  \n  /**\n   * Handle arrays with negative numbers by splitting and sorting separately\n   * \n   * @param {Array} array - Array with negative numbers\n   * @param {Object} analysis - Array analysis results\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  handleNegativeNumbers(array, analysis, options) {\n    this.setPhase('handling-negatives');\n    \n    const n = array.length;\n    const positives = [];\n    const negatives = [];\n    const zeros = [];\n    \n    // Separate positive, negative and zero values\n    for (let i = 0; i < n; i++) {\n      const value = this.read(array, i);\n      if (value < 0) {\n        negatives.push(-value); // Store as positive for sorting\n      } else if (value > 0) {\n        positives.push(value);\n      } else {\n        zeros.push(value); // Keep zeros separate\n      }\n    }\n    \n    this.recordState(array, {\n      type: 'negative-handling',\n      positiveCount: positives.length,\n      negativeCount: negatives.length,\n      zeroCount: zeros.length,\n      message: `Separated into ${positives.length} positive, ${negatives.length} negative, and ${zeros.length} zero values`\n    });\n    \n    // Create positive analysis\n    const positiveAnalysis = positives.length > 0 ? this.analyzeArray(positives) : null;\n    \n    // Create negative analysis (using absolute values)\n    const negativeAnalysis = negatives.length > 0 ? this.analyzeArray(negatives) : null;\n    \n    // Sort positive numbers if any\n    if (positives.length > 0) {\n      this.recordState(array, {\n        type: 'sorting-positives',\n        count: positives.length,\n        message: `Sorting ${positives.length} positive values`\n      });\n      \n      // Determine bucket count for positives\n      const positiveBucketCount = this.determineBucketCount(\n        positives.length, \n        positiveAnalysis.range, \n        options\n      );\n      \n      // Create buckets for positives\n      const positiveBuckets = Array.from(\n        { length: positiveBucketCount }, \n        () => []\n      );\n      \n      // Distribute positive elements\n      for (let i = 0; i < positives.length; i++) {\n        const value = positives[i];\n        const bucketIndex = this.getBucketIndex(\n          value, \n          positiveAnalysis.min, \n          positiveAnalysis.max, \n          positiveBucketCount\n        );\n        positiveBuckets[bucketIndex].push(value);\n      }\n      \n      // Sort each positive bucket\n      for (let i = 0; i < positiveBucketCount; i++) {\n        if (positiveBuckets[i].length > 0) {\n          this.sortBucket(positiveBuckets[i], options);\n        }\n      }\n      \n      // Concatenate positive buckets\n      positives.length = 0; // Clear array\n      for (let i = 0; i < positiveBucketCount; i++) {\n        positives.push(...positiveBuckets[i]);\n      }\n    }\n    \n    // Sort negative numbers if any\n    if (negatives.length > 0) {\n      this.recordState(array, {\n        type: 'sorting-negatives',\n        count: negatives.length,\n        message: `Sorting ${negatives.length} negative values (as absolute values)`\n      });\n      \n      // Determine bucket count for negatives\n      const negativeBucketCount = this.determineBucketCount(\n        negatives.length, \n        negativeAnalysis.range, \n        options\n      );\n      \n      // Create buckets for negatives\n      const negativeBuckets = Array.from(\n        { length: negativeBucketCount }, \n        () => []\n      );\n      \n      // Distribute negative elements (as positive values)\n      for (let i = 0; i < negatives.length; i++) {\n        const value = negatives[i];\n        const bucketIndex = this.getBucketIndex(\n          value, \n          negativeAnalysis.min, \n          negativeAnalysis.max, \n          negativeBucketCount\n        );\n        negativeBuckets[bucketIndex].push(value);\n      }\n      \n      // Sort each negative bucket\n      for (let i = 0; i < negativeBucketCount; i++) {\n        if (negativeBuckets[i].length > 0) {\n          this.sortBucket(negativeBuckets[i], options);\n        }\n      }\n      \n      // Concatenate negative buckets and negate values\n      negatives.length = 0; // Clear array\n      for (let i = negativeBucketCount - 1; i >= 0; i--) {\n        for (let j = negativeBuckets[i].length - 1; j >= 0; j--) {\n          negatives.push(-negativeBuckets[i][j]);\n        }\n      }\n    }\n    \n    // Combine results: negatives + zeros + positives\n    const result = [...negatives, ...zeros, ...positives];\n    \n    // Copy back to original array\n    for (let i = 0; i < n; i++) {\n      this.write(array, i, result[i]);\n    }\n    \n    this.recordState(array, {\n      type: 'combined-result',\n      message: 'Combined sorted negative, zero, and positive values'\n    });\n    \n    return array;\n  }\n  \n  /**\n   * Get the time and space complexity of Bucket Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(n + k)',\n        average: 'O(n + k)',\n        worst: 'O(nÂ²)'\n      },\n      space: {\n        best: 'O(n + k)',\n        average: 'O(n + k)',\n        worst: 'O(n + k)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Bucket Sort is stable\n   * \n   * @returns {boolean} - True if using stable sort for buckets\n   */\n  isStable() {\n    // Stability depends on the bucket sorting algorithm\n    return this.options.bucketSort === 'insertion' || this.options.bucketSort === 'merge';\n  }\n  \n  /**\n   * Whether Bucket Sort is in-place\n   * \n   * @returns {boolean} - False as Bucket Sort requires auxiliary space\n   */\n  isInPlace() {\n    return false; // Requires O(n) auxiliary space\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add bucket sort specific information\n    info.optimization = {\n      bucketCount: this.options.bucketCount,\n      bucketSizing: this.options.bucketSizing,\n      bucketSort: this.options.bucketSort,\n      optimizeSingleton: this.options.optimizeSingleton,\n      detectUniformity: this.options.detectUniformity\n    };\n    \n    info.properties = {\n      comparisonBased: false, // The distribution phase is not comparison-based\n      stable: this.isStable(),\n      inPlace: this.isInPlace(),\n      online: false,\n      divideAndConquer: true // Splits problem into independent parts\n    };\n    \n    info.suitable = {\n      smallArrays: false,\n      uniformDistribution: true,\n      floatingPointData: true,\n      limitedRange: true\n    };\n    \n    info.variants = [\n      'Standard Bucket Sort',\n      'Adaptive Bucket Sort (dynamic bucket sizing)',\n      'Proxmap Sort (specialized hash function)',\n      'Histogram Sort (counting-based variation)',\n      'Postman Sort (specialized for postal codes)'\n    ];\n    \n    info.advantages = [\n      'Linear time complexity O(n) for uniform distributions',\n      'Works well with floating-point numbers',\n      'Parallelizable across buckets',\n      'Adaptive to data distribution with proper bucket sizing',\n      'Can outperform comparison sorts for suitable data'\n    ];\n    \n    info.disadvantages = [\n      'Highly sensitive to data distribution (all elements in one bucket is worst case)',\n      'Requires additional space proportional to input size',\n      'Performance depends on efficiency of bucket sorting algorithm',\n      'Not suitable for linked lists or external sorting',\n      'Determining optimal bucket count requires data analysis'\n    ];\n    \n    return info;\n  }\n}\n\nexport default BucketSort;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}