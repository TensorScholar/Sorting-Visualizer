{"ast":null,"code":"// src/visualization/renderers/array-renderer.js\n\n/**\n * @file Canvas-based renderer for algorithm visualization\n * @author Algorithm Visualization Platform Team\n * @version 2.0.0\n * \n * @description\n * Canvas-based renderer that provides a fallback when WebGL isn't supported.\n * This implementation uses the standard Canvas 2D API to render visualization\n * elements with a focus on compatibility, correctness, and reasonable performance\n * for moderate dataset sizes (up to ~10,000 elements).\n * \n * The renderer implements the same interface as the WebGL renderer to ensure\n * seamless fallback, while optimizing Canvas-specific rendering techniques\n * for maximum possible performance within the constraints of the 2D context.\n * \n * Performance characteristics:\n * - Time complexity: O(n) for rendering n elements\n * - Space complexity: O(n) for state tracking\n * - Rendering performance: ~60fps for up to 1,000 elements on most devices\n *                          ~30fps for 1,000-5,000 elements\n *                          ~10-15fps for 5,000-10,000 elements\n * \n * Features:\n * - Identical API to WebGL renderer for simple substitution\n * - Performance optimizations specific to Canvas rendering\n * - Multiple rendering strategies based on data size\n * - Canvas-specific color handling and transformations\n * - Optimized animation with minimal redraws\n */\n\n/**\n * Color utilities for Canvas rendering\n * @namespace CanvasColors\n * @private\n */\nconst CanvasColors = {\n  /**\n   * Convert normalized RGBA array (0-1) to CSS color string\n   * @param {Array<number>} rgba - RGBA color values in 0-1 range\n   * @returns {string} CSS rgba color string\n   */\n  rgbaArrayToString(rgba) {\n    const r = Math.floor(rgba[0] * 255);\n    const g = Math.floor(rgba[1] * 255);\n    const b = Math.floor(rgba[2] * 255);\n    const a = rgba[3];\n    return `rgba(${r}, ${g}, ${b}, ${a})`;\n  },\n  /**\n   * Convert background color array to CSS color string\n   * @param {Array<number>} background - RGBA background color (0-1 range)\n   * @returns {string} CSS rgba color string\n   */\n  backgroundToString(background) {\n    return this.rgbaArrayToString(background);\n  },\n  /**\n   * Color schemes with CSS color string generation\n   */\n  schemes: {\n    // Spectrum (blue to red)\n    spectrum: value => {\n      const rgba = [Math.sin(value * Math.PI) * 0.5 + 0.5, Math.sin(value * Math.PI + Math.PI * 2 / 3) * 0.5 + 0.5, Math.sin(value * Math.PI + Math.PI * 4 / 3) * 0.5 + 0.5, 1.0];\n      return CanvasColors.rgbaArrayToString(rgba);\n    },\n    // Heatmap (blue to red)\n    heatmap: value => {\n      const rgba = [value, 0.2, 1.0 - value, 1.0];\n      return CanvasColors.rgbaArrayToString(rgba);\n    },\n    // Grayscale\n    grayscale: value => {\n      const v = Math.floor(value * 255);\n      return `rgba(${v}, ${v}, ${v}, 1.0)`;\n    },\n    // Rainbow\n    rainbow: value => {\n      const r = 0.5 + 0.5 * Math.sin(Math.PI * value);\n      const g = 0.5 + 0.5 * Math.sin(Math.PI * (value + 0.33));\n      const b = 0.5 + 0.5 * Math.sin(Math.PI * (value + 0.67));\n      return `rgba(${Math.floor(r * 255)}, ${Math.floor(g * 255)}, ${Math.floor(b * 255)}, 1.0)`;\n    },\n    // Monochromatic blue\n    blue: value => {\n      return `rgba(0, ${Math.floor(value * 127)}, ${Math.floor(127 + value * 128)}, 1.0)`;\n    },\n    // Monochromatic green\n    green: value => {\n      return `rgba(0, ${Math.floor(127 + value * 128)}, ${Math.floor(value * 77)}, 1.0)`;\n    },\n    // Viridis-inspired colormap (perceptually uniform)\n    viridis: value => {\n      // Approximation of the Viridis colormap\n      const x = value;\n      const r = Math.max(0, Math.min(1, 0.0 + 4.5 * x - 5.5 * x * x + 1.25 * x * x * x));\n      const g = Math.max(0, Math.min(1, 0.0 + 0.9 * x + 1.1 * x * x - 1.5 * x * x * x));\n      const b = Math.max(0, Math.min(1, 0.3 + 0.4 * x - 1.2 * x * x + 0.6 * x * x * x));\n      return `rgba(${Math.floor(r * 255)}, ${Math.floor(g * 255)}, ${Math.floor(b * 255)}, 1.0)`;\n    }\n  },\n  /**\n   * Get a color from a scheme\n   * @param {string} scheme - The name of the color scheme\n   * @param {number} value - Normalized value (0-1)\n   * @returns {string} CSS color string\n   */\n  getColor(scheme, value) {\n    const colorFn = this.schemes[scheme] || this.schemes.spectrum;\n    return colorFn(Math.max(0, Math.min(1, value)));\n  },\n  /**\n   * Get special highlight colors\n   * @param {string} type - Type of highlight ('highlight', 'comparing', 'sorted', 'read', 'write')\n   * @returns {string} CSS color string\n   */\n  getHighlightColor(type) {\n    switch (type) {\n      case 'highlight':\n        return 'rgba(255, 255, 0, 1.0)';\n      // Yellow\n      case 'comparing':\n        return 'rgba(255, 0, 0, 1.0)';\n      // Red\n      case 'sorted':\n        return 'rgba(0, 255, 0, 1.0)';\n      // Green\n      case 'read':\n        return 'rgba(0, 128, 255, 1.0)';\n      // Light blue\n      case 'write':\n        return 'rgba(255, 128, 0, 1.0)';\n      // Orange\n      default:\n        return 'rgba(255, 255, 255, 1.0)';\n      // White\n    }\n  }\n};\n\n/**\n * Easing functions for animations\n * @namespace Easings\n * @private\n */\nconst Easings = {\n  // Linear interpolation (no easing)\n  linear: t => t,\n  // Quadratic easing\n  easeInQuad: t => t * t,\n  easeOutQuad: t => t * (2 - t),\n  easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,\n  // Cubic easing\n  easeInCubic: t => t * t * t,\n  easeOutCubic: t => --t * t * t + 1,\n  easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,\n  // Elastic easing\n  easeOutElastic: t => {\n    const p = 0.3;\n    return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;\n  },\n  // Bounce easing\n  easeOutBounce: t => {\n    if (t < 1 / 2.75) {\n      return 7.5625 * t * t;\n    } else if (t < 2 / 2.75) {\n      return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n    } else if (t < 2.5 / 2.75) {\n      return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n    } else {\n      return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n    }\n  }\n};\n\n/**\n * Performance optimization strategies for Canvas rendering\n * @namespace RenderStrategies\n * @private\n */\nconst RenderStrategies = {\n  /**\n   * Strategy for small datasets (<= 500 elements)\n   * - Full rendering with rounded corners and shadows\n   * - Individual bar rendering with all visual effects\n   */\n  DETAILED: 'detailed',\n  /**\n   * Strategy for medium datasets (501-2000 elements)\n   * - Simplified rendering without shadows\n   * - Rectangular bars without rounded corners\n   * - Batch rendering with minimal state changes\n   */\n  OPTIMIZED: 'optimized',\n  /**\n   * Strategy for large datasets (2001-10000 elements)\n   * - Minimal visual effects\n   * - Direct pixel manipulation for maximum speed\n   * - Reduced animation complexity\n   */\n  PERFORMANCE: 'performance',\n  /**\n   * Determine the best strategy based on data size\n   * @param {number} dataSize - Number of elements to render\n   * @returns {string} The optimal rendering strategy\n   */\n  getBestStrategy(dataSize) {\n    if (dataSize <= 500) {\n      return this.DETAILED;\n    } else if (dataSize <= 2000) {\n      return this.OPTIMIZED;\n    } else {\n      return this.PERFORMANCE;\n    }\n  }\n};\n\n/**\n * @class ArrayRenderer\n * @description Canvas-based renderer for sorting algorithm visualization\n */\nclass ArrayRenderer {\n  /**\n   * Create a new Canvas renderer\n   * @param {HTMLCanvasElement} canvas - The canvas element to render to\n   * @param {Object} options - Configuration options\n   * @param {number} [options.maxElements=10000] - Maximum number of elements to render\n   * @param {number} [options.barWidth=4] - Width of each bar in pixels\n   * @param {number} [options.spacing=1] - Spacing between bars in pixels\n   * @param {string} [options.colorScheme='spectrum'] - Color scheme to use\n   * @param {Array<number>} [options.background=[0.1, 0.1, 0.1, 1.0]] - Background color (RGBA)\n   * @param {string|Array<number>} [options.highlightColor] - Color for highlighted elements\n   * @param {string|Array<number>} [options.comparingColor] - Color for elements being compared\n   * @param {string|Array<number>} [options.sortedColor] - Color for sorted elements\n   * @param {string|Array<number>} [options.readColor] - Color for elements being read\n   * @param {string|Array<number>} [options.writeColor] - Color for elements being written\n   * @param {number} [options.animationDuration=300] - Duration of animations in ms\n   * @param {string} [options.easingFunction='easeOutCubic'] - Easing function for animations\n   * @param {number} [options.effectMode=0] - Visual effect mode (0-3)\n   * @param {number} [options.amplitude=0.05] - Animation amplitude for effects\n   * @param {boolean} [options.usePixelManipulation=true] - Use direct pixel manipulation for large datasets\n   */\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n\n    // Store options with defaults\n    this.options = {\n      maxElements: 10000,\n      barWidth: 4,\n      spacing: 1,\n      colorScheme: 'spectrum',\n      background: [0.1, 0.1, 0.1, 1.0],\n      highlightColor: CanvasColors.getHighlightColor('highlight'),\n      comparingColor: CanvasColors.getHighlightColor('comparing'),\n      sortedColor: CanvasColors.getHighlightColor('sorted'),\n      readColor: CanvasColors.getHighlightColor('read'),\n      writeColor: CanvasColors.getHighlightColor('write'),\n      animationDuration: 300,\n      easingFunction: 'easeOutCubic',\n      effectMode: 0,\n      amplitude: 0.05,\n      usePixelManipulation: true,\n      ...options\n    };\n\n    // Get 2D context\n    this.ctx = canvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true // Potential performance optimization\n    });\n    if (!this.ctx) {\n      throw new Error('Failed to create Canvas 2D context.');\n    }\n\n    // Initialize renderer state\n    this.initRenderer();\n\n    // State for rendering\n    this.data = [];\n    this.originalData = [];\n    this.highlights = new Set();\n    this.comparing = new Set();\n    this.sortedIndices = new Set();\n    this.readIndices = new Set();\n    this.writeIndices = new Set();\n\n    // State for animation\n    this.positions = []; // Current positions of elements\n    this.targetPositions = []; // Target positions for animation\n    this.isAnimating = false;\n    this.animationStartTime = 0;\n    this.animationProgress = 0;\n\n    // ImageData optimization for large datasets\n    this.imageData = null;\n    this.renderStrategy = RenderStrategies.DETAILED;\n\n    // Renderer metrics\n    this.metrics = {\n      fps: 0,\n      renderTime: 0,\n      elementsRendered: 0,\n      renderStrategy: this.renderStrategy,\n      frameCount: 0\n    };\n\n    // Performance monitoring\n    this.lastFrameTime = 0;\n    this.frameCount = 0;\n    this.fpsUpdateInterval = 500; // ms\n    this.lastFpsUpdate = 0;\n  }\n\n  /**\n   * Initialize the Canvas renderer\n   * @private\n   */\n  initRenderer() {\n    // Convert background array to CSS color\n    const bgColor = CanvasColors.backgroundToString(this.options.background);\n\n    // Set initial canvas state\n    this.ctx.fillStyle = bgColor;\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Convert array colors to strings if needed\n    if (Array.isArray(this.options.highlightColor)) {\n      this.options.highlightColor = CanvasColors.rgbaArrayToString(this.options.highlightColor);\n    }\n    if (Array.isArray(this.options.comparingColor)) {\n      this.options.comparingColor = CanvasColors.rgbaArrayToString(this.options.comparingColor);\n    }\n    if (Array.isArray(this.options.sortedColor)) {\n      this.options.sortedColor = CanvasColors.rgbaArrayToString(this.options.sortedColor);\n    }\n    if (Array.isArray(this.options.readColor)) {\n      this.options.readColor = CanvasColors.rgbaArrayToString(this.options.readColor);\n    }\n    if (Array.isArray(this.options.writeColor)) {\n      this.options.writeColor = CanvasColors.rgbaArrayToString(this.options.writeColor);\n    }\n\n    // Initialize off-screen canvas for performance optimization\n    this.offscreenCanvas = document.createElement('canvas');\n    this.offscreenCanvas.width = this.canvas.width;\n    this.offscreenCanvas.height = this.canvas.height;\n    this.offscreenCtx = this.offscreenCanvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true\n    });\n  }\n\n  /**\n   * Set the data array to visualize\n   * @param {Array} data - Array of numerical values\n   * @param {boolean} [resetState=true] - Whether to reset visualization state\n   * @throws {Error} If data array exceeds maximum elements\n   */\n  setData(data, resetState = true) {\n    // Validate data\n    if (!Array.isArray(data)) {\n      throw new TypeError('Data must be an array.');\n    }\n\n    // Limit the number of elements to render\n    if (data.length > this.options.maxElements) {\n      console.warn(`Data array exceeds maximum elements (${this.options.maxElements}). Truncating.`);\n      data = data.slice(0, this.options.maxElements);\n    }\n\n    // Store data\n    this.data = [...data];\n\n    // Determine rendering strategy based on data size\n    this.renderStrategy = RenderStrategies.getBestStrategy(data.length);\n    this.metrics.renderStrategy = this.renderStrategy;\n\n    // Reset visualization state if needed\n    if (resetState) {\n      this.originalData = [...data];\n      this.highlights = new Set();\n      this.comparing = new Set();\n      this.sortedIndices = new Set();\n      this.readIndices = new Set();\n      this.writeIndices = new Set();\n\n      // Initialize positions for animation\n      this.positions = data.map((_, i) => i);\n      this.targetPositions = [...this.positions];\n    }\n\n    // Render the initial state\n    this.render(performance.now());\n  }\n\n  /**\n   * Highlight specific indices in the visualization\n   * @param {Array|Set} indices - Indices to highlight\n   */\n  highlight(indices) {\n    this.highlights = new Set(indices);\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n\n  /**\n   * Mark indices as being compared\n   * @param {Array|Set} indices - Indices being compared\n   */\n  markComparing(indices) {\n    this.comparing = new Set(indices);\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n\n  /**\n   * Mark indices as sorted\n   * @param {Array|Set} indices - Indices that are in sorted position\n   */\n  markSorted(indices) {\n    this.sortedIndices = new Set(indices);\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n\n  /**\n   * Mark indices as being read from\n   * @param {Array|Set} indices - Indices being read\n   */\n  markRead(indices) {\n    this.readIndices = new Set(indices);\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n\n  /**\n   * Mark indices as being written to\n   * @param {Array|Set} indices - Indices being written\n   */\n  markWrite(indices) {\n    this.writeIndices = new Set(indices);\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n\n  /**\n   * Swap two elements in the visualization with animation\n   * @param {number} i - First index\n   * @param {number} j - Second index\n   */\n  swap(i, j) {\n    // Swap data values\n    [this.data[i], this.data[j]] = [this.data[j], this.data[i]];\n\n    // Update target positions for animation\n    [this.targetPositions[i], this.targetPositions[j]] = [this.targetPositions[j], this.targetPositions[i]];\n\n    // Start animation if not already running\n    if (!this.isAnimating) {\n      this.startAnimation();\n    }\n  }\n\n  /**\n   * Update a single value in the array\n   * @param {number} index - Array index\n   * @param {number} value - New value\n   */\n  updateValue(index, value) {\n    this.data[index] = value;\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n\n  /**\n   * Start the animation sequence\n   * @private\n   */\n  startAnimation() {\n    this.isAnimating = true;\n    this.animationStartTime = performance.now();\n    this.animationProgress = 0;\n    this.requestAnimationFrame();\n  }\n\n  /**\n   * Request a new animation frame\n   * @private\n   */\n  requestAnimationFrame() {\n    requestAnimationFrame(timestamp => this.animate(timestamp));\n  }\n\n  /**\n   * Animate one frame of the visualization\n   * @param {number} timestamp - Current time from requestAnimationFrame\n   * @private\n   */\n  animate(timestamp) {\n    // Calculate elapsed time and animation progress\n    const elapsed = timestamp - this.animationStartTime;\n    this.animationProgress = Math.min(1, elapsed / this.options.animationDuration);\n\n    // Apply easing function\n    const easingFn = Easings[this.options.easingFunction] || Easings.linear;\n    const easedProgress = easingFn(this.animationProgress);\n\n    // Update element positions based on animation progress\n    for (let i = 0; i < this.positions.length; i++) {\n      this.positions[i] = this.lerp(this.positions[i], this.targetPositions[i], easedProgress);\n    }\n\n    // Render the frame\n    this.render(timestamp);\n\n    // Continue animation if not finished\n    if (this.animationProgress < 1) {\n      this.requestAnimationFrame();\n    } else {\n      // Animation complete\n      this.isAnimating = false;\n\n      // Snap to final positions\n      this.positions = [...this.targetPositions];\n      this.render(timestamp);\n    }\n  }\n\n  /**\n   * Render the current state of the visualization\n   * @param {number} timestamp - Current time\n   */\n  render(timestamp) {\n    const startTime = performance.now();\n    const ctx = this.ctx;\n    const {\n      barWidth,\n      spacing,\n      colorScheme,\n      background,\n      amplitude,\n      effectMode\n    } = this.options;\n\n    // Clear the canvas\n    ctx.fillStyle = CanvasColors.backgroundToString(background);\n    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Find the maximum value for scaling\n    const maxValue = Math.max(...this.data, 1); // Avoid division by zero\n\n    // Calculate available height accounting for potential animation amplitude\n    const availableHeight = this.canvas.height * 0.9; // Use 90% of canvas height\n    const maxAmplitude = this.canvas.height * 0.05 * amplitude;\n\n    // Choose rendering strategy based on data size and current strategy\n    switch (this.renderStrategy) {\n      case RenderStrategies.DETAILED:\n        this.renderDetailed(maxValue, availableHeight, maxAmplitude, timestamp, colorScheme);\n        break;\n      case RenderStrategies.OPTIMIZED:\n        this.renderOptimized(maxValue, availableHeight, maxAmplitude, timestamp, colorScheme);\n        break;\n      case RenderStrategies.PERFORMANCE:\n        if (this.options.usePixelManipulation && this.data.length > 5000) {\n          this.renderWithPixelManipulation(maxValue, availableHeight, colorScheme);\n        } else {\n          this.renderPerformance(maxValue, availableHeight, maxAmplitude, timestamp, colorScheme);\n        }\n        break;\n    }\n\n    // Update metrics\n    this.metrics.renderTime = performance.now() - startTime;\n    this.metrics.elementsRendered = this.data.length;\n    this.updateFPS(timestamp);\n  }\n\n  /**\n   * Render with detailed visuals for small datasets\n   * @param {number} maxValue - Maximum value in the dataset\n   * @param {number} availableHeight - Available height for rendering\n   * @param {number} maxAmplitude - Maximum amplitude for animations\n   * @param {number} timestamp - Current time\n   * @param {string} colorScheme - Color scheme to use\n   * @private\n   */\n  renderDetailed(maxValue, availableHeight, maxAmplitude, timestamp, colorScheme) {\n    const ctx = this.ctx;\n    const {\n      barWidth,\n      spacing\n    } = this.options;\n\n    // Enhanced rendering for small datasets\n    this.data.forEach((value, i) => {\n      const normValue = value / maxValue;\n      const height = normValue * availableHeight;\n\n      // Calculate position (using animation position)\n      const x = this.positions[i] * (barWidth + spacing);\n\n      // Apply subtle animation based on height and time\n      let wobble = 0;\n      if (this.options.effectMode !== 0) {\n        wobble = Math.sin(timestamp * 0.005 + i * 0.1) * maxAmplitude * normValue;\n      }\n\n      // Determine bar color based on state\n      let color;\n      if (this.comparing.has(i)) {\n        color = this.options.comparingColor;\n      } else if (this.highlights.has(i)) {\n        color = this.options.highlightColor;\n      } else if (this.sortedIndices.has(i)) {\n        color = this.options.sortedColor;\n      } else if (this.readIndices.has(i)) {\n        color = this.options.readColor;\n      } else if (this.writeIndices.has(i)) {\n        color = this.options.writeColor;\n      } else {\n        // Use color scheme for regular elements\n        color = CanvasColors.getColor(colorScheme, normValue);\n      }\n\n      // Draw bar with rounded corners\n      const barHeight = Math.max(1, height + wobble);\n      const cornerRadius = Math.min(2, barWidth / 2);\n      ctx.beginPath();\n      ctx.moveTo(x + cornerRadius, this.canvas.height);\n      ctx.lineTo(x + cornerRadius, this.canvas.height - barHeight + cornerRadius);\n      ctx.arc(x + cornerRadius, this.canvas.height - barHeight + cornerRadius, cornerRadius, Math.PI, 1.5 * Math.PI);\n      ctx.lineTo(x + barWidth - cornerRadius, this.canvas.height - barHeight);\n      ctx.arc(x + barWidth - cornerRadius, this.canvas.height - barHeight + cornerRadius, cornerRadius, 1.5 * Math.PI, 0);\n      ctx.lineTo(x + barWidth, this.canvas.height);\n      ctx.closePath();\n\n      // Fill with color\n      ctx.fillStyle = color;\n      ctx.fill();\n\n      // Add subtle shadow for 3D effect\n      if (barHeight > 5) {\n        ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';\n        ctx.shadowBlur = 2;\n        ctx.shadowOffsetX = 1;\n        ctx.shadowOffsetY = 1;\n        ctx.fill();\n\n        // Reset shadow\n        ctx.shadowColor = 'transparent';\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n\n      // Add a highlight effect on top for sorted elements\n      if (this.sortedIndices.has(i) && this.options.effectMode > 1) {\n        const gradient = ctx.createLinearGradient(x, this.canvas.height - barHeight, x, this.canvas.height);\n        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');\n        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      }\n    });\n  }\n\n  /**\n   * Render with optimized visuals for medium datasets\n   * @param {number} maxValue - Maximum value in the dataset\n   * @param {number} availableHeight - Available height for rendering\n   * @param {number} maxAmplitude - Maximum amplitude for animations\n   * @param {number} timestamp - Current time\n   * @param {string} colorScheme - Color scheme to use\n   * @private\n   */\n  renderOptimized(maxValue, availableHeight, maxAmplitude, timestamp, colorScheme) {\n    const ctx = this.ctx;\n    const {\n      barWidth,\n      spacing\n    } = this.options;\n\n    // Group elements by state for batch rendering\n    const groups = {\n      normal: [],\n      comparing: [],\n      highlighted: [],\n      sorted: [],\n      read: [],\n      write: []\n    };\n\n    // Categorize elements\n    this.data.forEach((value, i) => {\n      const normValue = value / maxValue;\n      const height = normValue * availableHeight;\n\n      // Calculate position (using animation position)\n      const x = this.positions[i] * (barWidth + spacing);\n\n      // Apply subtle animation based on height\n      let wobble = 0;\n      if (this.options.effectMode !== 0) {\n        wobble = Math.sin(timestamp * 0.005 + i * 0.1) * maxAmplitude * normValue;\n      }\n      const y = this.canvas.height - (height + wobble);\n\n      // Categorize by state\n      if (this.comparing.has(i)) {\n        groups.comparing.push({\n          x,\n          y,\n          width: barWidth,\n          height: height + wobble,\n          normValue\n        });\n      } else if (this.highlights.has(i)) {\n        groups.highlighted.push({\n          x,\n          y,\n          width: barWidth,\n          height: height + wobble,\n          normValue\n        });\n      } else if (this.sortedIndices.has(i)) {\n        groups.sorted.push({\n          x,\n          y,\n          width: barWidth,\n          height: height + wobble,\n          normValue\n        });\n      } else if (this.readIndices.has(i)) {\n        groups.read.push({\n          x,\n          y,\n          width: barWidth,\n          height: height + wobble,\n          normValue\n        });\n      } else if (this.writeIndices.has(i)) {\n        groups.write.push({\n          x,\n          y,\n          width: barWidth,\n          height: height + wobble,\n          normValue\n        });\n      } else {\n        groups.normal.push({\n          x,\n          y,\n          width: barWidth,\n          height: height + wobble,\n          normValue\n        });\n      }\n    });\n\n    // Render groups in batches for better performance\n\n    // Render normal elements (by color value for fewer state changes)\n    const colorMap = new Map();\n    groups.normal.forEach(elem => {\n      const color = CanvasColors.getColor(colorScheme, elem.normValue);\n      if (!colorMap.has(color)) {\n        colorMap.set(color, []);\n      }\n      colorMap.get(color).push(elem);\n    });\n    colorMap.forEach((elements, color) => {\n      ctx.fillStyle = color;\n      elements.forEach(elem => {\n        ctx.fillRect(elem.x, elem.y, elem.width, Math.max(1, elem.height));\n      });\n    });\n\n    // Render special state elements\n    this.renderElementGroup(ctx, groups.comparing, this.options.comparingColor);\n    this.renderElementGroup(ctx, groups.highlighted, this.options.highlightColor);\n    this.renderElementGroup(ctx, groups.sorted, this.options.sortedColor);\n    this.renderElementGroup(ctx, groups.read, this.options.readColor);\n    this.renderElementGroup(ctx, groups.write, this.options.writeColor);\n  }\n\n  /**\n   * Render element group with same color\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\n   * @param {Array} elements - Elements to render\n   * @param {string} color - Color to use\n   * @private\n   */\n  renderElementGroup(ctx, elements, color) {\n    if (elements.length === 0) return;\n    ctx.fillStyle = color;\n    elements.forEach(elem => {\n      ctx.fillRect(elem.x, elem.y, elem.width, Math.max(1, elem.height));\n    });\n  }\n\n  /**\n   * Render with minimal visual effects for large datasets\n   * @param {number} maxValue - Maximum value in the dataset\n   * @param {number} availableHeight - Available height for rendering\n   * @param {number} maxAmplitude - Maximum amplitude for animations\n   * @param {number} timestamp - Current time\n   * @param {string} colorScheme - Color scheme to use\n   * @private\n   */\n  renderPerformance(maxValue, availableHeight, maxAmplitude, timestamp, colorScheme) {\n    const ctx = this.ctx;\n    const {\n      barWidth,\n      spacing\n    } = this.options;\n    const totalWidth = barWidth + spacing;\n\n    // Pre-calculate to avoid redundant calculations in loop\n    const baseY = this.canvas.height;\n    const heightFactor = availableHeight / maxValue;\n\n    // Use path batching for fewer draw calls\n\n    // Draw normal elements in a single path\n    const specialIndices = new Set([...this.comparing, ...this.highlights, ...this.sortedIndices, ...this.readIndices, ...this.writeIndices]);\n\n    // Group elements by color value ranges to reduce state changes\n    const colorRanges = [{\n      min: 0.0,\n      max: 0.2,\n      elements: []\n    }, {\n      min: 0.2,\n      max: 0.4,\n      elements: []\n    }, {\n      min: 0.4,\n      max: 0.6,\n      elements: []\n    }, {\n      min: 0.6,\n      max: 0.8,\n      elements: []\n    }, {\n      min: 0.8,\n      max: 1.0,\n      elements: []\n    }];\n\n    // Categorize normal elements by value range\n    this.data.forEach((value, i) => {\n      if (specialIndices.has(i)) return;\n      const normValue = value / maxValue;\n      const range = colorRanges.find(r => normValue >= r.min && normValue < r.max);\n      if (range) {\n        range.elements.push({\n          index: i,\n          normValue: normValue,\n          x: this.positions[i] * totalWidth,\n          height: value * heightFactor\n        });\n      }\n    });\n\n    // Render normal elements by color range\n    colorRanges.forEach(range => {\n      if (range.elements.length === 0) return;\n\n      // Get color for this range\n      const avgValue = (range.min + range.max) / 2;\n      ctx.fillStyle = CanvasColors.getColor(colorScheme, avgValue);\n\n      // Draw all elements in this range at once\n      range.elements.forEach(elem => {\n        const barHeight = Math.max(1, elem.height);\n        ctx.fillRect(elem.x, baseY - barHeight, barWidth, barHeight);\n      });\n    });\n\n    // Draw special state elements\n    this.renderSpecialStates(baseY, heightFactor, totalWidth, barWidth, maxValue, colorScheme);\n  }\n\n  /**\n   * Render elements with special states\n   * @param {number} baseY - Base Y position\n   * @param {number} heightFactor - Factor to convert values to heights\n   * @param {number} totalWidth - Total width of each element\n   * @param {number} barWidth - Width of each bar\n   * @param {number} maxValue - Maximum value\n   * @param {string} colorScheme - Color scheme\n   * @private\n   */\n  renderSpecialStates(baseY, heightFactor, totalWidth, barWidth, maxValue, colorScheme) {\n    const ctx = this.ctx;\n\n    // Comparing elements\n    if (this.comparing.size > 0) {\n      ctx.fillStyle = this.options.comparingColor;\n      this.comparing.forEach(i => {\n        const value = this.data[i];\n        const barHeight = Math.max(1, value * heightFactor);\n        const x = this.positions[i] * totalWidth;\n        ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);\n      });\n    }\n\n    // Highlighted elements\n    if (this.highlights.size > 0) {\n      ctx.fillStyle = this.options.highlightColor;\n      this.highlights.forEach(i => {\n        const value = this.data[i];\n        const barHeight = Math.max(1, value * heightFactor);\n        const x = this.positions[i] * totalWidth;\n        ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);\n      });\n    }\n\n    // Sorted elements\n    if (this.sortedIndices.size > 0) {\n      ctx.fillStyle = this.options.sortedColor;\n      this.sortedIndices.forEach(i => {\n        const value = this.data[i];\n        const barHeight = Math.max(1, value * heightFactor);\n        const x = this.positions[i] * totalWidth;\n        ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);\n      });\n    }\n\n    // Read elements\n    if (this.readIndices.size > 0) {\n      ctx.fillStyle = this.options.readColor;\n      this.readIndices.forEach(i => {\n        const value = this.data[i];\n        const barHeight = Math.max(1, value * heightFactor);\n        const x = this.positions[i] * totalWidth;\n        ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);\n      });\n    }\n\n    // Write elements\n    if (this.writeIndices.size > 0) {\n      ctx.fillStyle = this.options.writeColor;\n      this.writeIndices.forEach(i => {\n        const value = this.data[i];\n        const barHeight = Math.max(1, value * heightFactor);\n        const x = this.positions[i] * totalWidth;\n        ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);\n      });\n    }\n  }\n\n  /**\n   * Render using direct pixel manipulation for large datasets\n   * @param {number} maxValue - Maximum value in the dataset\n   * @param {number} availableHeight - Available height for rendering\n   * @param {string} colorScheme - Color scheme to use\n   * @private\n   */\n  renderWithPixelManipulation(maxValue, availableHeight, colorScheme) {\n    // This is the most performant but least visually appealing rendering method\n    const {\n      barWidth,\n      spacing\n    } = this.options;\n    const totalWidth = barWidth + spacing;\n\n    // Create or reuse ImageData\n    if (!this.imageData || this.imageData.width !== this.canvas.width || this.imageData.height !== this.canvas.height) {\n      this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);\n    }\n    const data = this.imageData.data;\n    const width = this.canvas.width;\n    const height = this.canvas.height;\n\n    // Clear the image data\n    for (let i = 0; i < data.length; i += 4) {\n      data[i] = Math.floor(this.options.background[0] * 255); // R\n      data[i + 1] = Math.floor(this.options.background[1] * 255); // G\n      data[i + 2] = Math.floor(this.options.background[2] * 255); // B\n      data[i + 3] = Math.floor(this.options.background[3] * 255); // A\n    }\n\n    // Calculate the normalization factor\n    const heightFactor = availableHeight / maxValue;\n\n    // Draw the bars directly into the image data\n    this.data.forEach((value, i) => {\n      const normValue = value / maxValue;\n      const barHeight = Math.max(1, Math.floor(value * heightFactor));\n      const xPos = Math.floor(this.positions[i] * totalWidth);\n\n      // Skip if out of bounds\n      if (xPos + barWidth >= width || xPos < 0) return;\n\n      // Determine bar color\n      let color;\n      if (this.comparing.has(i)) {\n        color = [255, 0, 0, 255]; // Red for comparing\n      } else if (this.highlights.has(i)) {\n        color = [255, 255, 0, 255]; // Yellow for highlights\n      } else if (this.sortedIndices.has(i)) {\n        color = [0, 255, 0, 255]; // Green for sorted\n      } else if (this.readIndices.has(i)) {\n        color = [0, 128, 255, 255]; // Light blue for read\n      } else if (this.writeIndices.has(i)) {\n        color = [255, 128, 0, 255]; // Orange for write\n      } else {\n        // Parse color scheme\n        const rgbaColor = CanvasColors.getColor(colorScheme, normValue);\n        const match = rgbaColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)/);\n        if (match) {\n          color = [parseInt(match[1]),\n          // R\n          parseInt(match[2]),\n          // G\n          parseInt(match[3]),\n          // B\n          match[4] ? Math.floor(parseFloat(match[4]) * 255) : 255 // A\n          ];\n        } else {\n          color = [100, 100, 100, 255]; // Default gray\n        }\n      }\n\n      // Fill the bar by setting individual pixels\n      for (let x = 0; x < barWidth; x++) {\n        const xCoord = xPos + x;\n        if (xCoord >= width) continue;\n        for (let y = 0; y < barHeight; y++) {\n          const yCoord = height - y - 1;\n          if (yCoord < 0 || yCoord >= height) continue;\n          const pixelIndex = (yCoord * width + xCoord) * 4;\n          data[pixelIndex] = color[0]; // R\n          data[pixelIndex + 1] = color[1]; // G\n          data[pixelIndex + 2] = color[2]; // B\n          data[pixelIndex + 3] = color[3]; // A\n        }\n      }\n    });\n\n    // Put the image data back to the canvas\n    this.ctx.putImageData(this.imageData, 0, 0);\n  }\n\n  /**\n   * Update FPS calculation\n   * @param {number} timestamp - Current time\n   * @private\n   */\n  updateFPS(timestamp) {\n    // Count frames\n    this.frameCount++;\n\n    // Update FPS every interval\n    if (timestamp - this.lastFpsUpdate >= this.fpsUpdateInterval) {\n      const elapsed = timestamp - this.lastFpsUpdate;\n      this.metrics.fps = Math.round(this.frameCount * 1000 / elapsed);\n      this.lastFpsUpdate = timestamp;\n      this.frameCount = 0;\n    }\n  }\n\n  /**\n   * Resize the renderer to match canvas size\n   */\n  resize() {\n    // Get canvas display size\n    const displayWidth = this.canvas.clientWidth;\n    const displayHeight = this.canvas.clientHeight;\n\n    // Check if canvas size has changed\n    if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {\n      // Update canvas size to match display size\n      this.canvas.width = displayWidth;\n      this.canvas.height = displayHeight;\n\n      // Update offscreen canvas\n      this.offscreenCanvas.width = displayWidth;\n      this.offscreenCanvas.height = displayHeight;\n\n      // Clear image data cache\n      this.imageData = null;\n\n      // Redraw\n      this.render(performance.now());\n    }\n  }\n\n  /**\n   * Set renderer options\n   * @param {Object} options - New options to apply\n   */\n  setOptions(options) {\n    // Update options\n    this.options = {\n      ...this.options,\n      ...options\n    };\n\n    // Convert array colors to strings if needed\n    if (options.background) {\n      if (Array.isArray(options.background)) {\n        options.background = CanvasColors.backgroundToString(options.background);\n      }\n    }\n    if (options.highlightColor && Array.isArray(options.highlightColor)) {\n      options.highlightColor = CanvasColors.rgbaArrayToString(options.highlightColor);\n    }\n    if (options.comparingColor && Array.isArray(options.comparingColor)) {\n      options.comparingColor = CanvasColors.rgbaArrayToString(options.comparingColor);\n    }\n    if (options.sortedColor && Array.isArray(options.sortedColor)) {\n      options.sortedColor = CanvasColors.rgbaArrayToString(options.sortedColor);\n    }\n    if (options.readColor && Array.isArray(options.readColor)) {\n      options.readColor = CanvasColors.rgbaArrayToString(options.readColor);\n    }\n    if (options.writeColor && Array.isArray(options.writeColor)) {\n      options.writeColor = CanvasColors.rgbaArrayToString(options.writeColor);\n    }\n\n    // Redraw if needed\n    if (options.colorScheme || options.barWidth || options.spacing || options.background || options.highlightColor || options.comparingColor || options.sortedColor || options.readColor || options.writeColor) {\n      this.render(performance.now());\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose() {\n    // Clear references\n    this.data = [];\n    this.originalData = [];\n    this.positions = [];\n    this.targetPositions = [];\n\n    // Clear image data\n    this.imageData = null;\n    this.offscreenCanvas = null;\n    this.offscreenCtx = null;\n\n    // Clear render state\n    this.highlights = new Set();\n    this.comparing = new Set();\n    this.sortedIndices = new Set();\n    this.readIndices = new Set();\n    this.writeIndices = new Set();\n  }\n\n  /**\n   * Get current performance metrics\n   * @returns {Object} Performance metrics object\n   */\n  getMetrics() {\n    return {\n      ...this.metrics\n    };\n  }\n\n  /**\n   * Reset the visualization to original data\n   */\n  reset() {\n    this.data = [...this.originalData];\n    this.highlights = new Set();\n    this.comparing = new Set();\n    this.sortedIndices = new Set();\n    this.readIndices = new Set();\n    this.writeIndices = new Set();\n    this.positions = this.data.map((_, i) => i);\n    this.targetPositions = [...this.positions];\n    this.render(performance.now());\n  }\n\n  /**\n   * Linear interpolation between two values\n   * @param {number} a - Start value\n   * @param {number} b - End value\n   * @param {number} t - Interpolation factor (0-1)\n   * @returns {number} Interpolated value\n   * @private\n   */\n  lerp(a, b, t) {\n    return a + (b - a) * t;\n  }\n\n  /**\n   * Get an image of the current visualization state\n   * @returns {string} Data URL of the image\n   */\n  getImageData() {\n    return this.canvas.toDataURL('image/png');\n  }\n\n  /**\n   * Toggle animation amplitude\n   * @param {number} amplitude - Animation amplitude (0-1)\n   */\n  setAmplitude(amplitude) {\n    this.options.amplitude = Math.max(0, Math.min(1, amplitude));\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n\n  /**\n   * Set visual effect mode\n   * @param {number} mode - Effect mode (0: none, 1: basic, 2: enhanced)\n   */\n  setEffectMode(mode) {\n    this.options.effectMode = mode;\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n}\nexport { ArrayRenderer };","map":{"version":3,"names":["CanvasColors","rgbaArrayToString","rgba","r","Math","floor","g","b","a","backgroundToString","background","schemes","spectrum","value","sin","PI","heatmap","grayscale","v","rainbow","blue","green","viridis","x","max","min","getColor","scheme","colorFn","getHighlightColor","type","Easings","linear","t","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeOutElastic","p","pow","easeOutBounce","RenderStrategies","DETAILED","OPTIMIZED","PERFORMANCE","getBestStrategy","dataSize","ArrayRenderer","constructor","canvas","options","maxElements","barWidth","spacing","colorScheme","highlightColor","comparingColor","sortedColor","readColor","writeColor","animationDuration","easingFunction","effectMode","amplitude","usePixelManipulation","ctx","getContext","alpha","desynchronized","Error","initRenderer","data","originalData","highlights","Set","comparing","sortedIndices","readIndices","writeIndices","positions","targetPositions","isAnimating","animationStartTime","animationProgress","imageData","renderStrategy","metrics","fps","renderTime","elementsRendered","frameCount","lastFrameTime","fpsUpdateInterval","lastFpsUpdate","bgColor","fillStyle","fillRect","width","height","Array","isArray","offscreenCanvas","document","createElement","offscreenCtx","setData","resetState","TypeError","length","console","warn","slice","map","_","i","render","performance","now","highlight","indices","markComparing","markSorted","markRead","markWrite","swap","j","startAnimation","updateValue","index","requestAnimationFrame","timestamp","animate","elapsed","easingFn","easedProgress","lerp","startTime","maxValue","availableHeight","maxAmplitude","renderDetailed","renderOptimized","renderWithPixelManipulation","renderPerformance","updateFPS","forEach","normValue","wobble","color","has","barHeight","cornerRadius","beginPath","moveTo","lineTo","arc","closePath","fill","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","gradient","createLinearGradient","addColorStop","groups","normal","highlighted","sorted","read","write","y","push","colorMap","Map","elem","set","get","elements","renderElementGroup","totalWidth","baseY","heightFactor","specialIndices","colorRanges","range","find","avgValue","renderSpecialStates","size","createImageData","xPos","rgbaColor","match","parseInt","parseFloat","xCoord","yCoord","pixelIndex","putImageData","round","resize","displayWidth","clientWidth","displayHeight","clientHeight","setOptions","dispose","getMetrics","reset","getImageData","toDataURL","setAmplitude","setEffectMode","mode"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/visualization/renderers/array-renderer.js"],"sourcesContent":["// src/visualization/renderers/array-renderer.js\n\n/**\n * @file Canvas-based renderer for algorithm visualization\n * @author Algorithm Visualization Platform Team\n * @version 2.0.0\n * \n * @description\n * Canvas-based renderer that provides a fallback when WebGL isn't supported.\n * This implementation uses the standard Canvas 2D API to render visualization\n * elements with a focus on compatibility, correctness, and reasonable performance\n * for moderate dataset sizes (up to ~10,000 elements).\n * \n * The renderer implements the same interface as the WebGL renderer to ensure\n * seamless fallback, while optimizing Canvas-specific rendering techniques\n * for maximum possible performance within the constraints of the 2D context.\n * \n * Performance characteristics:\n * - Time complexity: O(n) for rendering n elements\n * - Space complexity: O(n) for state tracking\n * - Rendering performance: ~60fps for up to 1,000 elements on most devices\n *                          ~30fps for 1,000-5,000 elements\n *                          ~10-15fps for 5,000-10,000 elements\n * \n * Features:\n * - Identical API to WebGL renderer for simple substitution\n * - Performance optimizations specific to Canvas rendering\n * - Multiple rendering strategies based on data size\n * - Canvas-specific color handling and transformations\n * - Optimized animation with minimal redraws\n */\n\n/**\n * Color utilities for Canvas rendering\n * @namespace CanvasColors\n * @private\n */\nconst CanvasColors = {\n  /**\n   * Convert normalized RGBA array (0-1) to CSS color string\n   * @param {Array<number>} rgba - RGBA color values in 0-1 range\n   * @returns {string} CSS rgba color string\n   */\n  rgbaArrayToString(rgba) {\n    const r = Math.floor(rgba[0] * 255);\n    const g = Math.floor(rgba[1] * 255);\n    const b = Math.floor(rgba[2] * 255);\n    const a = rgba[3];\n    return `rgba(${r}, ${g}, ${b}, ${a})`;\n  },\n  \n  /**\n   * Convert background color array to CSS color string\n   * @param {Array<number>} background - RGBA background color (0-1 range)\n   * @returns {string} CSS rgba color string\n   */\n  backgroundToString(background) {\n    return this.rgbaArrayToString(background);\n  },\n  \n  /**\n   * Color schemes with CSS color string generation\n   */\n  schemes: {\n    // Spectrum (blue to red)\n    spectrum: (value) => {\n      const rgba = [\n        Math.sin(value * Math.PI) * 0.5 + 0.5,\n        Math.sin(value * Math.PI + Math.PI * 2/3) * 0.5 + 0.5,\n        Math.sin(value * Math.PI + Math.PI * 4/3) * 0.5 + 0.5,\n        1.0\n      ];\n      return CanvasColors.rgbaArrayToString(rgba);\n    },\n    \n    // Heatmap (blue to red)\n    heatmap: (value) => {\n      const rgba = [value, 0.2, 1.0 - value, 1.0];\n      return CanvasColors.rgbaArrayToString(rgba);\n    },\n    \n    // Grayscale\n    grayscale: (value) => {\n      const v = Math.floor(value * 255);\n      return `rgba(${v}, ${v}, ${v}, 1.0)`;\n    },\n    \n    // Rainbow\n    rainbow: (value) => {\n      const r = 0.5 + 0.5 * Math.sin(Math.PI * value);\n      const g = 0.5 + 0.5 * Math.sin(Math.PI * (value + 0.33));\n      const b = 0.5 + 0.5 * Math.sin(Math.PI * (value + 0.67));\n      return `rgba(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)}, 1.0)`;\n    },\n    \n    // Monochromatic blue\n    blue: (value) => {\n      return `rgba(0, ${Math.floor(value * 127)}, ${Math.floor(127 + value * 128)}, 1.0)`;\n    },\n    \n    // Monochromatic green\n    green: (value) => {\n      return `rgba(0, ${Math.floor(127 + value * 128)}, ${Math.floor(value * 77)}, 1.0)`;\n    },\n    \n    // Viridis-inspired colormap (perceptually uniform)\n    viridis: (value) => {\n      // Approximation of the Viridis colormap\n      const x = value;\n      const r = Math.max(0, Math.min(1, (0.0 + 4.5 * x - 5.5 * x * x + 1.25 * x * x * x)));\n      const g = Math.max(0, Math.min(1, (0.0 + 0.9 * x + 1.1 * x * x - 1.5 * x * x * x)));\n      const b = Math.max(0, Math.min(1, (0.3 + 0.4 * x - 1.2 * x * x + 0.6 * x * x * x)));\n      return `rgba(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)}, 1.0)`;\n    }\n  },\n  \n  /**\n   * Get a color from a scheme\n   * @param {string} scheme - The name of the color scheme\n   * @param {number} value - Normalized value (0-1)\n   * @returns {string} CSS color string\n   */\n  getColor(scheme, value) {\n    const colorFn = this.schemes[scheme] || this.schemes.spectrum;\n    return colorFn(Math.max(0, Math.min(1, value)));\n  },\n  \n  /**\n   * Get special highlight colors\n   * @param {string} type - Type of highlight ('highlight', 'comparing', 'sorted', 'read', 'write')\n   * @returns {string} CSS color string\n   */\n  getHighlightColor(type) {\n    switch (type) {\n      case 'highlight':\n        return 'rgba(255, 255, 0, 1.0)'; // Yellow\n      case 'comparing':\n        return 'rgba(255, 0, 0, 1.0)';   // Red\n      case 'sorted':\n        return 'rgba(0, 255, 0, 1.0)';   // Green\n      case 'read':\n        return 'rgba(0, 128, 255, 1.0)'; // Light blue\n      case 'write':\n        return 'rgba(255, 128, 0, 1.0)'; // Orange\n      default:\n        return 'rgba(255, 255, 255, 1.0)'; // White\n    }\n  }\n};\n\n/**\n * Easing functions for animations\n * @namespace Easings\n * @private\n */\nconst Easings = {\n  // Linear interpolation (no easing)\n  linear: (t) => t,\n  \n  // Quadratic easing\n  easeInQuad: (t) => t * t,\n  easeOutQuad: (t) => t * (2 - t),\n  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,\n  \n  // Cubic easing\n  easeInCubic: (t) => t * t * t,\n  easeOutCubic: (t) => (--t) * t * t + 1,\n  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,\n  \n  // Elastic easing\n  easeOutElastic: (t) => {\n    const p = 0.3;\n    return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;\n  },\n  \n  // Bounce easing\n  easeOutBounce: (t) => {\n    if (t < (1 / 2.75)) {\n      return 7.5625 * t * t;\n    } else if (t < (2 / 2.75)) {\n      return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\n    } else if (t < (2.5 / 2.75)) {\n      return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\n    } else {\n      return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\n    }\n  }\n};\n\n/**\n * Performance optimization strategies for Canvas rendering\n * @namespace RenderStrategies\n * @private\n */\nconst RenderStrategies = {\n  /**\n   * Strategy for small datasets (<= 500 elements)\n   * - Full rendering with rounded corners and shadows\n   * - Individual bar rendering with all visual effects\n   */\n  DETAILED: 'detailed',\n  \n  /**\n   * Strategy for medium datasets (501-2000 elements)\n   * - Simplified rendering without shadows\n   * - Rectangular bars without rounded corners\n   * - Batch rendering with minimal state changes\n   */\n  OPTIMIZED: 'optimized',\n  \n  /**\n   * Strategy for large datasets (2001-10000 elements)\n   * - Minimal visual effects\n   * - Direct pixel manipulation for maximum speed\n   * - Reduced animation complexity\n   */\n  PERFORMANCE: 'performance',\n  \n  /**\n   * Determine the best strategy based on data size\n   * @param {number} dataSize - Number of elements to render\n   * @returns {string} The optimal rendering strategy\n   */\n  getBestStrategy(dataSize) {\n    if (dataSize <= 500) {\n      return this.DETAILED;\n    } else if (dataSize <= 2000) {\n      return this.OPTIMIZED;\n    } else {\n      return this.PERFORMANCE;\n    }\n  }\n};\n\n/**\n * @class ArrayRenderer\n * @description Canvas-based renderer for sorting algorithm visualization\n */\nclass ArrayRenderer {\n  /**\n   * Create a new Canvas renderer\n   * @param {HTMLCanvasElement} canvas - The canvas element to render to\n   * @param {Object} options - Configuration options\n   * @param {number} [options.maxElements=10000] - Maximum number of elements to render\n   * @param {number} [options.barWidth=4] - Width of each bar in pixels\n   * @param {number} [options.spacing=1] - Spacing between bars in pixels\n   * @param {string} [options.colorScheme='spectrum'] - Color scheme to use\n   * @param {Array<number>} [options.background=[0.1, 0.1, 0.1, 1.0]] - Background color (RGBA)\n   * @param {string|Array<number>} [options.highlightColor] - Color for highlighted elements\n   * @param {string|Array<number>} [options.comparingColor] - Color for elements being compared\n   * @param {string|Array<number>} [options.sortedColor] - Color for sorted elements\n   * @param {string|Array<number>} [options.readColor] - Color for elements being read\n   * @param {string|Array<number>} [options.writeColor] - Color for elements being written\n   * @param {number} [options.animationDuration=300] - Duration of animations in ms\n   * @param {string} [options.easingFunction='easeOutCubic'] - Easing function for animations\n   * @param {number} [options.effectMode=0] - Visual effect mode (0-3)\n   * @param {number} [options.amplitude=0.05] - Animation amplitude for effects\n   * @param {boolean} [options.usePixelManipulation=true] - Use direct pixel manipulation for large datasets\n   */\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    \n    // Store options with defaults\n    this.options = {\n      maxElements: 10000,\n      barWidth: 4,\n      spacing: 1,\n      colorScheme: 'spectrum',\n      background: [0.1, 0.1, 0.1, 1.0],\n      highlightColor: CanvasColors.getHighlightColor('highlight'),\n      comparingColor: CanvasColors.getHighlightColor('comparing'),\n      sortedColor: CanvasColors.getHighlightColor('sorted'),\n      readColor: CanvasColors.getHighlightColor('read'),\n      writeColor: CanvasColors.getHighlightColor('write'),\n      animationDuration: 300,\n      easingFunction: 'easeOutCubic',\n      effectMode: 0,\n      amplitude: 0.05,\n      usePixelManipulation: true,\n      ...options\n    };\n    \n    // Get 2D context\n    this.ctx = canvas.getContext('2d', { \n      alpha: true,\n      desynchronized: true // Potential performance optimization\n    });\n    \n    if (!this.ctx) {\n      throw new Error('Failed to create Canvas 2D context.');\n    }\n    \n    // Initialize renderer state\n    this.initRenderer();\n    \n    // State for rendering\n    this.data = [];\n    this.originalData = [];\n    this.highlights = new Set();\n    this.comparing = new Set();\n    this.sortedIndices = new Set();\n    this.readIndices = new Set();\n    this.writeIndices = new Set();\n    \n    // State for animation\n    this.positions = [];      // Current positions of elements\n    this.targetPositions = []; // Target positions for animation\n    this.isAnimating = false;\n    this.animationStartTime = 0;\n    this.animationProgress = 0;\n    \n    // ImageData optimization for large datasets\n    this.imageData = null;\n    this.renderStrategy = RenderStrategies.DETAILED;\n    \n    // Renderer metrics\n    this.metrics = {\n      fps: 0,\n      renderTime: 0,\n      elementsRendered: 0,\n      renderStrategy: this.renderStrategy,\n      frameCount: 0\n    };\n    \n    // Performance monitoring\n    this.lastFrameTime = 0;\n    this.frameCount = 0;\n    this.fpsUpdateInterval = 500; // ms\n    this.lastFpsUpdate = 0;\n  }\n  \n  /**\n   * Initialize the Canvas renderer\n   * @private\n   */\n  initRenderer() {\n    // Convert background array to CSS color\n    const bgColor = CanvasColors.backgroundToString(this.options.background);\n    \n    // Set initial canvas state\n    this.ctx.fillStyle = bgColor;\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    // Convert array colors to strings if needed\n    if (Array.isArray(this.options.highlightColor)) {\n      this.options.highlightColor = CanvasColors.rgbaArrayToString(this.options.highlightColor);\n    }\n    \n    if (Array.isArray(this.options.comparingColor)) {\n      this.options.comparingColor = CanvasColors.rgbaArrayToString(this.options.comparingColor);\n    }\n    \n    if (Array.isArray(this.options.sortedColor)) {\n      this.options.sortedColor = CanvasColors.rgbaArrayToString(this.options.sortedColor);\n    }\n    \n    if (Array.isArray(this.options.readColor)) {\n      this.options.readColor = CanvasColors.rgbaArrayToString(this.options.readColor);\n    }\n    \n    if (Array.isArray(this.options.writeColor)) {\n      this.options.writeColor = CanvasColors.rgbaArrayToString(this.options.writeColor);\n    }\n    \n    // Initialize off-screen canvas for performance optimization\n    this.offscreenCanvas = document.createElement('canvas');\n    this.offscreenCanvas.width = this.canvas.width;\n    this.offscreenCanvas.height = this.canvas.height;\n    this.offscreenCtx = this.offscreenCanvas.getContext('2d', {\n      alpha: true,\n      desynchronized: true\n    });\n  }\n  \n  /**\n   * Set the data array to visualize\n   * @param {Array} data - Array of numerical values\n   * @param {boolean} [resetState=true] - Whether to reset visualization state\n   * @throws {Error} If data array exceeds maximum elements\n   */\n  setData(data, resetState = true) {\n    // Validate data\n    if (!Array.isArray(data)) {\n      throw new TypeError('Data must be an array.');\n    }\n    \n    // Limit the number of elements to render\n    if (data.length > this.options.maxElements) {\n      console.warn(`Data array exceeds maximum elements (${this.options.maxElements}). Truncating.`);\n      data = data.slice(0, this.options.maxElements);\n    }\n    \n    // Store data\n    this.data = [...data];\n    \n    // Determine rendering strategy based on data size\n    this.renderStrategy = RenderStrategies.getBestStrategy(data.length);\n    this.metrics.renderStrategy = this.renderStrategy;\n    \n    // Reset visualization state if needed\n    if (resetState) {\n      this.originalData = [...data];\n      this.highlights = new Set();\n      this.comparing = new Set();\n      this.sortedIndices = new Set();\n      this.readIndices = new Set();\n      this.writeIndices = new Set();\n      \n      // Initialize positions for animation\n      this.positions = data.map((_, i) => i);\n      this.targetPositions = [...this.positions];\n    }\n    \n    // Render the initial state\n    this.render(performance.now());\n  }\n  \n  /**\n   * Highlight specific indices in the visualization\n   * @param {Array|Set} indices - Indices to highlight\n   */\n  highlight(indices) {\n    this.highlights = new Set(indices);\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n  \n  /**\n   * Mark indices as being compared\n   * @param {Array|Set} indices - Indices being compared\n   */\n  markComparing(indices) {\n    this.comparing = new Set(indices);\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n  \n  /**\n   * Mark indices as sorted\n   * @param {Array|Set} indices - Indices that are in sorted position\n   */\n  markSorted(indices) {\n    this.sortedIndices = new Set(indices);\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n  \n  /**\n   * Mark indices as being read from\n   * @param {Array|Set} indices - Indices being read\n   */\n  markRead(indices) {\n    this.readIndices = new Set(indices);\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n  \n  /**\n   * Mark indices as being written to\n   * @param {Array|Set} indices - Indices being written\n   */\n  markWrite(indices) {\n    this.writeIndices = new Set(indices);\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n  \n  /**\n   * Swap two elements in the visualization with animation\n   * @param {number} i - First index\n   * @param {number} j - Second index\n   */\n  swap(i, j) {\n    // Swap data values\n    [this.data[i], this.data[j]] = [this.data[j], this.data[i]];\n    \n    // Update target positions for animation\n    [this.targetPositions[i], this.targetPositions[j]] = [this.targetPositions[j], this.targetPositions[i]];\n    \n    // Start animation if not already running\n    if (!this.isAnimating) {\n      this.startAnimation();\n    }\n  }\n  \n  /**\n   * Update a single value in the array\n   * @param {number} index - Array index\n   * @param {number} value - New value\n   */\n  updateValue(index, value) {\n    this.data[index] = value;\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n  \n  /**\n   * Start the animation sequence\n   * @private\n   */\n  startAnimation() {\n    this.isAnimating = true;\n    this.animationStartTime = performance.now();\n    this.animationProgress = 0;\n    this.requestAnimationFrame();\n  }\n  \n  /**\n   * Request a new animation frame\n   * @private\n   */\n  requestAnimationFrame() {\n    requestAnimationFrame((timestamp) => this.animate(timestamp));\n  }\n  \n  /**\n   * Animate one frame of the visualization\n   * @param {number} timestamp - Current time from requestAnimationFrame\n   * @private\n   */\n  animate(timestamp) {\n    // Calculate elapsed time and animation progress\n    const elapsed = timestamp - this.animationStartTime;\n    this.animationProgress = Math.min(1, elapsed / this.options.animationDuration);\n    \n    // Apply easing function\n    const easingFn = Easings[this.options.easingFunction] || Easings.linear;\n    const easedProgress = easingFn(this.animationProgress);\n    \n    // Update element positions based on animation progress\n    for (let i = 0; i < this.positions.length; i++) {\n      this.positions[i] = this.lerp(\n        this.positions[i],\n        this.targetPositions[i],\n        easedProgress\n      );\n    }\n    \n    // Render the frame\n    this.render(timestamp);\n    \n    // Continue animation if not finished\n    if (this.animationProgress < 1) {\n      this.requestAnimationFrame();\n    } else {\n      // Animation complete\n      this.isAnimating = false;\n      \n      // Snap to final positions\n      this.positions = [...this.targetPositions];\n      this.render(timestamp);\n    }\n  }\n  \n  /**\n   * Render the current state of the visualization\n   * @param {number} timestamp - Current time\n   */\n  render(timestamp) {\n    const startTime = performance.now();\n    const ctx = this.ctx;\n    const { barWidth, spacing, colorScheme, background, amplitude, effectMode } = this.options;\n    \n    // Clear the canvas\n    ctx.fillStyle = CanvasColors.backgroundToString(background);\n    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    // Find the maximum value for scaling\n    const maxValue = Math.max(...this.data, 1); // Avoid division by zero\n    \n    // Calculate available height accounting for potential animation amplitude\n    const availableHeight = this.canvas.height * 0.9; // Use 90% of canvas height\n    const maxAmplitude = this.canvas.height * 0.05 * amplitude;\n    \n    // Choose rendering strategy based on data size and current strategy\n    switch (this.renderStrategy) {\n      case RenderStrategies.DETAILED:\n        this.renderDetailed(\n          maxValue, \n          availableHeight, \n          maxAmplitude, \n          timestamp, \n          colorScheme\n        );\n        break;\n        \n      case RenderStrategies.OPTIMIZED:\n        this.renderOptimized(\n          maxValue, \n          availableHeight, \n          maxAmplitude, \n          timestamp, \n          colorScheme\n        );\n        break;\n        \n      case RenderStrategies.PERFORMANCE:\n        if (this.options.usePixelManipulation && this.data.length > 5000) {\n          this.renderWithPixelManipulation(\n            maxValue, \n            availableHeight, \n            colorScheme\n          );\n        } else {\n          this.renderPerformance(\n            maxValue, \n            availableHeight, \n            maxAmplitude, \n            timestamp, \n            colorScheme\n          );\n        }\n        break;\n    }\n    \n    // Update metrics\n    this.metrics.renderTime = performance.now() - startTime;\n    this.metrics.elementsRendered = this.data.length;\n    this.updateFPS(timestamp);\n  }\n  \n  /**\n   * Render with detailed visuals for small datasets\n   * @param {number} maxValue - Maximum value in the dataset\n   * @param {number} availableHeight - Available height for rendering\n   * @param {number} maxAmplitude - Maximum amplitude for animations\n   * @param {number} timestamp - Current time\n   * @param {string} colorScheme - Color scheme to use\n   * @private\n   */\n  renderDetailed(maxValue, availableHeight, maxAmplitude, timestamp, colorScheme) {\n    const ctx = this.ctx;\n    const { barWidth, spacing } = this.options;\n    \n    // Enhanced rendering for small datasets\n    this.data.forEach((value, i) => {\n      const normValue = value / maxValue;\n      const height = normValue * availableHeight;\n      \n      // Calculate position (using animation position)\n      const x = this.positions[i] * (barWidth + spacing);\n      \n      // Apply subtle animation based on height and time\n      let wobble = 0;\n      if (this.options.effectMode !== 0) {\n        wobble = Math.sin(timestamp * 0.005 + i * 0.1) * maxAmplitude * normValue;\n      }\n      \n      // Determine bar color based on state\n      let color;\n      \n      if (this.comparing.has(i)) {\n        color = this.options.comparingColor;\n      } else if (this.highlights.has(i)) {\n        color = this.options.highlightColor;\n      } else if (this.sortedIndices.has(i)) {\n        color = this.options.sortedColor;\n      } else if (this.readIndices.has(i)) {\n        color = this.options.readColor;\n      } else if (this.writeIndices.has(i)) {\n        color = this.options.writeColor;\n      } else {\n        // Use color scheme for regular elements\n        color = CanvasColors.getColor(colorScheme, normValue);\n      }\n      \n      // Draw bar with rounded corners\n      const barHeight = Math.max(1, height + wobble);\n      const cornerRadius = Math.min(2, barWidth / 2);\n      \n      ctx.beginPath();\n      ctx.moveTo(x + cornerRadius, this.canvas.height);\n      ctx.lineTo(x + cornerRadius, this.canvas.height - barHeight + cornerRadius);\n      ctx.arc(x + cornerRadius, this.canvas.height - barHeight + cornerRadius, cornerRadius, Math.PI, 1.5 * Math.PI);\n      ctx.lineTo(x + barWidth - cornerRadius, this.canvas.height - barHeight);\n      ctx.arc(x + barWidth - cornerRadius, this.canvas.height - barHeight + cornerRadius, cornerRadius, 1.5 * Math.PI, 0);\n      ctx.lineTo(x + barWidth, this.canvas.height);\n      ctx.closePath();\n      \n      // Fill with color\n      ctx.fillStyle = color;\n      ctx.fill();\n      \n      // Add subtle shadow for 3D effect\n      if (barHeight > 5) {\n        ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';\n        ctx.shadowBlur = 2;\n        ctx.shadowOffsetX = 1;\n        ctx.shadowOffsetY = 1;\n        ctx.fill();\n        \n        // Reset shadow\n        ctx.shadowColor = 'transparent';\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n      \n      // Add a highlight effect on top for sorted elements\n      if (this.sortedIndices.has(i) && this.options.effectMode > 1) {\n        const gradient = ctx.createLinearGradient(\n          x, this.canvas.height - barHeight,\n          x, this.canvas.height\n        );\n        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');\n        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n        \n        ctx.fillStyle = gradient;\n        ctx.fill();\n      }\n    });\n  }\n  \n  /**\n   * Render with optimized visuals for medium datasets\n   * @param {number} maxValue - Maximum value in the dataset\n   * @param {number} availableHeight - Available height for rendering\n   * @param {number} maxAmplitude - Maximum amplitude for animations\n   * @param {number} timestamp - Current time\n   * @param {string} colorScheme - Color scheme to use\n   * @private\n   */\n  renderOptimized(maxValue, availableHeight, maxAmplitude, timestamp, colorScheme) {\n    const ctx = this.ctx;\n    const { barWidth, spacing } = this.options;\n    \n    // Group elements by state for batch rendering\n    const groups = {\n      normal: [],\n      comparing: [],\n      highlighted: [],\n      sorted: [],\n      read: [],\n      write: []\n    };\n    \n    // Categorize elements\n    this.data.forEach((value, i) => {\n      const normValue = value / maxValue;\n      const height = normValue * availableHeight;\n      \n      // Calculate position (using animation position)\n      const x = this.positions[i] * (barWidth + spacing);\n      \n      // Apply subtle animation based on height\n      let wobble = 0;\n      if (this.options.effectMode !== 0) {\n        wobble = Math.sin(timestamp * 0.005 + i * 0.1) * maxAmplitude * normValue;\n      }\n      \n      const y = this.canvas.height - (height + wobble);\n      \n      // Categorize by state\n      if (this.comparing.has(i)) {\n        groups.comparing.push({ x, y, width: barWidth, height: height + wobble, normValue });\n      } else if (this.highlights.has(i)) {\n        groups.highlighted.push({ x, y, width: barWidth, height: height + wobble, normValue });\n      } else if (this.sortedIndices.has(i)) {\n        groups.sorted.push({ x, y, width: barWidth, height: height + wobble, normValue });\n      } else if (this.readIndices.has(i)) {\n        groups.read.push({ x, y, width: barWidth, height: height + wobble, normValue });\n      } else if (this.writeIndices.has(i)) {\n        groups.write.push({ x, y, width: barWidth, height: height + wobble, normValue });\n      } else {\n        groups.normal.push({ x, y, width: barWidth, height: height + wobble, normValue });\n      }\n    });\n    \n    // Render groups in batches for better performance\n    \n    // Render normal elements (by color value for fewer state changes)\n    const colorMap = new Map();\n    groups.normal.forEach(elem => {\n      const color = CanvasColors.getColor(colorScheme, elem.normValue);\n      if (!colorMap.has(color)) {\n        colorMap.set(color, []);\n      }\n      colorMap.get(color).push(elem);\n    });\n    \n    colorMap.forEach((elements, color) => {\n      ctx.fillStyle = color;\n      elements.forEach(elem => {\n        ctx.fillRect(elem.x, elem.y, elem.width, Math.max(1, elem.height));\n      });\n    });\n    \n    // Render special state elements\n    this.renderElementGroup(ctx, groups.comparing, this.options.comparingColor);\n    this.renderElementGroup(ctx, groups.highlighted, this.options.highlightColor);\n    this.renderElementGroup(ctx, groups.sorted, this.options.sortedColor);\n    this.renderElementGroup(ctx, groups.read, this.options.readColor);\n    this.renderElementGroup(ctx, groups.write, this.options.writeColor);\n  }\n  \n  /**\n   * Render element group with same color\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\n   * @param {Array} elements - Elements to render\n   * @param {string} color - Color to use\n   * @private\n   */\n  renderElementGroup(ctx, elements, color) {\n    if (elements.length === 0) return;\n    \n    ctx.fillStyle = color;\n    elements.forEach(elem => {\n      ctx.fillRect(elem.x, elem.y, elem.width, Math.max(1, elem.height));\n    });\n  }\n  \n  /**\n   * Render with minimal visual effects for large datasets\n   * @param {number} maxValue - Maximum value in the dataset\n   * @param {number} availableHeight - Available height for rendering\n   * @param {number} maxAmplitude - Maximum amplitude for animations\n   * @param {number} timestamp - Current time\n   * @param {string} colorScheme - Color scheme to use\n   * @private\n   */\n  renderPerformance(maxValue, availableHeight, maxAmplitude, timestamp, colorScheme) {\n    const ctx = this.ctx;\n    const { barWidth, spacing } = this.options;\n    const totalWidth = barWidth + spacing;\n    \n    // Pre-calculate to avoid redundant calculations in loop\n    const baseY = this.canvas.height;\n    const heightFactor = availableHeight / maxValue;\n    \n    // Use path batching for fewer draw calls\n    \n    // Draw normal elements in a single path\n    const specialIndices = new Set([\n      ...this.comparing,\n      ...this.highlights,\n      ...this.sortedIndices,\n      ...this.readIndices,\n      ...this.writeIndices\n    ]);\n    \n    // Group elements by color value ranges to reduce state changes\n    const colorRanges = [\n      { min: 0.0, max: 0.2, elements: [] },\n      { min: 0.2, max: 0.4, elements: [] },\n      { min: 0.4, max: 0.6, elements: [] },\n      { min: 0.6, max: 0.8, elements: [] },\n      { min: 0.8, max: 1.0, elements: [] }\n    ];\n    \n    // Categorize normal elements by value range\n    this.data.forEach((value, i) => {\n      if (specialIndices.has(i)) return;\n      \n      const normValue = value / maxValue;\n      const range = colorRanges.find(r => normValue >= r.min && normValue < r.max);\n      if (range) {\n        range.elements.push({\n          index: i,\n          normValue: normValue,\n          x: this.positions[i] * totalWidth,\n          height: value * heightFactor\n        });\n      }\n    });\n    \n    // Render normal elements by color range\n    colorRanges.forEach(range => {\n      if (range.elements.length === 0) return;\n      \n      // Get color for this range\n      const avgValue = (range.min + range.max) / 2;\n      ctx.fillStyle = CanvasColors.getColor(colorScheme, avgValue);\n      \n      // Draw all elements in this range at once\n      range.elements.forEach(elem => {\n        const barHeight = Math.max(1, elem.height);\n        ctx.fillRect(elem.x, baseY - barHeight, barWidth, barHeight);\n      });\n    });\n    \n    // Draw special state elements\n    this.renderSpecialStates(\n      baseY, \n      heightFactor, \n      totalWidth, \n      barWidth, \n      maxValue,\n      colorScheme\n    );\n  }\n  \n  /**\n   * Render elements with special states\n   * @param {number} baseY - Base Y position\n   * @param {number} heightFactor - Factor to convert values to heights\n   * @param {number} totalWidth - Total width of each element\n   * @param {number} barWidth - Width of each bar\n   * @param {number} maxValue - Maximum value\n   * @param {string} colorScheme - Color scheme\n   * @private\n   */\n  renderSpecialStates(baseY, heightFactor, totalWidth, barWidth, maxValue, colorScheme) {\n    const ctx = this.ctx;\n    \n    // Comparing elements\n    if (this.comparing.size > 0) {\n      ctx.fillStyle = this.options.comparingColor;\n      this.comparing.forEach(i => {\n        const value = this.data[i];\n        const barHeight = Math.max(1, value * heightFactor);\n        const x = this.positions[i] * totalWidth;\n        ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);\n      });\n    }\n    \n    // Highlighted elements\n    if (this.highlights.size > 0) {\n      ctx.fillStyle = this.options.highlightColor;\n      this.highlights.forEach(i => {\n        const value = this.data[i];\n        const barHeight = Math.max(1, value * heightFactor);\n        const x = this.positions[i] * totalWidth;\n        ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);\n      });\n    }\n    \n    // Sorted elements\n    if (this.sortedIndices.size > 0) {\n      ctx.fillStyle = this.options.sortedColor;\n      this.sortedIndices.forEach(i => {\n        const value = this.data[i];\n        const barHeight = Math.max(1, value * heightFactor);\n        const x = this.positions[i] * totalWidth;\n        ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);\n      });\n    }\n    \n    // Read elements\n    if (this.readIndices.size > 0) {\n      ctx.fillStyle = this.options.readColor;\n      this.readIndices.forEach(i => {\n        const value = this.data[i];\n        const barHeight = Math.max(1, value * heightFactor);\n        const x = this.positions[i] * totalWidth;\n        ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);\n      });\n    }\n    \n    // Write elements\n    if (this.writeIndices.size > 0) {\n      ctx.fillStyle = this.options.writeColor;\n      this.writeIndices.forEach(i => {\n        const value = this.data[i];\n        const barHeight = Math.max(1, value * heightFactor);\n        const x = this.positions[i] * totalWidth;\n        ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);\n      });\n    }\n  }\n  \n  /**\n   * Render using direct pixel manipulation for large datasets\n   * @param {number} maxValue - Maximum value in the dataset\n   * @param {number} availableHeight - Available height for rendering\n   * @param {string} colorScheme - Color scheme to use\n   * @private\n   */\n  renderWithPixelManipulation(maxValue, availableHeight, colorScheme) {\n    // This is the most performant but least visually appealing rendering method\n    const { barWidth, spacing } = this.options;\n    const totalWidth = barWidth + spacing;\n    \n    // Create or reuse ImageData\n    if (!this.imageData || \n        this.imageData.width !== this.canvas.width || \n        this.imageData.height !== this.canvas.height) {\n      this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);\n    }\n    \n    const data = this.imageData.data;\n    const width = this.canvas.width;\n    const height = this.canvas.height;\n    \n    // Clear the image data\n    for (let i = 0; i < data.length; i += 4) {\n      data[i] = Math.floor(this.options.background[0] * 255);     // R\n      data[i + 1] = Math.floor(this.options.background[1] * 255); // G\n      data[i + 2] = Math.floor(this.options.background[2] * 255); // B\n      data[i + 3] = Math.floor(this.options.background[3] * 255); // A\n    }\n    \n    // Calculate the normalization factor\n    const heightFactor = availableHeight / maxValue;\n    \n    // Draw the bars directly into the image data\n    this.data.forEach((value, i) => {\n      const normValue = value / maxValue;\n      const barHeight = Math.max(1, Math.floor(value * heightFactor));\n      const xPos = Math.floor(this.positions[i] * totalWidth);\n      \n      // Skip if out of bounds\n      if (xPos + barWidth >= width || xPos < 0) return;\n      \n      // Determine bar color\n      let color;\n      \n      if (this.comparing.has(i)) {\n        color = [255, 0, 0, 255]; // Red for comparing\n      } else if (this.highlights.has(i)) {\n        color = [255, 255, 0, 255]; // Yellow for highlights\n      } else if (this.sortedIndices.has(i)) {\n        color = [0, 255, 0, 255]; // Green for sorted\n      } else if (this.readIndices.has(i)) {\n        color = [0, 128, 255, 255]; // Light blue for read\n      } else if (this.writeIndices.has(i)) {\n        color = [255, 128, 0, 255]; // Orange for write\n      } else {\n        // Parse color scheme\n        const rgbaColor = CanvasColors.getColor(colorScheme, normValue);\n        const match = rgbaColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)/);\n        \n        if (match) {\n          color = [\n            parseInt(match[1]), // R\n            parseInt(match[2]), // G\n            parseInt(match[3]), // B\n            match[4] ? Math.floor(parseFloat(match[4]) * 255) : 255 // A\n          ];\n        } else {\n          color = [100, 100, 100, 255]; // Default gray\n        }\n      }\n      \n      // Fill the bar by setting individual pixels\n      for (let x = 0; x < barWidth; x++) {\n        const xCoord = xPos + x;\n        if (xCoord >= width) continue;\n        \n        for (let y = 0; y < barHeight; y++) {\n          const yCoord = height - y - 1;\n          if (yCoord < 0 || yCoord >= height) continue;\n          \n          const pixelIndex = (yCoord * width + xCoord) * 4;\n          data[pixelIndex] = color[0];     // R\n          data[pixelIndex + 1] = color[1]; // G\n          data[pixelIndex + 2] = color[2]; // B\n          data[pixelIndex + 3] = color[3]; // A\n        }\n      }\n    });\n    \n    // Put the image data back to the canvas\n    this.ctx.putImageData(this.imageData, 0, 0);\n  }\n  \n  /**\n   * Update FPS calculation\n   * @param {number} timestamp - Current time\n   * @private\n   */\n  updateFPS(timestamp) {\n    // Count frames\n    this.frameCount++;\n    \n    // Update FPS every interval\n    if (timestamp - this.lastFpsUpdate >= this.fpsUpdateInterval) {\n      const elapsed = timestamp - this.lastFpsUpdate;\n      this.metrics.fps = Math.round((this.frameCount * 1000) / elapsed);\n      \n      this.lastFpsUpdate = timestamp;\n      this.frameCount = 0;\n    }\n  }\n  \n  /**\n   * Resize the renderer to match canvas size\n   */\n  resize() {\n    // Get canvas display size\n    const displayWidth = this.canvas.clientWidth;\n    const displayHeight = this.canvas.clientHeight;\n    \n    // Check if canvas size has changed\n    if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {\n      // Update canvas size to match display size\n      this.canvas.width = displayWidth;\n      this.canvas.height = displayHeight;\n      \n      // Update offscreen canvas\n      this.offscreenCanvas.width = displayWidth;\n      this.offscreenCanvas.height = displayHeight;\n      \n      // Clear image data cache\n      this.imageData = null;\n      \n      // Redraw\n      this.render(performance.now());\n    }\n  }\n  \n  /**\n   * Set renderer options\n   * @param {Object} options - New options to apply\n   */\n  setOptions(options) {\n    // Update options\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    \n    // Convert array colors to strings if needed\n    if (options.background) {\n      if (Array.isArray(options.background)) {\n        options.background = CanvasColors.backgroundToString(options.background);\n      }\n    }\n    \n    if (options.highlightColor && Array.isArray(options.highlightColor)) {\n      options.highlightColor = CanvasColors.rgbaArrayToString(options.highlightColor);\n    }\n    \n    if (options.comparingColor && Array.isArray(options.comparingColor)) {\n      options.comparingColor = CanvasColors.rgbaArrayToString(options.comparingColor);\n    }\n    \n    if (options.sortedColor && Array.isArray(options.sortedColor)) {\n      options.sortedColor = CanvasColors.rgbaArrayToString(options.sortedColor);\n    }\n    \n    if (options.readColor && Array.isArray(options.readColor)) {\n      options.readColor = CanvasColors.rgbaArrayToString(options.readColor);\n    }\n    \n    if (options.writeColor && Array.isArray(options.writeColor)) {\n      options.writeColor = CanvasColors.rgbaArrayToString(options.writeColor);\n    }\n    \n    // Redraw if needed\n    if (options.colorScheme || \n        options.barWidth || \n        options.spacing || \n        options.background ||\n        options.highlightColor ||\n        options.comparingColor ||\n        options.sortedColor ||\n        options.readColor ||\n        options.writeColor) {\n      this.render(performance.now());\n    }\n  }\n  \n  /**\n   * Clean up resources\n   */\n  dispose() {\n    // Clear references\n    this.data = [];\n    this.originalData = [];\n    this.positions = [];\n    this.targetPositions = [];\n    \n    // Clear image data\n    this.imageData = null;\n    this.offscreenCanvas = null;\n    this.offscreenCtx = null;\n    \n    // Clear render state\n    this.highlights = new Set();\n    this.comparing = new Set();\n    this.sortedIndices = new Set();\n    this.readIndices = new Set();\n    this.writeIndices = new Set();\n  }\n  \n  /**\n   * Get current performance metrics\n   * @returns {Object} Performance metrics object\n   */\n  getMetrics() {\n    return { ...this.metrics };\n  }\n  \n  /**\n   * Reset the visualization to original data\n   */\n  reset() {\n    this.data = [...this.originalData];\n    this.highlights = new Set();\n    this.comparing = new Set();\n    this.sortedIndices = new Set();\n    this.readIndices = new Set();\n    this.writeIndices = new Set();\n    this.positions = this.data.map((_, i) => i);\n    this.targetPositions = [...this.positions];\n    this.render(performance.now());\n  }\n  \n  /**\n   * Linear interpolation between two values\n   * @param {number} a - Start value\n   * @param {number} b - End value\n   * @param {number} t - Interpolation factor (0-1)\n   * @returns {number} Interpolated value\n   * @private\n   */\n  lerp(a, b, t) {\n    return a + (b - a) * t;\n  }\n  \n  /**\n   * Get an image of the current visualization state\n   * @returns {string} Data URL of the image\n   */\n  getImageData() {\n    return this.canvas.toDataURL('image/png');\n  }\n  \n  /**\n   * Toggle animation amplitude\n   * @param {number} amplitude - Animation amplitude (0-1)\n   */\n  setAmplitude(amplitude) {\n    this.options.amplitude = Math.max(0, Math.min(1, amplitude));\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n  \n  /**\n   * Set visual effect mode\n   * @param {number} mode - Effect mode (0: none, 1: basic, 2: enhanced)\n   */\n  setEffectMode(mode) {\n    this.options.effectMode = mode;\n    if (!this.isAnimating) {\n      this.render(performance.now());\n    }\n  }\n}\n\nexport { ArrayRenderer };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}