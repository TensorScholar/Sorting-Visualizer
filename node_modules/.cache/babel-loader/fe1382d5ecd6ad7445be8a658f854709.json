{"ast":null,"code":"/**\n * @file generators.js\n * @author Algorithm Visualization Platform Team\n * @version 3.0.0\n * \n * @description\n * Comprehensive data generation utilities for algorithm visualization and performance analysis.\n * This module provides statistical, mathematical, and algorithmic tools for generating datasets\n * with specific properties, distributions, and characteristics that demonstrate algorithm behavior\n * under various conditions.\n * \n * Each generator is designed with configurable parameters, ensuring precise control over\n * dataset properties while maintaining mathematical rigor in distribution characteristics.\n * All generators include detailed complexity analysis and performance considerations.\n * \n * Features:\n * - Multiple distribution types (uniform, Gaussian, exponential, etc.)\n * - Sorted and partially-sorted data generation\n * - Special pattern generators (sawtooth, plateau, stepped, etc.)\n * - Adversarial case generators for specific algorithms\n * - Statistical property control (skewness, kurtosis)\n * - Duplicates and unique value control\n * - Selection algorithm test case generators\n * - Verification and validation utilities\n */\n\n/**\n * @namespace DataGenerators\n * @description Comprehensive set of data generation utilities\n */\nconst DataGenerators = {\n  /**\n   * Generate a dataset based on specified type and parameters\n   * \n   * @function generateDataSet\n   * @memberof DataGenerators\n   * \n   * @param {string} type - Type of data set to generate\n   * @param {number} size - Size of data set\n   * @param {Object} [options={}] - Configuration options\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {number} [options.uniqueValues=10] - Number of unique values for few-unique type\n   * @param {number} [options.sortedRatio=0.9] - Ratio of sortedness for nearly-sorted type\n   * @param {number} [options.reversedRatio=0.9] - Ratio of reversedness for reversed type\n   * @param {number} [options.seed] - Random seed for reproducible generation\n   * \n   * @returns {Array<number>} Generated data set\n   * \n   * @throws {TypeError} If parameters are of incorrect type\n   * @throws {RangeError} If parameters are out of acceptable range\n   * \n   * @example\n   * // Generate a nearly sorted array of 100 elements\n   * const nearlySorted = DataGenerators.generateDataSet('nearly-sorted', 100, { sortedRatio: 0.8 });\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateDataSet(type, size, options = {}) {\n    // Parameter validation\n    if (typeof size !== 'number' || size < 0 || !Number.isInteger(size)) {\n      throw new TypeError('Size must be a non-negative integer');\n    }\n\n    // Apply defaults with ES6 destructuring and defaults\n    const {\n      min = 1,\n      max = 100,\n      uniqueValues = 10,\n      sortedRatio = 0.9,\n      reversedRatio = 0.9,\n      seed = undefined\n    } = options;\n\n    // Validate ranges\n    if (min > max) {\n      throw new RangeError('Minimum value must be less than or equal to maximum value');\n    }\n    if (uniqueValues <= 0) {\n      throw new RangeError('Number of unique values must be positive');\n    }\n    if (sortedRatio < 0 || sortedRatio > 1) {\n      throw new RangeError('Sorted ratio must be between 0 and 1');\n    }\n    if (reversedRatio < 0 || reversedRatio > 1) {\n      throw new RangeError('Reversed ratio must be between 0 and 1');\n    }\n\n    // If seed is provided, initialize PRNG\n    let randomFn = Math.random;\n    if (seed !== undefined) {\n      const seededRandom = this._createSeededRandom(seed);\n      randomFn = seededRandom;\n    }\n\n    // Select appropriate generator based on type\n    switch (type.toLowerCase()) {\n      case 'random':\n        return this.generateRandomData(size, min, max, randomFn);\n      case 'nearly-sorted':\n        return this.generateNearlySortedData(size, min, max, sortedRatio, randomFn);\n      case 'reversed':\n        return this.generateReversedData(size, min, max, reversedRatio, randomFn);\n      case 'few-unique':\n        return this.generateFewUniqueData(size, min, max, uniqueValues, randomFn);\n      case 'sorted':\n        return this.generateSortedData(size, min, max);\n      case 'sawtooth':\n        return this.generateSawtoothData(size, min, max);\n      case 'plateau':\n        return this.generatePlateauData(size, min, max, randomFn);\n      case 'shuffled-plateau':\n        const plateau = this.generatePlateauData(size, min, max, randomFn);\n        return this._shuffleArray(plateau, randomFn);\n      case 'pipe-organ':\n        return this.generatePipeOrganData(size, min, max);\n      case 'sorted-blocks':\n        return this.generateSortedBlocksData(size, min, max, options.blockSize || Math.floor(size / 10), randomFn);\n      case 'gaussian':\n        return this.generateGaussianDistribution(size, {\n          mean: (min + max) / 2,\n          stdDev: (max - min) / 6,\n          // ~99.7% of values within range\n          min,\n          max,\n          ...options\n        }, randomFn);\n      default:\n        console.warn(`Unknown data set type: ${type}, using random instead`);\n        return this.generateRandomData(size, min, max, randomFn);\n    }\n  },\n  /**\n   * Generate a random array of numbers with uniform distribution\n   * \n   * @function generateRandomData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Random array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateRandomData(size, min = 1, max = 100, randomFn = Math.random) {\n    return Array.from({\n      length: size\n    }, () => Math.floor(randomFn() * (max - min + 1)) + min);\n  },\n  /**\n   * Generate a sorted array of numbers\n   * \n   * @function generateSortedData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {boolean} [descending=false] - Whether to sort in descending order\n   * \n   * @returns {Array<number>} Sorted array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateSortedData(size, min = 1, max = 100, descending = false) {\n    if (size <= 0) return [];\n    const step = (max - min) / (size - 1 || 1);\n    const result = Array.from({\n      length: size\n    }, (_, i) => Math.round(min + i * step));\n    return descending ? result.reverse() : result;\n  },\n  /**\n   * Generate a reversed (descending) array of numbers\n   * \n   * @function generateReversedData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {number} [ratio=0.9] - How reversed the array should be (0-1)\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Reversed array with specified disorder\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateReversedData(size, min = 1, max = 100, ratio = 0.9, randomFn = Math.random) {\n    // First generate sorted array\n    const sorted = this.generateSortedData(size, min, max);\n\n    // Completely reversed\n    if (ratio >= 1) {\n      return sorted.reverse();\n    }\n\n    // Partially reversed\n    const reversed = sorted.reverse();\n    const result = [...reversed];\n\n    // Shuffle some elements to make it less perfectly reversed\n    const shuffleCount = Math.floor(size * (1 - ratio));\n    for (let i = 0; i < shuffleCount; i++) {\n      const idx1 = Math.floor(randomFn() * size);\n      const idx2 = Math.floor(randomFn() * size);\n      [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n    }\n    return result;\n  },\n  /**\n   * Generate a nearly sorted array of numbers\n   * \n   * @function generateNearlySortedData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {number} [ratio=0.9] - How sorted the array should be (0-1)\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Nearly sorted array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateNearlySortedData(size, min = 1, max = 100, ratio = 0.9, randomFn = Math.random) {\n    // Generate sorted array\n    const result = this.generateSortedData(size, min, max);\n\n    // Determine how many elements to shuffle\n    const shuffleCount = Math.floor(size * (1 - ratio));\n\n    // Shuffle random pairs of elements\n    for (let i = 0; i < shuffleCount; i++) {\n      const idx1 = Math.floor(randomFn() * size);\n\n      // Keep swaps relatively local for more realistic nearly-sorted data\n      const maxDistance = Math.max(5, Math.floor(size * 0.1));\n      const offset = Math.floor(randomFn() * maxDistance) - Math.floor(maxDistance / 2);\n      const idx2 = Math.max(0, Math.min(size - 1, idx1 + offset));\n      [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n    }\n    return result;\n  },\n  /**\n   * Generate an array with few unique values\n   * \n   * @function generateFewUniqueData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {number} [uniqueCount=10] - Number of unique values\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array with few unique values\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array, plus O(uniqueCount) for the unique values\n   */\n  generateFewUniqueData(size, min = 1, max = 100, uniqueCount = 10, randomFn = Math.random) {\n    // Ensure uniqueCount isn't larger than the possible range\n    uniqueCount = Math.min(uniqueCount, max - min + 1);\n\n    // Generate the unique values\n    const uniqueValues = [];\n    for (let i = 0; i < uniqueCount; i++) {\n      const value = Math.floor(min + i * (max - min) / (uniqueCount - 1 || 1));\n      uniqueValues.push(value);\n    }\n\n    // Create array by randomly selecting from unique values\n    return Array.from({\n      length: size\n    }, () => uniqueValues[Math.floor(randomFn() * uniqueCount)]);\n  },\n  /**\n   * Generate a sawtooth pattern array\n   * \n   * @function generateSawtoothData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {number} [teethCount] - Number of teeth in the pattern (defaults to size/20)\n   * \n   * @returns {Array<number>} Sawtooth pattern array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateSawtoothData(size, min = 1, max = 100, teethCount = null) {\n    // Default teeth count is related to array size\n    if (teethCount === null) {\n      teethCount = Math.max(2, Math.floor(size / 20));\n    }\n    const teethSize = Math.ceil(size / teethCount);\n    const result = [];\n    for (let i = 0; i < size; i++) {\n      // Determine which tooth this element belongs to\n      const toothIdx = Math.floor(i / teethSize);\n      // Position within the current tooth\n      const posInTooth = i % teethSize;\n      // Value increases within each tooth, then drops for the next tooth\n      const progress = posInTooth / teethSize;\n      const value = min + Math.floor(progress * (max - min));\n      result.push(value);\n    }\n    return result;\n  },\n  /**\n   * Generate a plateau pattern array (sections of same values)\n   * \n   * @function generatePlateauData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Plateau pattern array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array, plus O(plateauCount) for plateau values\n   */\n  generatePlateauData(size, min = 1, max = 100, randomFn = Math.random) {\n    // Determine number of plateaus\n    const plateauCount = Math.max(2, Math.floor(Math.sqrt(size)));\n    const plateauSize = Math.floor(size / plateauCount);\n    const result = [];\n\n    // Generate plateau values in ascending order\n    const plateauValues = [];\n    for (let i = 0; i < plateauCount; i++) {\n      // Add some randomness to plateau values while maintaining order\n      const prevValue = i > 0 ? plateauValues[i - 1] : min - 1;\n      const maxValue = min + Math.floor((i + 1) / plateauCount * (max - min));\n      const minValue = i === 0 ? min : prevValue + 1;\n      plateauValues.push(minValue + Math.floor(randomFn() * (maxValue - minValue + 1)));\n    }\n\n    // Build the array\n    for (let i = 0; i < size; i++) {\n      const plateauIdx = Math.min(plateauCount - 1, Math.floor(i / plateauSize));\n      result.push(plateauValues[plateauIdx]);\n    }\n    return result;\n  },\n  /**\n   * Generate a pipe organ pattern (ascending then descending)\n   * \n   * @function generatePipeOrganData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * \n   * @returns {Array<number>} Pipe organ pattern array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generatePipeOrganData(size, min = 1, max = 100) {\n    const result = [];\n    const midpoint = Math.floor(size / 2);\n    const step = (max - min) / midpoint;\n\n    // Generate ascending part\n    for (let i = 0; i < midpoint; i++) {\n      result.push(Math.round(min + i * step));\n    }\n\n    // Generate descending part\n    for (let i = 0; i < size - midpoint; i++) {\n      result.push(Math.round(max - i * step));\n    }\n    return result;\n  },\n  /**\n   * Generate data with sorted blocks\n   * \n   * @function generateSortedBlocksData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {number} [blockSize=10] - Size of sorted blocks\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array with sorted blocks\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateSortedBlocksData(size, min = 1, max = 100, blockSize = 10, randomFn = Math.random) {\n    // Generate random data\n    const data = this.generateRandomData(size, min, max, randomFn);\n    const result = [];\n\n    // Sort blocks\n    for (let i = 0; i < size; i += blockSize) {\n      const blockEnd = Math.min(i + blockSize, size);\n      const block = data.slice(i, blockEnd).sort((a, b) => a - b);\n      result.push(...block);\n    }\n    return result;\n  },\n  /**\n   * Generate a Gaussian (normal) distribution\n   * \n   * @function generateGaussianDistribution\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Distribution parameters\n   * @param {number} [options.mean=50] - Mean of the distribution\n   * @param {number} [options.stdDev=15] - Standard deviation\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Gaussian distribution array\n   * \n   * @complexity Time: O(n) where n is the size parameter, with potential rejection sampling\n   * @complexity Space: O(n) for the returned array\n   */\n  generateGaussianDistribution(size, options = {}, randomFn = Math.random) {\n    const {\n      mean = 50,\n      stdDev = 15,\n      min = 1,\n      max = 100\n    } = options;\n    const result = [];\n\n    // Box-Muller transform for Gaussian distribution\n    for (let i = 0; i < size; i++) {\n      let num;\n      do {\n        // Generate normal distribution with desired mean and std dev\n        const u1 = randomFn();\n        const u2 = randomFn();\n        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);\n        num = Math.round(z0 * stdDev + mean);\n      } while (num < min || num > max); // Ensure within range with rejection sampling\n\n      result.push(num);\n    }\n    return result;\n  },\n  /**\n   * Generate an exponential distribution\n   * \n   * @function generateExponentialDistribution\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Distribution parameters\n   * @param {number} [options.lambda=0.1] - Rate parameter\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Exponential distribution array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateExponentialDistribution(size, options = {}, randomFn = Math.random) {\n    const {\n      lambda = 0.1,\n      min = 1,\n      max = 100\n    } = options;\n    const result = [];\n    const range = max - min;\n    for (let i = 0; i < size; i++) {\n      // Generate exponential distribution\n      const u = randomFn();\n      const value = min + Math.round(-Math.log(1 - u) / lambda % range);\n      result.push(Math.min(value, max));\n    }\n    return result;\n  },\n  /**\n   * Generate a bimodal distribution (two peaks)\n   * \n   * @function generateBimodalDistribution\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Distribution parameters\n   * @param {number} [options.mean1=25] - Mean of first distribution\n   * @param {number} [options.stdDev1=10] - Standard deviation of first distribution\n   * @param {number} [options.mean2=75] - Mean of second distribution\n   * @param {number} [options.stdDev2=10] - Standard deviation of second distribution\n   * @param {number} [options.ratio=0.5] - Ratio of values from first distribution\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Bimodal distribution array\n   * \n   * @complexity Time: O(n) where n is the size parameter, with potential rejection sampling\n   * @complexity Space: O(n) for the returned array\n   */\n  generateBimodalDistribution(size, options = {}, randomFn = Math.random) {\n    const {\n      mean1 = 25,\n      stdDev1 = 10,\n      mean2 = 75,\n      stdDev2 = 10,\n      ratio = 0.5,\n      min = 1,\n      max = 100\n    } = options;\n    const result = [];\n    for (let i = 0; i < size; i++) {\n      let num;\n      do {\n        // Decide which distribution to use\n        const useFirst = randomFn() < ratio;\n\n        // Generate value from selected distribution\n        const mean = useFirst ? mean1 : mean2;\n        const stdDev = useFirst ? stdDev1 : stdDev2;\n\n        // Box-Muller transform\n        const u1 = randomFn();\n        const u2 = randomFn();\n        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);\n        num = Math.round(z0 * stdDev + mean);\n      } while (num < min || num > max); // Ensure within range\n\n      result.push(num);\n    }\n    return result;\n  },\n  /**\n   * Generate an array that's challenging for a specific algorithm\n   * \n   * @function generateAdversarialCase\n   * @memberof DataGenerators\n   * \n   * @param {string} algorithm - Algorithm name\n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Additional options\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {string} [options.pivotStrategy] - Pivot strategy for quicksort\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for the algorithm\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateAdversarialCase(algorithm, size, options = {}, randomFn = Math.random) {\n    const {\n      min = 1,\n      max = 100\n    } = options;\n\n    // Select appropriate adversarial case\n    switch (algorithm.toLowerCase()) {\n      case 'quicksort':\n        return this._generateQuicksortAdversarial(size, min, max, options, randomFn);\n      case 'mergesort':\n        return this._generateMergesortAdversarial(size, min, max, randomFn);\n      case 'insertionsort':\n        return this._generateInsertionSortAdversarial(size, min, max);\n      case 'heapsort':\n        return this._generateHeapSortAdversarial(size, min, max, randomFn);\n      case 'bubblesort':\n        return this.generateReversedData(size, min, max, 1);\n      case 'shellsort':\n        return this._generateShellSortAdversarial(size, min, max, randomFn);\n      default:\n        // Default to reversed for unknown algorithms\n        return this.generateReversedData(size, min, max, 1);\n    }\n  },\n  /**\n   * Generate an adversarial case for Quicksort\n   * \n   * @function _generateQuicksortAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @param {Object} options - Additional options\n   * @param {string} [options.pivotStrategy='first'] - Pivot strategy\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for Quicksort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateQuicksortAdversarial(size, min, max, options = {}, randomFn = Math.random) {\n    const {\n      pivotStrategy = 'first'\n    } = options;\n    switch (pivotStrategy) {\n      case 'first':\n        // Worst case for first-element pivot is already sorted\n        return this.generateSortedData(size, min, max);\n      case 'last':\n        // Worst case for last-element pivot is reversed\n        return this.generateReversedData(size, min, max, 1);\n      case 'middle':\n        // Create a pattern where middle elements are bad pivots\n        return this._generateSpecialPattern(size, min, max);\n      case 'median-of-three':\n        // More complex pattern needed for median-of-three\n        return this._generateMedianOfThreeAdversarial(size, min, max, randomFn);\n      case 'random':\n        // Hard to create a true adversarial case for random pivot\n        // but we can create a degenerate distribution\n        return this.generateFewUniqueData(size, min, max, 2, randomFn);\n      default:\n        return this.generateSortedData(size, min, max);\n    }\n  },\n  /**\n   * Generate a special pattern for quicksort with middle pivot\n   * \n   * @function _generateSpecialPattern\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * \n   * @returns {Array<number>} Special pattern array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateSpecialPattern(size, min, max) {\n    const result = [];\n    const range = max - min;\n\n    // Create a pattern where pivoting on middle gives unbalanced partitions\n    // This works by arranging values so that partitioning around the middle\n    // element consistently creates very unbalanced partitions\n    for (let i = 0; i < size; i++) {\n      const halfSize = Math.floor(size / 2);\n      let value;\n      if (i < halfSize) {\n        // First half of array: create values that are all less than middle\n        value = min + Math.floor(i / halfSize * (range / 3));\n      } else {\n        // Second half: create values that are all greater than middle\n        // but clustered near middle to make poor partitioning\n        value = min + Math.floor(range / 2) + Math.floor((i - halfSize) / (size - halfSize) * (range / 2));\n      }\n      result.push(value);\n    }\n    return result;\n  },\n  /**\n   * Generate adversarial case for median-of-three quicksort\n   * \n   * @function _generateMedianOfThreeAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for median-of-three quicksort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateMedianOfThreeAdversarial(size, min, max, randomFn = Math.random) {\n    // This requires a complex pattern that would defeat median-of-three\n    // We'll use a \"fat pivot\" approach with many repeated elements\n\n    const result = [];\n    const step = (max - min) / (size - 1 || 1);\n\n    // Build an array that will tend to select poor pivots\n    // by creating local patterns where the median is often a poor choice\n    for (let i = 0; i < size; i++) {\n      const mod = i % 3;\n      if (mod === 0) {\n        // Every third element is a large value - middle of triplet\n        result.push(min + Math.floor((size - i) * step * 0.8));\n      } else if (mod === 1) {\n        // Every third + 1 element is at the median\n        const medianVal = min + Math.floor(i * step * 0.5);\n        result.push(medianVal);\n      } else {\n        // Every third + 2 element is a small value\n        result.push(min + Math.floor(i * step * 0.3));\n      }\n    }\n\n    // Add some random shuffling to avoid too obvious patterns\n    for (let i = 0; i < size / 3; i++) {\n      const idx1 = Math.floor(randomFn() * size);\n      const idx2 = Math.floor(randomFn() * size);\n      if (idx1 % 3 === idx2 % 3) {\n        // Only swap elements in the same mod class\n        [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n      }\n    }\n    return result;\n  },\n  /**\n   * Generate adversarial case for mergesort\n   * \n   * @function _generateMergesortAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for mergesort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateMergesortAdversarial(size, min, max, randomFn = Math.random) {\n    // Mergesort is typically O(n log n) regardless of input\n    // but a pattern that maximizes comparisons and pathological merging can be constructed\n\n    const result = [];\n    const step = (max - min) / (size - 1 || 1);\n\n    // Pattern designed to increase merge complexity:\n    // - Create \"runs\" of already sorted data in reverse order\n    // - This forces the merge operation to always interleave elements\n\n    // Generate sorted runs of power-of-two lengths\n    let runLength = 1;\n    while (runLength * 2 <= size) {\n      runLength *= 2;\n    }\n\n    // Generate each run in alternating order to maximize merging cost\n    let offset = 0;\n    while (offset < size) {\n      const currentRunLength = Math.min(runLength, size - offset);\n      const ascending = offset / runLength % 2 === 0;\n      for (let i = 0; i < currentRunLength; i++) {\n        const pos = offset + i;\n        const localValue = min + Math.floor(pos * step);\n        if (ascending) {\n          result.push(localValue);\n        } else {\n          // Insert at the beginning of the current run\n          result.splice(offset, 0, localValue);\n        }\n      }\n      offset += currentRunLength;\n    }\n    return result;\n  },\n  /**\n   * Generate adversarial case for insertion sort\n   * \n   * @function _generateInsertionSortAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * \n   * @returns {Array<number>} Adversarial array for insertion sort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateInsertionSortAdversarial(size, min, max) {\n    // Worst case for insertion sort is reversed order\n    return this.generateReversedData(size, min, max, 1);\n  },\n  /**\n   * Generate adversarial case for heap sort\n   * \n   * @function _generateHeapSortAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for heap sort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateHeapSortAdversarial(size, min, max, randomFn = Math.random) {\n    // Heap sort is typically O(n log n) regardless of input\n    // but certain patterns can maximize the number of heapify operations\n\n    const result = [];\n    const step = (max - min) / (size - 1 || 1);\n\n    // Build an array that will require many sift-down operations\n    // For heap sort, a good adversarial case is a pattern where each\n    // heapify operation involves many comparisons and swaps\n\n    // Fill the first half with ascending values (base of heap)\n    for (let i = 0; i < Math.floor(size / 2); i++) {\n      result.push(min + Math.floor(i * step));\n    }\n\n    // Fill the second half with larger values in decreasing order\n    // This creates a situation where many elements will need heapification\n    for (let i = Math.floor(size / 2); i < size; i++) {\n      result.push(max - Math.floor((i - size / 2) * step));\n    }\n\n    // Shuffle the result a bit to avoid too obvious pattern detection\n    // But maintain the general structure that makes heap sort work harder\n    for (let i = 0; i < size / 4; i++) {\n      const idx1 = Math.floor(randomFn() * (size / 2));\n      const idx2 = Math.floor(randomFn() * (size / 2));\n      [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n      const idx3 = Math.floor(size / 2) + Math.floor(randomFn() * (size / 2));\n      const idx4 = Math.floor(size / 2) + Math.floor(randomFn() * (size / 2));\n      [result[idx3], result[idx4]] = [result[idx4], result[idx3]];\n    }\n    return result;\n  },\n  /**\n   * Generate adversarial case for shell sort\n   * \n   * @function _generateShellSortAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for shell sort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateShellSortAdversarial(size, min, max, randomFn = Math.random) {\n    // Shell sort performance is heavily dependent on the gap sequence\n    // A good adversarial case would have elements arranged to maximize\n    // the number of comparisons and swaps for common gap sequences\n\n    // Create an array with elements positioned to require maximum movement\n    const result = Array(size).fill(0);\n    const range = max - min;\n\n    // Common gap sequences:\n    // - Shell's original: n/2, n/4, ..., 1\n    // - Knuth's: 1, 4, 13, 40, 121, ...\n    // - Sedgewick's: 1, 8, 23, 77, 281, 1073, 4193, ...\n\n    // Start with a pattern that's adversarial for the first gap (usually n/2)\n    for (let i = 0; i < size; i++) {\n      // Position elements to maximize swaps with typical gap sequences\n      // by alternating large and small values in positions that will be compared\n      if (i % 2 === 0) {\n        result[i] = max - Math.floor(i / size * range * 0.5);\n      } else {\n        result[i] = min + Math.floor(i / size * range * 0.5);\n      }\n    }\n\n    // Add a further pattern to defeat later gap sequences\n    for (let i = 0; i < size; i += 4) {\n      if (i + 3 < size) {\n        // Re-arrange groups of 4 elements to maximize swaps for smaller gaps\n        [result[i], result[i + 3]] = [result[i + 3], result[i]];\n        [result[i + 1], result[i + 2]] = [result[i + 2], result[i + 1]];\n      }\n    }\n    return result;\n  },\n  /**\n   * Create an array of custom objects for testing stability\n   * \n   * @function generateObjectsForStabilityTest\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Additional options\n   * @param {number} [options.keyRange=10] - Range of key values\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<Object>} Array of objects for stability testing\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateObjectsForStabilityTest(size, options = {}, randomFn = Math.random) {\n    const {\n      keyRange = 10,\n      // Range of key values (smaller = more duplicates)\n      min = 1,\n      max = 100\n    } = options;\n    return Array.from({\n      length: size\n    }, (_, i) => {\n      return {\n        key: min + i % keyRange,\n        // Key to sort by (will have duplicates)\n        originalIndex: i,\n        // Original position (for checking stability)\n        value: Math.floor(randomFn() * (max - min + 1)) + min // Random value\n      };\n    });\n  },\n  /**\n   * Generate a partially K-sorted array\n   * \n   * @function generateKSortedArray\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [k=10] - Maximum distance each element is from its sorted position\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} K-sorted array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateKSortedArray(size, k = 10, min = 1, max = 100, randomFn = Math.random) {\n    // Generate sorted array\n    const sorted = this.generateSortedData(size, min, max);\n    const result = [...sorted];\n\n    // Move each element up to k positions from its sorted position\n    for (let i = 0; i < size; i++) {\n      const maxOffset = Math.min(k, Math.min(i, size - 1 - i));\n      if (maxOffset === 0) continue;\n      const offset = Math.floor(randomFn() * (maxOffset * 2 + 1)) - maxOffset;\n      const newPos = i + offset;\n\n      // Swap elements\n      [result[i], result[newPos]] = [result[newPos], result[i]];\n    }\n    return result;\n  },\n  /**\n   * Generate an array with runs of sorted elements\n   * \n   * @function generateArrayWithSortedRuns\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [runSize=10] - Average size of sorted runs\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array with sorted runs\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateArrayWithSortedRuns(size, runSize = 10, min = 1, max = 100, randomFn = Math.random) {\n    const result = [];\n    let currentPos = 0;\n    while (currentPos < size) {\n      // Determine size of this run (add some randomness)\n      const thisRunSize = Math.min(size - currentPos, Math.max(1, Math.floor(runSize * (0.5 + randomFn()))));\n\n      // Generate a sorted run\n      const runMin = min + Math.floor(randomFn() * (max - min) / 2);\n      const runMax = runMin + Math.floor(randomFn() * (max - runMin));\n      const run = this.generateSortedData(thisRunSize, runMin, runMax);\n\n      // Add to result\n      result.push(...run);\n      currentPos += thisRunSize;\n    }\n    return result;\n  },\n  /**\n   * Generate a rotated sorted array\n   * \n   * @function generateRotatedSortedArray\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number|null} [rotationPoint=null] - Index to rotate at\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Rotated sorted array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateRotatedSortedArray(size, rotationPoint = null, min = 1, max = 100, randomFn = Math.random) {\n    // Generate sorted array\n    const sorted = this.generateSortedData(size, min, max);\n\n    // If rotation point not specified, pick a random one\n    if (rotationPoint === null) {\n      rotationPoint = Math.floor(randomFn() * size);\n    }\n\n    // Ensure rotation point is valid\n    rotationPoint = Math.max(0, Math.min(size - 1, rotationPoint));\n\n    // Perform rotation\n    const result = [...sorted.slice(rotationPoint), ...sorted.slice(0, rotationPoint)];\n    return result;\n  },\n  /**\n   * Generate test data for Dutch national flag problem\n   * \n   * @function generateDutchFlagData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [numValues=3] - Number of unique values\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array for Dutch flag partitioning\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateDutchFlagData(size, numValues = 3, randomFn = Math.random) {\n    return Array.from({\n      length: size\n    }, () => Math.floor(randomFn() * numValues));\n  },\n  /**\n   * Generate data for testing median finding algorithms\n   * \n   * @function generateMedianFindingData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {string} [distribution='uniform'] - Type of distribution\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array for median finding\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateMedianFindingData(size, min = 1, max = 100, distribution = 'uniform', randomFn = Math.random) {\n    // Generate data using the specified distribution\n    let data;\n    switch (distribution.toLowerCase()) {\n      case 'gaussian':\n      case 'normal':\n        data = this.generateGaussianDistribution(size, {\n          min,\n          max\n        }, randomFn);\n        break;\n      case 'exponential':\n        data = this.generateExponentialDistribution(size, {\n          min,\n          max\n        }, randomFn);\n        break;\n      case 'bimodal':\n        data = this.generateBimodalDistribution(size, {\n          min,\n          max\n        }, randomFn);\n        break;\n      case 'few-unique':\n        data = this.generateFewUniqueData(size, min, max, Math.ceil(size / 10), randomFn);\n        break;\n      case 'uniform':\n      default:\n        data = this.generateRandomData(size, min, max, randomFn);\n    }\n    return data;\n  },\n  /**\n   * Generate data for top-K elements problem\n   * \n   * @function generateTopKData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [k=10] - Value of K\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Object} Object with array and the true top-K elements\n   * \n   * @complexity Time: O(n log k) due to sorting the top-k elements\n   * @complexity Space: O(n + k) for the returned array and top-k array\n   */\n  generateTopKData(size, k = 10, min = 1, max = 100, randomFn = Math.random) {\n    // Generate random data\n    const data = this.generateRandomData(size, min, max, randomFn);\n\n    // Find actual top-K elements\n    const sortedCopy = [...data].sort((a, b) => b - a);\n    const topK = sortedCopy.slice(0, k);\n    return {\n      data,\n      topK\n    };\n  },\n  /**\n   * Generate multiple sorted arrays for K-way merge\n   * \n   * @function generateKSortedArrays\n   * @memberof DataGenerators\n   * \n   * @param {number} [k=5] - Number of arrays\n   * @param {number} [avgSize=20] - Average size of each array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {boolean} [enforceRanges=false] - Enforce non-overlapping ranges between arrays\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<Array<number>>} Array of sorted arrays\n   * \n   * @complexity Time: O(k * avgSize) where k is the number of arrays and avgSize is the average size\n   * @complexity Space: O(k * avgSize) for the returned arrays\n   */\n  generateKSortedArrays(k = 5, avgSize = 20, min = 1, max = 100, enforceRanges = false, randomFn = Math.random) {\n    const arrays = [];\n    if (enforceRanges) {\n      // Create non-overlapping ranges for the arrays\n      const rangeStep = (max - min) / k;\n      for (let i = 0; i < k; i++) {\n        // Calculate range for this array\n        const arrayMin = min + i * rangeStep;\n        const arrayMax = arrayMin + rangeStep;\n\n        // Randomize array size around the average\n        const thisSize = Math.max(1, Math.floor(avgSize * (0.5 + randomFn() * 1.5)));\n\n        // Create sorted array\n        const array = this.generateSortedData(thisSize, arrayMin, arrayMax);\n        arrays.push(array);\n      }\n    } else {\n      // Arrays may have overlapping ranges\n      for (let i = 0; i < k; i++) {\n        // Randomize array size around the average\n        const thisSize = Math.max(1, Math.floor(avgSize * (0.5 + randomFn() * 1.5)));\n\n        // Generate array with random range within the overall min-max\n        const arrayMin = min + Math.floor(randomFn() * (max - min) / 2);\n        const arrayMax = arrayMin + Math.floor(randomFn() * (max - arrayMin));\n\n        // Create sorted array\n        const array = this.generateSortedData(thisSize, arrayMin, arrayMax);\n        arrays.push(array);\n      }\n    }\n    return arrays;\n  },\n  /**\n   * Utility to verify if an array is sorted\n   * \n   * @function isSorted\n   * @memberof DataGenerators\n   * \n   * @param {Array} array - Array to check\n   * @param {Function} [comparator=null] - Optional custom comparator\n   * \n   * @returns {boolean} True if array is sorted\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(1) for variables\n   */\n  isSorted(array, comparator = null) {\n    if (array.length <= 1) return true;\n    const compare = comparator || ((a, b) => a < b ? -1 : a > b ? 1 : 0);\n    for (let i = 1; i < array.length; i++) {\n      if (compare(array[i], array[i - 1]) < 0) {\n        return false;\n      }\n    }\n    return true;\n  },\n  /**\n   * Measure how sorted an array is (0 = reverse sorted, 1 = fully sorted)\n   * \n   * @function measureSortedness\n   * @memberof DataGenerators\n   * \n   * @param {Array} array - Array to measure\n   * \n   * @returns {number} Sortedness measure between 0 and 1\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(1) for variables\n   */\n  measureSortedness(array) {\n    if (array.length <= 1) return 1;\n    let inversions = 0;\n    const maxInversions = array.length * (array.length - 1) / 2;\n\n    // Count adjacent inversions (simplified method)\n    for (let i = 0; i < array.length - 1; i++) {\n      if (array[i] > array[i + 1]) {\n        inversions++;\n      }\n    }\n\n    // Convert to a measure between 0 and 1\n    // Note: This is an approximation; a perfect measure would count all inversions\n    return 1 - inversions / (array.length - 1);\n  },\n  /**\n   * Create a dataset with known statistical properties\n   * \n   * @function generateStatisticalDataset\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Statistical parameters\n   * @param {number} [options.mean=50] - Mean of the distribution\n   * @param {number} [options.stdDev=15] - Standard deviation\n   * @param {number} [options.skewness=0] - Skewness (-1 to 1)\n   * @param {number} [options.kurtosis=0] - Kurtosis (-1 to 1)\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array with desired statistical properties\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateStatisticalDataset(size, options = {}, randomFn = Math.random) {\n    const {\n      mean = 50,\n      stdDev = 15,\n      skewness = 0,\n      kurtosis = 0,\n      min = 1,\n      max = 100\n    } = options;\n\n    // Start with a Gaussian distribution\n    let data = this.generateGaussianDistribution(size, {\n      mean,\n      stdDev,\n      min,\n      max\n    }, randomFn);\n\n    // Apply skewness if requested\n    if (skewness !== 0) {\n      data = this._applySkewness(data, skewness, min, max);\n    }\n\n    // Apply kurtosis if requested\n    if (kurtosis !== 0) {\n      data = this._applyKurtosis(data, kurtosis, mean, min, max);\n    }\n    return data;\n  },\n  /**\n   * Apply skewness to a dataset\n   * \n   * @function _applySkewness\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {Array<number>} data - Input data\n   * @param {number} skewness - Desired skewness (-1 to 1)\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * \n   * @returns {Array<number>} Transformed data\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(n) for the returned array\n   */\n  _applySkewness(data, skewness, min, max) {\n    // Simplified transformation for skewness\n    const result = [];\n    const range = max - min;\n    for (let value of data) {\n      // Normalize to 0-1\n      const normalized = (value - min) / range;\n\n      // Apply power transformation for skewness\n      // Positive skewness: longer tail to the right\n      // Negative skewness: longer tail to the left\n      let transformed;\n      if (skewness > 0) {\n        transformed = Math.pow(normalized, 1 / (1 + skewness));\n      } else {\n        transformed = 1 - Math.pow(1 - normalized, 1 / (1 - skewness));\n      }\n\n      // Convert back to original range\n      result.push(min + Math.floor(transformed * range));\n    }\n    return result;\n  },\n  /**\n   * Apply kurtosis to a dataset\n   * \n   * @function _applyKurtosis\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {Array<number>} data - Input data\n   * @param {number} kurtosis - Desired kurtosis adjustment (-1 to 1)\n   * @param {number} mean - Mean value\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * \n   * @returns {Array<number>} Transformed data\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(n) for the returned array\n   */\n  _applyKurtosis(data, kurtosis, mean, min, max) {\n    // Simplified transformation for kurtosis\n    const result = [];\n    for (let value of data) {\n      // Distance from mean\n      const distFromMean = value - mean;\n      let transformed;\n      if (kurtosis > 0) {\n        // Positive kurtosis: heavier tails, more peaked\n        transformed = mean + Math.sign(distFromMean) * Math.pow(Math.abs(distFromMean), 1 + kurtosis);\n      } else {\n        // Negative kurtosis: lighter tails, less peaked\n        transformed = mean + Math.sign(distFromMean) * Math.pow(Math.abs(distFromMean), 1 + kurtosis);\n      }\n\n      // Clamp to range\n      transformed = Math.max(min, Math.min(max, transformed));\n      result.push(Math.floor(transformed));\n    }\n    return result;\n  },\n  /**\n   * Generate custom distribution by combining other distributions\n   * \n   * @function generateCustomDistribution\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Array<Object>} distributions - Array of distribution specs\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Custom distribution\n   * \n   * @example\n   * // Generate a mixture of gaussian and exponential distributions\n   * const data = DataGenerators.generateCustomDistribution(1000, [\n   *   { type: 'gaussian', ratio: 0.7, params: { mean: 30, stdDev: 5 } },\n   *   { type: 'exponential', ratio: 0.3, params: { lambda: 0.1 } }\n   * ]);\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateCustomDistribution(size, distributions, min = 1, max = 100, randomFn = Math.random) {\n    const result = [];\n    let remaining = size;\n    for (let i = 0; i < distributions.length && remaining > 0; i++) {\n      const dist = distributions[i];\n      const count = i === distributions.length - 1 ? remaining : Math.floor(size * dist.ratio);\n\n      // Generate data according to this distribution\n      let data;\n      switch (dist.type) {\n        case 'gaussian':\n        case 'normal':\n          data = this.generateGaussianDistribution(count, {\n            min: dist.min !== undefined ? dist.min : min,\n            max: dist.max !== undefined ? dist.max : max,\n            ...(dist.params || {})\n          }, randomFn);\n          break;\n        case 'exponential':\n          data = this.generateExponentialDistribution(count, {\n            min: dist.min !== undefined ? dist.min : min,\n            max: dist.max !== undefined ? dist.max : max,\n            ...(dist.params || {})\n          }, randomFn);\n          break;\n        case 'bimodal':\n          data = this.generateBimodalDistribution(count, {\n            min: dist.min !== undefined ? dist.min : min,\n            max: dist.max !== undefined ? dist.max : max,\n            ...(dist.params || {})\n          }, randomFn);\n          break;\n        case 'uniform':\n        default:\n          data = this.generateRandomData(count, dist.min !== undefined ? dist.min : min, dist.max !== undefined ? dist.max : max, randomFn);\n      }\n      result.push(...data);\n      remaining -= count;\n    }\n\n    // Shuffle to mix the distributions\n    return this._shuffleArray(result, randomFn);\n  },\n  /**\n   * Shuffle an array using Fisher-Yates algorithm\n   * \n   * @function _shuffleArray\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {Array} array - Array to shuffle\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array} Shuffled array\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(1) for in-place shuffle\n   */\n  _shuffleArray(array, randomFn = Math.random) {\n    const result = [...array];\n    for (let i = result.length - 1; i > 0; i--) {\n      const j = Math.floor(randomFn() * (i + 1));\n      [result[i], result[j]] = [result[j], result[i]];\n    }\n    return result;\n  },\n  /**\n   * Create a seeded random number generator\n   * \n   * @function _createSeededRandom\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} seed - Seed value for the generator\n   * \n   * @returns {Function} Seeded random function\n   * \n   * @complexity Time: O(1) per call\n   * @complexity Space: O(1) for variables\n   */\n  _createSeededRandom(seed) {\n    // Simple xorshift algorithm for seeded random generation\n    let state = seed;\n    return function () {\n      // xorshift algorithm\n      state ^= state << 13;\n      state ^= state >>> 17;\n      state ^= state << 5;\n\n      // Normalize to [0, 1)\n      return (state >>> 0) / 4294967296;\n    };\n  },\n  /**\n   * Calculate basic statistics for an array\n   * \n   * @function calculateStatistics\n   * @memberof DataGenerators\n   * \n   * @param {Array<number>} array - Array to analyze\n   * \n   * @returns {Object} Object containing statistical measures\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(1) for variables\n   */\n  calculateStatistics(array) {\n    if (array.length === 0) {\n      return {\n        min: NaN,\n        max: NaN,\n        mean: NaN,\n        median: NaN,\n        standardDeviation: NaN\n      };\n    }\n\n    // Calculate min and max\n    let min = array[0];\n    let max = array[0];\n\n    // Calculate sum for mean\n    let sum = 0;\n    for (let i = 0; i < array.length; i++) {\n      const value = array[i];\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n      sum += value;\n    }\n\n    // Calculate mean\n    const mean = sum / array.length;\n\n    // Calculate median\n    const sortedArr = [...array].sort((a, b) => a - b);\n    const midIdx = Math.floor(array.length / 2);\n    const median = array.length % 2 === 0 ? (sortedArr[midIdx - 1] + sortedArr[midIdx]) / 2 : sortedArr[midIdx];\n\n    // Calculate standard deviation\n    let variance = 0;\n    for (let i = 0; i < array.length; i++) {\n      const diff = array[i] - mean;\n      variance += diff * diff;\n    }\n    variance /= array.length;\n    const standardDeviation = Math.sqrt(variance);\n    return {\n      min,\n      max,\n      mean,\n      median,\n      standardDeviation\n    };\n  },\n  /**\n   * Generate a dataset that's specifically designed to test a given sorting algorithm\n   * \n   * @function generateTestCase\n   * @memberof DataGenerators\n   * \n   * @param {string} algorithm - Algorithm name\n   * @param {string} testCase - Test case type ('best', 'worst', 'average')\n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Additional options\n   * \n   * @returns {Array<number>} Array for testing\n   * \n   * @complexity Varies depending on algorithm and test case\n   */\n  generateTestCase(algorithm, testCase, size, options = {}) {\n    const lowerAlgo = algorithm.toLowerCase();\n    const lowerCase = testCase.toLowerCase();\n    if (lowerCase === 'worst') {\n      // Generate worst case for the specified algorithm\n      return this.generateAdversarialCase(lowerAlgo, size, options);\n    } else if (lowerCase === 'best') {\n      // Generate best case for the specified algorithm\n      switch (lowerAlgo) {\n        case 'insertionsort':\n        case 'bubblesort':\n          return this.generateSortedData(size, options.min, options.max);\n        case 'quicksort':\n          // Best case for quicksort is typically a balanced partition\n          return this.generateRandomData(size, options.min, options.max);\n        case 'mergesort':\n          // Mergesort is relatively insensitive to input order\n          return this.generateRandomData(size, options.min, options.max);\n        default:\n          // For unknown algorithms, return a random array\n          return this.generateRandomData(size, options.min, options.max);\n      }\n    } else {\n      // Average case - usually a random array\n      return this.generateRandomData(size, options.min, options.max);\n    }\n  },\n  /**\n   * Generate a dataset that gradually transitions from one pattern to another\n   * \n   * @function generateTransitionData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {string} startPattern - Starting pattern type\n   * @param {string} endPattern - Ending pattern type\n   * @param {number} [transitionPoint=0.5] - Position of transition (0-1)\n   * @param {Object} [options={}] - Additional options\n   * \n   * @returns {Array<number>} Array with transition\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateTransitionData(size, startPattern, endPattern, transitionPoint = 0.5, options = {}) {\n    // Generate data for both patterns\n    const firstSize = Math.floor(size * transitionPoint);\n    const secondSize = size - firstSize;\n    const firstData = this.generateDataSet(startPattern, firstSize, options);\n    const secondData = this.generateDataSet(endPattern, secondSize, options);\n\n    // Combine the data\n    return [...firstData, ...secondData];\n  },\n  /**\n   * Generate a dataset with known duplicates pattern\n   * \n   * @function generateDuplicatesPattern\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [uniqueCount=10] - Number of unique values\n   * @param {string} [pattern='random'] - Pattern of duplicates ('random', 'blocks', 'interleaved')\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array with duplicates pattern\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array, plus O(uniqueCount) for unique values\n   */\n  generateDuplicatesPattern(size, uniqueCount = 10, pattern = 'random', min = 1, max = 100, randomFn = Math.random) {\n    // Generate unique values\n    const uniqueValues = [];\n    for (let i = 0; i < uniqueCount; i++) {\n      uniqueValues.push(min + Math.floor((max - min) * i / uniqueCount));\n    }\n    const result = [];\n    switch (pattern.toLowerCase()) {\n      case 'blocks':\n        // Generate blocks of duplicate values\n        const blockSize = Math.floor(size / uniqueCount);\n        for (let i = 0; i < uniqueCount; i++) {\n          const value = uniqueValues[i];\n          for (let j = 0; j < blockSize; j++) {\n            result.push(value);\n          }\n        }\n\n        // Fill any remaining spots\n        while (result.length < size) {\n          result.push(uniqueValues[uniqueCount - 1]);\n        }\n        break;\n      case 'interleaved':\n        // Generate interleaved pattern of duplicate values\n        for (let i = 0; i < size; i++) {\n          result.push(uniqueValues[i % uniqueCount]);\n        }\n        break;\n      case 'random':\n      default:\n        // Random distribution of duplicates\n        for (let i = 0; i < size; i++) {\n          const idx = Math.floor(randomFn() * uniqueCount);\n          result.push(uniqueValues[idx]);\n        }\n    }\n    return result;\n  }\n};\nexport default DataGenerators;","map":{"version":3,"names":["DataGenerators","generateDataSet","type","size","options","Number","isInteger","TypeError","min","max","uniqueValues","sortedRatio","reversedRatio","seed","undefined","RangeError","randomFn","Math","random","seededRandom","_createSeededRandom","toLowerCase","generateRandomData","generateNearlySortedData","generateReversedData","generateFewUniqueData","generateSortedData","generateSawtoothData","generatePlateauData","plateau","_shuffleArray","generatePipeOrganData","generateSortedBlocksData","blockSize","floor","generateGaussianDistribution","mean","stdDev","console","warn","Array","from","length","descending","step","result","_","i","round","reverse","ratio","sorted","reversed","shuffleCount","idx1","idx2","maxDistance","offset","uniqueCount","value","push","teethCount","teethSize","ceil","toothIdx","posInTooth","progress","plateauCount","sqrt","plateauSize","plateauValues","prevValue","maxValue","minValue","plateauIdx","midpoint","data","blockEnd","block","slice","sort","a","b","num","u1","u2","z0","log","cos","PI","generateExponentialDistribution","lambda","range","u","generateBimodalDistribution","mean1","stdDev1","mean2","stdDev2","useFirst","generateAdversarialCase","algorithm","_generateQuicksortAdversarial","_generateMergesortAdversarial","_generateInsertionSortAdversarial","_generateHeapSortAdversarial","_generateShellSortAdversarial","pivotStrategy","_generateSpecialPattern","_generateMedianOfThreeAdversarial","halfSize","mod","medianVal","runLength","currentRunLength","ascending","pos","localValue","splice","idx3","idx4","fill","generateObjectsForStabilityTest","keyRange","key","originalIndex","generateKSortedArray","k","maxOffset","newPos","generateArrayWithSortedRuns","runSize","currentPos","thisRunSize","runMin","runMax","run","generateRotatedSortedArray","rotationPoint","generateDutchFlagData","numValues","generateMedianFindingData","distribution","generateTopKData","sortedCopy","topK","generateKSortedArrays","avgSize","enforceRanges","arrays","rangeStep","arrayMin","arrayMax","thisSize","array","isSorted","comparator","compare","measureSortedness","inversions","maxInversions","generateStatisticalDataset","skewness","kurtosis","_applySkewness","_applyKurtosis","normalized","transformed","pow","distFromMean","sign","abs","generateCustomDistribution","distributions","remaining","dist","count","params","j","state","calculateStatistics","NaN","median","standardDeviation","sum","sortedArr","midIdx","variance","diff","generateTestCase","testCase","lowerAlgo","lowerCase","generateTransitionData","startPattern","endPattern","transitionPoint","firstSize","secondSize","firstData","secondData","generateDuplicatesPattern","pattern","idx"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/data/generators.js"],"sourcesContent":["/**\n * @file generators.js\n * @author Algorithm Visualization Platform Team\n * @version 3.0.0\n * \n * @description\n * Comprehensive data generation utilities for algorithm visualization and performance analysis.\n * This module provides statistical, mathematical, and algorithmic tools for generating datasets\n * with specific properties, distributions, and characteristics that demonstrate algorithm behavior\n * under various conditions.\n * \n * Each generator is designed with configurable parameters, ensuring precise control over\n * dataset properties while maintaining mathematical rigor in distribution characteristics.\n * All generators include detailed complexity analysis and performance considerations.\n * \n * Features:\n * - Multiple distribution types (uniform, Gaussian, exponential, etc.)\n * - Sorted and partially-sorted data generation\n * - Special pattern generators (sawtooth, plateau, stepped, etc.)\n * - Adversarial case generators for specific algorithms\n * - Statistical property control (skewness, kurtosis)\n * - Duplicates and unique value control\n * - Selection algorithm test case generators\n * - Verification and validation utilities\n */\n\n/**\n * @namespace DataGenerators\n * @description Comprehensive set of data generation utilities\n */\nconst DataGenerators = {\n  /**\n   * Generate a dataset based on specified type and parameters\n   * \n   * @function generateDataSet\n   * @memberof DataGenerators\n   * \n   * @param {string} type - Type of data set to generate\n   * @param {number} size - Size of data set\n   * @param {Object} [options={}] - Configuration options\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {number} [options.uniqueValues=10] - Number of unique values for few-unique type\n   * @param {number} [options.sortedRatio=0.9] - Ratio of sortedness for nearly-sorted type\n   * @param {number} [options.reversedRatio=0.9] - Ratio of reversedness for reversed type\n   * @param {number} [options.seed] - Random seed for reproducible generation\n   * \n   * @returns {Array<number>} Generated data set\n   * \n   * @throws {TypeError} If parameters are of incorrect type\n   * @throws {RangeError} If parameters are out of acceptable range\n   * \n   * @example\n   * // Generate a nearly sorted array of 100 elements\n   * const nearlySorted = DataGenerators.generateDataSet('nearly-sorted', 100, { sortedRatio: 0.8 });\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateDataSet(type, size, options = {}) {\n    // Parameter validation\n    if (typeof size !== 'number' || size < 0 || !Number.isInteger(size)) {\n      throw new TypeError('Size must be a non-negative integer');\n    }\n\n    // Apply defaults with ES6 destructuring and defaults\n    const {\n      min = 1,\n      max = 100,\n      uniqueValues = 10,\n      sortedRatio = 0.9,\n      reversedRatio = 0.9,\n      seed = undefined\n    } = options;\n\n    // Validate ranges\n    if (min > max) {\n      throw new RangeError('Minimum value must be less than or equal to maximum value');\n    }\n\n    if (uniqueValues <= 0) {\n      throw new RangeError('Number of unique values must be positive');\n    }\n\n    if (sortedRatio < 0 || sortedRatio > 1) {\n      throw new RangeError('Sorted ratio must be between 0 and 1');\n    }\n\n    if (reversedRatio < 0 || reversedRatio > 1) {\n      throw new RangeError('Reversed ratio must be between 0 and 1');\n    }\n\n    // If seed is provided, initialize PRNG\n    let randomFn = Math.random;\n    if (seed !== undefined) {\n      const seededRandom = this._createSeededRandom(seed);\n      randomFn = seededRandom;\n    }\n\n    // Select appropriate generator based on type\n    switch (type.toLowerCase()) {\n      case 'random':\n        return this.generateRandomData(size, min, max, randomFn);\n      case 'nearly-sorted':\n        return this.generateNearlySortedData(size, min, max, sortedRatio, randomFn);\n      case 'reversed':\n        return this.generateReversedData(size, min, max, reversedRatio, randomFn);\n      case 'few-unique':\n        return this.generateFewUniqueData(size, min, max, uniqueValues, randomFn);\n      case 'sorted':\n        return this.generateSortedData(size, min, max);\n      case 'sawtooth':\n        return this.generateSawtoothData(size, min, max);\n      case 'plateau':\n        return this.generatePlateauData(size, min, max, randomFn);\n      case 'shuffled-plateau':\n        const plateau = this.generatePlateauData(size, min, max, randomFn);\n        return this._shuffleArray(plateau, randomFn);\n      case 'pipe-organ':\n        return this.generatePipeOrganData(size, min, max);\n      case 'sorted-blocks':\n        return this.generateSortedBlocksData(size, min, max, options.blockSize || Math.floor(size / 10), randomFn);\n      case 'gaussian':\n        return this.generateGaussianDistribution(size, {\n          mean: (min + max) / 2,\n          stdDev: (max - min) / 6,  // ~99.7% of values within range\n          min,\n          max,\n          ...options\n        }, randomFn);\n      default:\n        console.warn(`Unknown data set type: ${type}, using random instead`);\n        return this.generateRandomData(size, min, max, randomFn);\n    }\n  },\n\n  /**\n   * Generate a random array of numbers with uniform distribution\n   * \n   * @function generateRandomData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Random array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateRandomData(size, min = 1, max = 100, randomFn = Math.random) {\n    return Array.from({ length: size }, () => \n      Math.floor(randomFn() * (max - min + 1)) + min\n    );\n  },\n\n  /**\n   * Generate a sorted array of numbers\n   * \n   * @function generateSortedData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {boolean} [descending=false] - Whether to sort in descending order\n   * \n   * @returns {Array<number>} Sorted array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateSortedData(size, min = 1, max = 100, descending = false) {\n    if (size <= 0) return [];\n    \n    const step = (max - min) / (size - 1 || 1);\n    const result = Array.from({ length: size }, (_, i) => \n      Math.round(min + i * step)\n    );\n    \n    return descending ? result.reverse() : result;\n  },\n\n  /**\n   * Generate a reversed (descending) array of numbers\n   * \n   * @function generateReversedData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {number} [ratio=0.9] - How reversed the array should be (0-1)\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Reversed array with specified disorder\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateReversedData(size, min = 1, max = 100, ratio = 0.9, randomFn = Math.random) {\n    // First generate sorted array\n    const sorted = this.generateSortedData(size, min, max);\n    \n    // Completely reversed\n    if (ratio >= 1) {\n      return sorted.reverse();\n    }\n    \n    // Partially reversed\n    const reversed = sorted.reverse();\n    const result = [...reversed];\n    \n    // Shuffle some elements to make it less perfectly reversed\n    const shuffleCount = Math.floor(size * (1 - ratio));\n    for (let i = 0; i < shuffleCount; i++) {\n      const idx1 = Math.floor(randomFn() * size);\n      const idx2 = Math.floor(randomFn() * size);\n      [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate a nearly sorted array of numbers\n   * \n   * @function generateNearlySortedData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {number} [ratio=0.9] - How sorted the array should be (0-1)\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Nearly sorted array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateNearlySortedData(size, min = 1, max = 100, ratio = 0.9, randomFn = Math.random) {\n    // Generate sorted array\n    const result = this.generateSortedData(size, min, max);\n    \n    // Determine how many elements to shuffle\n    const shuffleCount = Math.floor(size * (1 - ratio));\n    \n    // Shuffle random pairs of elements\n    for (let i = 0; i < shuffleCount; i++) {\n      const idx1 = Math.floor(randomFn() * size);\n      \n      // Keep swaps relatively local for more realistic nearly-sorted data\n      const maxDistance = Math.max(5, Math.floor(size * 0.1));\n      const offset = Math.floor(randomFn() * maxDistance) - Math.floor(maxDistance / 2);\n      const idx2 = Math.max(0, Math.min(size - 1, idx1 + offset));\n      \n      [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate an array with few unique values\n   * \n   * @function generateFewUniqueData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {number} [uniqueCount=10] - Number of unique values\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array with few unique values\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array, plus O(uniqueCount) for the unique values\n   */\n  generateFewUniqueData(size, min = 1, max = 100, uniqueCount = 10, randomFn = Math.random) {\n    // Ensure uniqueCount isn't larger than the possible range\n    uniqueCount = Math.min(uniqueCount, max - min + 1);\n    \n    // Generate the unique values\n    const uniqueValues = [];\n    for (let i = 0; i < uniqueCount; i++) {\n      const value = Math.floor(min + (i * (max - min) / (uniqueCount - 1 || 1)));\n      uniqueValues.push(value);\n    }\n    \n    // Create array by randomly selecting from unique values\n    return Array.from({ length: size }, () => \n      uniqueValues[Math.floor(randomFn() * uniqueCount)]\n    );\n  },\n\n  /**\n   * Generate a sawtooth pattern array\n   * \n   * @function generateSawtoothData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {number} [teethCount] - Number of teeth in the pattern (defaults to size/20)\n   * \n   * @returns {Array<number>} Sawtooth pattern array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateSawtoothData(size, min = 1, max = 100, teethCount = null) {\n    // Default teeth count is related to array size\n    if (teethCount === null) {\n      teethCount = Math.max(2, Math.floor(size / 20));\n    }\n    \n    const teethSize = Math.ceil(size / teethCount);\n    const result = [];\n    \n    for (let i = 0; i < size; i++) {\n      // Determine which tooth this element belongs to\n      const toothIdx = Math.floor(i / teethSize);\n      // Position within the current tooth\n      const posInTooth = i % teethSize;\n      // Value increases within each tooth, then drops for the next tooth\n      const progress = posInTooth / teethSize;\n      const value = min + Math.floor(progress * (max - min));\n      \n      result.push(value);\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate a plateau pattern array (sections of same values)\n   * \n   * @function generatePlateauData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Plateau pattern array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array, plus O(plateauCount) for plateau values\n   */\n  generatePlateauData(size, min = 1, max = 100, randomFn = Math.random) {\n    // Determine number of plateaus\n    const plateauCount = Math.max(2, Math.floor(Math.sqrt(size)));\n    const plateauSize = Math.floor(size / plateauCount);\n    const result = [];\n    \n    // Generate plateau values in ascending order\n    const plateauValues = [];\n    for (let i = 0; i < plateauCount; i++) {\n      // Add some randomness to plateau values while maintaining order\n      const prevValue = i > 0 ? plateauValues[i-1] : min - 1;\n      const maxValue = min + Math.floor((i + 1) / plateauCount * (max - min));\n      const minValue = i === 0 ? min : prevValue + 1;\n      plateauValues.push(minValue + Math.floor(randomFn() * (maxValue - minValue + 1)));\n    }\n    \n    // Build the array\n    for (let i = 0; i < size; i++) {\n      const plateauIdx = Math.min(plateauCount - 1, Math.floor(i / plateauSize));\n      result.push(plateauValues[plateauIdx]);\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate a pipe organ pattern (ascending then descending)\n   * \n   * @function generatePipeOrganData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * \n   * @returns {Array<number>} Pipe organ pattern array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generatePipeOrganData(size, min = 1, max = 100) {\n    const result = [];\n    const midpoint = Math.floor(size / 2);\n    const step = (max - min) / midpoint;\n    \n    // Generate ascending part\n    for (let i = 0; i < midpoint; i++) {\n      result.push(Math.round(min + i * step));\n    }\n    \n    // Generate descending part\n    for (let i = 0; i < size - midpoint; i++) {\n      result.push(Math.round(max - i * step));\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate data with sorted blocks\n   * \n   * @function generateSortedBlocksData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {number} [blockSize=10] - Size of sorted blocks\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array with sorted blocks\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateSortedBlocksData(size, min = 1, max = 100, blockSize = 10, randomFn = Math.random) {\n    // Generate random data\n    const data = this.generateRandomData(size, min, max, randomFn);\n    const result = [];\n    \n    // Sort blocks\n    for (let i = 0; i < size; i += blockSize) {\n      const blockEnd = Math.min(i + blockSize, size);\n      const block = data.slice(i, blockEnd).sort((a, b) => a - b);\n      result.push(...block);\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate a Gaussian (normal) distribution\n   * \n   * @function generateGaussianDistribution\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Distribution parameters\n   * @param {number} [options.mean=50] - Mean of the distribution\n   * @param {number} [options.stdDev=15] - Standard deviation\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Gaussian distribution array\n   * \n   * @complexity Time: O(n) where n is the size parameter, with potential rejection sampling\n   * @complexity Space: O(n) for the returned array\n   */\n  generateGaussianDistribution(size, options = {}, randomFn = Math.random) {\n    const {\n      mean = 50,\n      stdDev = 15,\n      min = 1,\n      max = 100\n    } = options;\n    \n    const result = [];\n    \n    // Box-Muller transform for Gaussian distribution\n    for (let i = 0; i < size; i++) {\n      let num;\n      do {\n        // Generate normal distribution with desired mean and std dev\n        const u1 = randomFn();\n        const u2 = randomFn();\n        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);\n        num = Math.round(z0 * stdDev + mean);\n      } while (num < min || num > max); // Ensure within range with rejection sampling\n      \n      result.push(num);\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate an exponential distribution\n   * \n   * @function generateExponentialDistribution\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Distribution parameters\n   * @param {number} [options.lambda=0.1] - Rate parameter\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Exponential distribution array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateExponentialDistribution(size, options = {}, randomFn = Math.random) {\n    const {\n      lambda = 0.1,\n      min = 1,\n      max = 100\n    } = options;\n    \n    const result = [];\n    const range = max - min;\n    \n    for (let i = 0; i < size; i++) {\n      // Generate exponential distribution\n      const u = randomFn();\n      const value = min + Math.round((-Math.log(1 - u) / lambda) % range);\n      result.push(Math.min(value, max));\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate a bimodal distribution (two peaks)\n   * \n   * @function generateBimodalDistribution\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Distribution parameters\n   * @param {number} [options.mean1=25] - Mean of first distribution\n   * @param {number} [options.stdDev1=10] - Standard deviation of first distribution\n   * @param {number} [options.mean2=75] - Mean of second distribution\n   * @param {number} [options.stdDev2=10] - Standard deviation of second distribution\n   * @param {number} [options.ratio=0.5] - Ratio of values from first distribution\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Bimodal distribution array\n   * \n   * @complexity Time: O(n) where n is the size parameter, with potential rejection sampling\n   * @complexity Space: O(n) for the returned array\n   */\n  generateBimodalDistribution(size, options = {}, randomFn = Math.random) {\n    const {\n      mean1 = 25,\n      stdDev1 = 10,\n      mean2 = 75,\n      stdDev2 = 10,\n      ratio = 0.5,\n      min = 1,\n      max = 100\n    } = options;\n    \n    const result = [];\n    \n    for (let i = 0; i < size; i++) {\n      let num;\n      do {\n        // Decide which distribution to use\n        const useFirst = randomFn() < ratio;\n        \n        // Generate value from selected distribution\n        const mean = useFirst ? mean1 : mean2;\n        const stdDev = useFirst ? stdDev1 : stdDev2;\n        \n        // Box-Muller transform\n        const u1 = randomFn();\n        const u2 = randomFn();\n        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);\n        num = Math.round(z0 * stdDev + mean);\n      } while (num < min || num > max); // Ensure within range\n      \n      result.push(num);\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate an array that's challenging for a specific algorithm\n   * \n   * @function generateAdversarialCase\n   * @memberof DataGenerators\n   * \n   * @param {string} algorithm - Algorithm name\n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Additional options\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {string} [options.pivotStrategy] - Pivot strategy for quicksort\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for the algorithm\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateAdversarialCase(algorithm, size, options = {}, randomFn = Math.random) {\n    const {\n      min = 1,\n      max = 100\n    } = options;\n    \n    // Select appropriate adversarial case\n    switch (algorithm.toLowerCase()) {\n      case 'quicksort':\n        return this._generateQuicksortAdversarial(size, min, max, options, randomFn);\n      case 'mergesort':\n        return this._generateMergesortAdversarial(size, min, max, randomFn);\n      case 'insertionsort':\n        return this._generateInsertionSortAdversarial(size, min, max);\n      case 'heapsort':\n        return this._generateHeapSortAdversarial(size, min, max, randomFn);\n      case 'bubblesort':\n        return this.generateReversedData(size, min, max, 1);\n      case 'shellsort':\n        return this._generateShellSortAdversarial(size, min, max, randomFn);\n      default:\n        // Default to reversed for unknown algorithms\n        return this.generateReversedData(size, min, max, 1);\n    }\n  },\n\n  /**\n   * Generate an adversarial case for Quicksort\n   * \n   * @function _generateQuicksortAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @param {Object} options - Additional options\n   * @param {string} [options.pivotStrategy='first'] - Pivot strategy\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for Quicksort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateQuicksortAdversarial(size, min, max, options = {}, randomFn = Math.random) {\n    const { pivotStrategy = 'first' } = options;\n    \n    switch (pivotStrategy) {\n      case 'first':\n        // Worst case for first-element pivot is already sorted\n        return this.generateSortedData(size, min, max);\n      case 'last':\n        // Worst case for last-element pivot is reversed\n        return this.generateReversedData(size, min, max, 1);\n      case 'middle':\n        // Create a pattern where middle elements are bad pivots\n        return this._generateSpecialPattern(size, min, max);\n      case 'median-of-three':\n        // More complex pattern needed for median-of-three\n        return this._generateMedianOfThreeAdversarial(size, min, max, randomFn);\n      case 'random':\n        // Hard to create a true adversarial case for random pivot\n        // but we can create a degenerate distribution\n        return this.generateFewUniqueData(size, min, max, 2, randomFn);\n      default:\n        return this.generateSortedData(size, min, max);\n    }\n  },\n\n  /**\n   * Generate a special pattern for quicksort with middle pivot\n   * \n   * @function _generateSpecialPattern\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * \n   * @returns {Array<number>} Special pattern array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateSpecialPattern(size, min, max) {\n    const result = [];\n    const range = max - min;\n    \n    // Create a pattern where pivoting on middle gives unbalanced partitions\n    // This works by arranging values so that partitioning around the middle\n    // element consistently creates very unbalanced partitions\n    for (let i = 0; i < size; i++) {\n      const halfSize = Math.floor(size / 2);\n      let value;\n      \n      if (i < halfSize) {\n        // First half of array: create values that are all less than middle\n        value = min + Math.floor((i / halfSize) * (range / 3));\n      } else {\n        // Second half: create values that are all greater than middle\n        // but clustered near middle to make poor partitioning\n        value = min + Math.floor(range / 2) + Math.floor(((i - halfSize) / (size - halfSize)) * (range / 2));\n      }\n      \n      result.push(value);\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate adversarial case for median-of-three quicksort\n   * \n   * @function _generateMedianOfThreeAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for median-of-three quicksort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateMedianOfThreeAdversarial(size, min, max, randomFn = Math.random) {\n    // This requires a complex pattern that would defeat median-of-three\n    // We'll use a \"fat pivot\" approach with many repeated elements\n    \n    const result = [];\n    const step = (max - min) / (size - 1 || 1);\n    \n    // Build an array that will tend to select poor pivots\n    // by creating local patterns where the median is often a poor choice\n    for (let i = 0; i < size; i++) {\n      const mod = i % 3;\n      \n      if (mod === 0) {\n        // Every third element is a large value - middle of triplet\n        result.push(min + Math.floor((size - i) * step * 0.8));\n      } else if (mod === 1) {\n        // Every third + 1 element is at the median\n        const medianVal = min + Math.floor(i * step * 0.5);\n        result.push(medianVal);\n      } else {\n        // Every third + 2 element is a small value\n        result.push(min + Math.floor(i * step * 0.3));\n      }\n    }\n    \n    // Add some random shuffling to avoid too obvious patterns\n    for (let i = 0; i < size / 3; i++) {\n      const idx1 = Math.floor(randomFn() * size);\n      const idx2 = Math.floor(randomFn() * size);\n      if (idx1 % 3 === idx2 % 3) { // Only swap elements in the same mod class\n        [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n      }\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate adversarial case for mergesort\n   * \n   * @function _generateMergesortAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for mergesort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateMergesortAdversarial(size, min, max, randomFn = Math.random) {\n    // Mergesort is typically O(n log n) regardless of input\n    // but a pattern that maximizes comparisons and pathological merging can be constructed\n    \n    const result = [];\n    const step = (max - min) / (size - 1 || 1);\n    \n    // Pattern designed to increase merge complexity:\n    // - Create \"runs\" of already sorted data in reverse order\n    // - This forces the merge operation to always interleave elements\n    \n    // Generate sorted runs of power-of-two lengths\n    let runLength = 1;\n    while (runLength * 2 <= size) {\n      runLength *= 2;\n    }\n    \n    // Generate each run in alternating order to maximize merging cost\n    let offset = 0;\n    while (offset < size) {\n      const currentRunLength = Math.min(runLength, size - offset);\n      const ascending = ((offset / runLength) % 2 === 0);\n      \n      for (let i = 0; i < currentRunLength; i++) {\n        const pos = offset + i;\n        const localValue = min + Math.floor(pos * step);\n        \n        if (ascending) {\n          result.push(localValue);\n        } else {\n          // Insert at the beginning of the current run\n          result.splice(offset, 0, localValue);\n        }\n      }\n      \n      offset += currentRunLength;\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate adversarial case for insertion sort\n   * \n   * @function _generateInsertionSortAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * \n   * @returns {Array<number>} Adversarial array for insertion sort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateInsertionSortAdversarial(size, min, max) {\n    // Worst case for insertion sort is reversed order\n    return this.generateReversedData(size, min, max, 1);\n  },\n\n  /**\n   * Generate adversarial case for heap sort\n   * \n   * @function _generateHeapSortAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for heap sort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateHeapSortAdversarial(size, min, max, randomFn = Math.random) {\n    // Heap sort is typically O(n log n) regardless of input\n    // but certain patterns can maximize the number of heapify operations\n    \n    const result = [];\n    const step = (max - min) / (size - 1 || 1);\n    \n    // Build an array that will require many sift-down operations\n    // For heap sort, a good adversarial case is a pattern where each\n    // heapify operation involves many comparisons and swaps\n    \n    // Fill the first half with ascending values (base of heap)\n    for (let i = 0; i < Math.floor(size / 2); i++) {\n      result.push(min + Math.floor(i * step));\n    }\n    \n    // Fill the second half with larger values in decreasing order\n    // This creates a situation where many elements will need heapification\n    for (let i = Math.floor(size / 2); i < size; i++) {\n      result.push(max - Math.floor((i - size / 2) * step));\n    }\n    \n    // Shuffle the result a bit to avoid too obvious pattern detection\n    // But maintain the general structure that makes heap sort work harder\n    for (let i = 0; i < size / 4; i++) {\n      const idx1 = Math.floor(randomFn() * (size / 2));\n      const idx2 = Math.floor(randomFn() * (size / 2));\n      [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n      \n      const idx3 = Math.floor(size / 2) + Math.floor(randomFn() * (size / 2));\n      const idx4 = Math.floor(size / 2) + Math.floor(randomFn() * (size / 2));\n      [result[idx3], result[idx4]] = [result[idx4], result[idx3]];\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate adversarial case for shell sort\n   * \n   * @function _generateShellSortAdversarial\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} size - Size of array\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array<number>} Adversarial array for shell sort\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  _generateShellSortAdversarial(size, min, max, randomFn = Math.random) {\n    // Shell sort performance is heavily dependent on the gap sequence\n    // A good adversarial case would have elements arranged to maximize\n    // the number of comparisons and swaps for common gap sequences\n    \n    // Create an array with elements positioned to require maximum movement\n    const result = Array(size).fill(0);\n    const range = max - min;\n    \n    // Common gap sequences:\n    // - Shell's original: n/2, n/4, ..., 1\n    // - Knuth's: 1, 4, 13, 40, 121, ...\n    // - Sedgewick's: 1, 8, 23, 77, 281, 1073, 4193, ...\n    \n    // Start with a pattern that's adversarial for the first gap (usually n/2)\n    for (let i = 0; i < size; i++) {\n      // Position elements to maximize swaps with typical gap sequences\n      // by alternating large and small values in positions that will be compared\n      if (i % 2 === 0) {\n        result[i] = max - Math.floor((i / size) * range * 0.5);\n      } else {\n        result[i] = min + Math.floor((i / size) * range * 0.5);\n      }\n    }\n    \n    // Add a further pattern to defeat later gap sequences\n    for (let i = 0; i < size; i += 4) {\n      if (i + 3 < size) {\n        // Re-arrange groups of 4 elements to maximize swaps for smaller gaps\n        [result[i], result[i + 3]] = [result[i + 3], result[i]];\n        [result[i + 1], result[i + 2]] = [result[i + 2], result[i + 1]];\n      }\n    }\n    \n    return result;\n  },\n\n  /**\n   * Create an array of custom objects for testing stability\n   * \n   * @function generateObjectsForStabilityTest\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Additional options\n   * @param {number} [options.keyRange=10] - Range of key values\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<Object>} Array of objects for stability testing\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateObjectsForStabilityTest(size, options = {}, randomFn = Math.random) {\n    const {\n      keyRange = 10,  // Range of key values (smaller = more duplicates)\n      min = 1,\n      max = 100\n    } = options;\n    \n    return Array.from({ length: size }, (_, i) => {\n      return {\n        key: min + (i % keyRange),  // Key to sort by (will have duplicates)\n        originalIndex: i,          // Original position (for checking stability)\n        value: Math.floor(randomFn() * (max - min + 1)) + min  // Random value\n      };\n    });\n  },\n\n  /**\n   * Generate a partially K-sorted array\n   * \n   * @function generateKSortedArray\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [k=10] - Maximum distance each element is from its sorted position\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} K-sorted array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateKSortedArray(size, k = 10, min = 1, max = 100, randomFn = Math.random) {\n    // Generate sorted array\n    const sorted = this.generateSortedData(size, min, max);\n    const result = [...sorted];\n    \n    // Move each element up to k positions from its sorted position\n    for (let i = 0; i < size; i++) {\n      const maxOffset = Math.min(k, Math.min(i, size - 1 - i));\n      if (maxOffset === 0) continue;\n      \n      const offset = Math.floor(randomFn() * (maxOffset * 2 + 1)) - maxOffset;\n      const newPos = i + offset;\n      \n      // Swap elements\n      [result[i], result[newPos]] = [result[newPos], result[i]];\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate an array with runs of sorted elements\n   * \n   * @function generateArrayWithSortedRuns\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [runSize=10] - Average size of sorted runs\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array with sorted runs\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateArrayWithSortedRuns(size, runSize = 10, min = 1, max = 100, randomFn = Math.random) {\n    const result = [];\n    let currentPos = 0;\n    \n    while (currentPos < size) {\n      // Determine size of this run (add some randomness)\n      const thisRunSize = Math.min(\n        size - currentPos, \n        Math.max(1, Math.floor(runSize * (0.5 + randomFn())))\n      );\n      \n      // Generate a sorted run\n      const runMin = min + Math.floor(randomFn() * (max - min) / 2);\n      const runMax = runMin + Math.floor(randomFn() * (max - runMin));\n      const run = this.generateSortedData(thisRunSize, runMin, runMax);\n      \n      // Add to result\n      result.push(...run);\n      currentPos += thisRunSize;\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate a rotated sorted array\n   * \n   * @function generateRotatedSortedArray\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number|null} [rotationPoint=null] - Index to rotate at\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Rotated sorted array\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateRotatedSortedArray(size, rotationPoint = null, min = 1, max = 100, randomFn = Math.random) {\n    // Generate sorted array\n    const sorted = this.generateSortedData(size, min, max);\n    \n    // If rotation point not specified, pick a random one\n    if (rotationPoint === null) {\n      rotationPoint = Math.floor(randomFn() * size);\n    }\n    \n    // Ensure rotation point is valid\n    rotationPoint = Math.max(0, Math.min(size - 1, rotationPoint));\n    \n    // Perform rotation\n    const result = [\n      ...sorted.slice(rotationPoint),\n      ...sorted.slice(0, rotationPoint)\n    ];\n    \n    return result;\n  },\n\n  /**\n   * Generate test data for Dutch national flag problem\n   * \n   * @function generateDutchFlagData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [numValues=3] - Number of unique values\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array for Dutch flag partitioning\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateDutchFlagData(size, numValues = 3, randomFn = Math.random) {\n    return Array.from({ length: size }, () => \n      Math.floor(randomFn() * numValues)\n    );\n  },\n\n  /**\n   * Generate data for testing median finding algorithms\n   * \n   * @function generateMedianFindingData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {string} [distribution='uniform'] - Type of distribution\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array for median finding\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateMedianFindingData(size, min = 1, max = 100, distribution = 'uniform', randomFn = Math.random) {\n    // Generate data using the specified distribution\n    let data;\n    \n    switch (distribution.toLowerCase()) {\n      case 'gaussian':\n      case 'normal':\n        data = this.generateGaussianDistribution(size, { min, max }, randomFn);\n        break;\n      case 'exponential':\n        data = this.generateExponentialDistribution(size, { min, max }, randomFn);\n        break;\n      case 'bimodal':\n        data = this.generateBimodalDistribution(size, { min, max }, randomFn);\n        break;\n      case 'few-unique':\n        data = this.generateFewUniqueData(size, min, max, Math.ceil(size / 10), randomFn);\n        break;\n      case 'uniform':\n      default:\n        data = this.generateRandomData(size, min, max, randomFn);\n    }\n    \n    return data;\n  },\n\n  /**\n   * Generate data for top-K elements problem\n   * \n   * @function generateTopKData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [k=10] - Value of K\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Object} Object with array and the true top-K elements\n   * \n   * @complexity Time: O(n log k) due to sorting the top-k elements\n   * @complexity Space: O(n + k) for the returned array and top-k array\n   */\n  generateTopKData(size, k = 10, min = 1, max = 100, randomFn = Math.random) {\n    // Generate random data\n    const data = this.generateRandomData(size, min, max, randomFn);\n    \n    // Find actual top-K elements\n    const sortedCopy = [...data].sort((a, b) => b - a);\n    const topK = sortedCopy.slice(0, k);\n    \n    return {\n      data,\n      topK\n    };\n  },\n\n  /**\n   * Generate multiple sorted arrays for K-way merge\n   * \n   * @function generateKSortedArrays\n   * @memberof DataGenerators\n   * \n   * @param {number} [k=5] - Number of arrays\n   * @param {number} [avgSize=20] - Average size of each array\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {boolean} [enforceRanges=false] - Enforce non-overlapping ranges between arrays\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<Array<number>>} Array of sorted arrays\n   * \n   * @complexity Time: O(k * avgSize) where k is the number of arrays and avgSize is the average size\n   * @complexity Space: O(k * avgSize) for the returned arrays\n   */\n  generateKSortedArrays(k = 5, avgSize = 20, min = 1, max = 100, enforceRanges = false, randomFn = Math.random) {\n    const arrays = [];\n    \n    if (enforceRanges) {\n      // Create non-overlapping ranges for the arrays\n      const rangeStep = (max - min) / k;\n      \n      for (let i = 0; i < k; i++) {\n        // Calculate range for this array\n        const arrayMin = min + i * rangeStep;\n        const arrayMax = arrayMin + rangeStep;\n        \n        // Randomize array size around the average\n        const thisSize = Math.max(1, Math.floor(avgSize * (0.5 + randomFn() * 1.5)));\n        \n        // Create sorted array\n        const array = this.generateSortedData(thisSize, arrayMin, arrayMax);\n        arrays.push(array);\n      }\n    } else {\n      // Arrays may have overlapping ranges\n      for (let i = 0; i < k; i++) {\n        // Randomize array size around the average\n        const thisSize = Math.max(1, Math.floor(avgSize * (0.5 + randomFn() * 1.5)));\n        \n        // Generate array with random range within the overall min-max\n        const arrayMin = min + Math.floor(randomFn() * (max - min) / 2);\n        const arrayMax = arrayMin + Math.floor(randomFn() * (max - arrayMin));\n        \n        // Create sorted array\n        const array = this.generateSortedData(thisSize, arrayMin, arrayMax);\n        arrays.push(array);\n      }\n    }\n    \n    return arrays;\n  },\n\n  /**\n   * Utility to verify if an array is sorted\n   * \n   * @function isSorted\n   * @memberof DataGenerators\n   * \n   * @param {Array} array - Array to check\n   * @param {Function} [comparator=null] - Optional custom comparator\n   * \n   * @returns {boolean} True if array is sorted\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(1) for variables\n   */\n  isSorted(array, comparator = null) {\n    if (array.length <= 1) return true;\n    \n    const compare = comparator || ((a, b) => (a < b ? -1 : (a > b ? 1 : 0)));\n    \n    for (let i = 1; i < array.length; i++) {\n      if (compare(array[i], array[i-1]) < 0) {\n        return false;\n      }\n    }\n    \n    return true;\n  },\n\n  /**\n   * Measure how sorted an array is (0 = reverse sorted, 1 = fully sorted)\n   * \n   * @function measureSortedness\n   * @memberof DataGenerators\n   * \n   * @param {Array} array - Array to measure\n   * \n   * @returns {number} Sortedness measure between 0 and 1\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(1) for variables\n   */\n  measureSortedness(array) {\n    if (array.length <= 1) return 1;\n    \n    let inversions = 0;\n    const maxInversions = (array.length * (array.length - 1)) / 2;\n    \n    // Count adjacent inversions (simplified method)\n    for (let i = 0; i < array.length - 1; i++) {\n      if (array[i] > array[i + 1]) {\n        inversions++;\n      }\n    }\n    \n    // Convert to a measure between 0 and 1\n    // Note: This is an approximation; a perfect measure would count all inversions\n    return 1 - (inversions / (array.length - 1));\n  },\n\n  /**\n   * Create a dataset with known statistical properties\n   * \n   * @function generateStatisticalDataset\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Statistical parameters\n   * @param {number} [options.mean=50] - Mean of the distribution\n   * @param {number} [options.stdDev=15] - Standard deviation\n   * @param {number} [options.skewness=0] - Skewness (-1 to 1)\n   * @param {number} [options.kurtosis=0] - Kurtosis (-1 to 1)\n   * @param {number} [options.min=1] - Minimum value\n   * @param {number} [options.max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array with desired statistical properties\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateStatisticalDataset(size, options = {}, randomFn = Math.random) {\n    const {\n      mean = 50,\n      stdDev = 15,\n      skewness = 0,\n      kurtosis = 0,\n      min = 1,\n      max = 100\n    } = options;\n    \n    // Start with a Gaussian distribution\n    let data = this.generateGaussianDistribution(size, { mean, stdDev, min, max }, randomFn);\n    \n    // Apply skewness if requested\n    if (skewness !== 0) {\n      data = this._applySkewness(data, skewness, min, max);\n    }\n    \n    // Apply kurtosis if requested\n    if (kurtosis !== 0) {\n      data = this._applyKurtosis(data, kurtosis, mean, min, max);\n    }\n    \n    return data;\n  },\n\n  /**\n   * Apply skewness to a dataset\n   * \n   * @function _applySkewness\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {Array<number>} data - Input data\n   * @param {number} skewness - Desired skewness (-1 to 1)\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * \n   * @returns {Array<number>} Transformed data\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(n) for the returned array\n   */\n  _applySkewness(data, skewness, min, max) {\n    // Simplified transformation for skewness\n    const result = [];\n    const range = max - min;\n    \n    for (let value of data) {\n      // Normalize to 0-1\n      const normalized = (value - min) / range;\n      \n      // Apply power transformation for skewness\n      // Positive skewness: longer tail to the right\n      // Negative skewness: longer tail to the left\n      let transformed;\n      if (skewness > 0) {\n        transformed = Math.pow(normalized, 1 / (1 + skewness));\n      } else {\n        transformed = 1 - Math.pow(1 - normalized, 1 / (1 - skewness));\n      }\n      \n      // Convert back to original range\n      result.push(min + Math.floor(transformed * range));\n    }\n    \n    return result;\n  },\n\n  /**\n   * Apply kurtosis to a dataset\n   * \n   * @function _applyKurtosis\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {Array<number>} data - Input data\n   * @param {number} kurtosis - Desired kurtosis adjustment (-1 to 1)\n   * @param {number} mean - Mean value\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * \n   * @returns {Array<number>} Transformed data\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(n) for the returned array\n   */\n  _applyKurtosis(data, kurtosis, mean, min, max) {\n    // Simplified transformation for kurtosis\n    const result = [];\n    \n    for (let value of data) {\n      // Distance from mean\n      const distFromMean = value - mean;\n      \n      let transformed;\n      if (kurtosis > 0) {\n        // Positive kurtosis: heavier tails, more peaked\n        transformed = mean + Math.sign(distFromMean) * Math.pow(Math.abs(distFromMean), 1 + kurtosis);\n      } else {\n        // Negative kurtosis: lighter tails, less peaked\n        transformed = mean + Math.sign(distFromMean) * Math.pow(Math.abs(distFromMean), 1 + kurtosis);\n      }\n      \n      // Clamp to range\n      transformed = Math.max(min, Math.min(max, transformed));\n      result.push(Math.floor(transformed));\n    }\n    \n    return result;\n  },\n\n  /**\n   * Generate custom distribution by combining other distributions\n   * \n   * @function generateCustomDistribution\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {Array<Object>} distributions - Array of distribution specs\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Custom distribution\n   * \n   * @example\n   * // Generate a mixture of gaussian and exponential distributions\n   * const data = DataGenerators.generateCustomDistribution(1000, [\n   *   { type: 'gaussian', ratio: 0.7, params: { mean: 30, stdDev: 5 } },\n   *   { type: 'exponential', ratio: 0.3, params: { lambda: 0.1 } }\n   * ]);\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateCustomDistribution(size, distributions, min = 1, max = 100, randomFn = Math.random) {\n    const result = [];\n    let remaining = size;\n    \n    for (let i = 0; i < distributions.length && remaining > 0; i++) {\n      const dist = distributions[i];\n      const count = i === distributions.length - 1 ? \n        remaining : \n        Math.floor(size * dist.ratio);\n      \n      // Generate data according to this distribution\n      let data;\n      switch (dist.type) {\n        case 'gaussian':\n        case 'normal':\n          data = this.generateGaussianDistribution(\n            count,\n            {\n              min: dist.min !== undefined ? dist.min : min,\n              max: dist.max !== undefined ? dist.max : max,\n              ...(dist.params || {})\n            },\n            randomFn\n          );\n          break;\n        case 'exponential':\n          data = this.generateExponentialDistribution(\n            count,\n            {\n              min: dist.min !== undefined ? dist.min : min,\n              max: dist.max !== undefined ? dist.max : max,\n              ...(dist.params || {})\n            },\n            randomFn\n          );\n          break;\n        case 'bimodal':\n          data = this.generateBimodalDistribution(\n            count,\n            {\n              min: dist.min !== undefined ? dist.min : min,\n              max: dist.max !== undefined ? dist.max : max,\n              ...(dist.params || {})\n            },\n            randomFn\n          );\n          break;\n        case 'uniform':\n        default:\n          data = this.generateRandomData(\n            count,\n            dist.min !== undefined ? dist.min : min,\n            dist.max !== undefined ? dist.max : max,\n            randomFn\n          );\n      }\n      \n      result.push(...data);\n      remaining -= count;\n    }\n    \n    // Shuffle to mix the distributions\n    return this._shuffleArray(result, randomFn);\n  },\n\n  /**\n   * Shuffle an array using Fisher-Yates algorithm\n   * \n   * @function _shuffleArray\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {Array} array - Array to shuffle\n   * @param {Function} randomFn - Random number generator function\n   * \n   * @returns {Array} Shuffled array\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(1) for in-place shuffle\n   */\n  _shuffleArray(array, randomFn = Math.random) {\n    const result = [...array];\n    \n    for (let i = result.length - 1; i > 0; i--) {\n      const j = Math.floor(randomFn() * (i + 1));\n      [result[i], result[j]] = [result[j], result[i]];\n    }\n    \n    return result;\n  },\n\n  /**\n   * Create a seeded random number generator\n   * \n   * @function _createSeededRandom\n   * @memberof DataGenerators\n   * @private\n   * \n   * @param {number} seed - Seed value for the generator\n   * \n   * @returns {Function} Seeded random function\n   * \n   * @complexity Time: O(1) per call\n   * @complexity Space: O(1) for variables\n   */\n  _createSeededRandom(seed) {\n    // Simple xorshift algorithm for seeded random generation\n    let state = seed;\n    \n    return function() {\n      // xorshift algorithm\n      state ^= state << 13;\n      state ^= state >>> 17;\n      state ^= state << 5;\n      \n      // Normalize to [0, 1)\n      return (state >>> 0) / 4294967296;\n    };\n  },\n\n  /**\n   * Calculate basic statistics for an array\n   * \n   * @function calculateStatistics\n   * @memberof DataGenerators\n   * \n   * @param {Array<number>} array - Array to analyze\n   * \n   * @returns {Object} Object containing statistical measures\n   * \n   * @complexity Time: O(n) where n is the array length\n   * @complexity Space: O(1) for variables\n   */\n  calculateStatistics(array) {\n    if (array.length === 0) {\n      return {\n        min: NaN,\n        max: NaN,\n        mean: NaN,\n        median: NaN,\n        standardDeviation: NaN\n      };\n    }\n    \n    // Calculate min and max\n    let min = array[0];\n    let max = array[0];\n    \n    // Calculate sum for mean\n    let sum = 0;\n    \n    for (let i = 0; i < array.length; i++) {\n      const value = array[i];\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n      sum += value;\n    }\n    \n    // Calculate mean\n    const mean = sum / array.length;\n    \n    // Calculate median\n    const sortedArr = [...array].sort((a, b) => a - b);\n    const midIdx = Math.floor(array.length / 2);\n    const median = array.length % 2 === 0\n      ? (sortedArr[midIdx - 1] + sortedArr[midIdx]) / 2\n      : sortedArr[midIdx];\n    \n    // Calculate standard deviation\n    let variance = 0;\n    for (let i = 0; i < array.length; i++) {\n      const diff = array[i] - mean;\n      variance += diff * diff;\n    }\n    variance /= array.length;\n    const standardDeviation = Math.sqrt(variance);\n    \n    return {\n      min,\n      max,\n      mean,\n      median,\n      standardDeviation\n    };\n  },\n\n  /**\n   * Generate a dataset that's specifically designed to test a given sorting algorithm\n   * \n   * @function generateTestCase\n   * @memberof DataGenerators\n   * \n   * @param {string} algorithm - Algorithm name\n   * @param {string} testCase - Test case type ('best', 'worst', 'average')\n   * @param {number} size - Size of array\n   * @param {Object} [options={}] - Additional options\n   * \n   * @returns {Array<number>} Array for testing\n   * \n   * @complexity Varies depending on algorithm and test case\n   */\n  generateTestCase(algorithm, testCase, size, options = {}) {\n    const lowerAlgo = algorithm.toLowerCase();\n    const lowerCase = testCase.toLowerCase();\n    \n    if (lowerCase === 'worst') {\n      // Generate worst case for the specified algorithm\n      return this.generateAdversarialCase(lowerAlgo, size, options);\n    } else if (lowerCase === 'best') {\n      // Generate best case for the specified algorithm\n      switch (lowerAlgo) {\n        case 'insertionsort':\n        case 'bubblesort':\n          return this.generateSortedData(size, options.min, options.max);\n        case 'quicksort':\n          // Best case for quicksort is typically a balanced partition\n          return this.generateRandomData(size, options.min, options.max);\n        case 'mergesort':\n          // Mergesort is relatively insensitive to input order\n          return this.generateRandomData(size, options.min, options.max);\n        default:\n          // For unknown algorithms, return a random array\n          return this.generateRandomData(size, options.min, options.max);\n      }\n    } else {\n      // Average case - usually a random array\n      return this.generateRandomData(size, options.min, options.max);\n    }\n  },\n\n  /**\n   * Generate a dataset that gradually transitions from one pattern to another\n   * \n   * @function generateTransitionData\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {string} startPattern - Starting pattern type\n   * @param {string} endPattern - Ending pattern type\n   * @param {number} [transitionPoint=0.5] - Position of transition (0-1)\n   * @param {Object} [options={}] - Additional options\n   * \n   * @returns {Array<number>} Array with transition\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array\n   */\n  generateTransitionData(size, startPattern, endPattern, transitionPoint = 0.5, options = {}) {\n    // Generate data for both patterns\n    const firstSize = Math.floor(size * transitionPoint);\n    const secondSize = size - firstSize;\n    \n    const firstData = this.generateDataSet(startPattern, firstSize, options);\n    const secondData = this.generateDataSet(endPattern, secondSize, options);\n    \n    // Combine the data\n    return [...firstData, ...secondData];\n  },\n\n  /**\n   * Generate a dataset with known duplicates pattern\n   * \n   * @function generateDuplicatesPattern\n   * @memberof DataGenerators\n   * \n   * @param {number} size - Size of array\n   * @param {number} [uniqueCount=10] - Number of unique values\n   * @param {string} [pattern='random'] - Pattern of duplicates ('random', 'blocks', 'interleaved')\n   * @param {number} [min=1] - Minimum value\n   * @param {number} [max=100] - Maximum value\n   * @param {Function} [randomFn=Math.random] - Random number generator function\n   * \n   * @returns {Array<number>} Array with duplicates pattern\n   * \n   * @complexity Time: O(n) where n is the size parameter\n   * @complexity Space: O(n) for the returned array, plus O(uniqueCount) for unique values\n   */\n  generateDuplicatesPattern(size, uniqueCount = 10, pattern = 'random', min = 1, max = 100, randomFn = Math.random) {\n    // Generate unique values\n    const uniqueValues = [];\n    for (let i = 0; i < uniqueCount; i++) {\n      uniqueValues.push(min + Math.floor((max - min) * i / uniqueCount));\n    }\n    \n    const result = [];\n    \n    switch (pattern.toLowerCase()) {\n      case 'blocks':\n        // Generate blocks of duplicate values\n        const blockSize = Math.floor(size / uniqueCount);\n        for (let i = 0; i < uniqueCount; i++) {\n          const value = uniqueValues[i];\n          for (let j = 0; j < blockSize; j++) {\n            result.push(value);\n          }\n        }\n        \n        // Fill any remaining spots\n        while (result.length < size) {\n          result.push(uniqueValues[uniqueCount - 1]);\n        }\n        break;\n        \n      case 'interleaved':\n        // Generate interleaved pattern of duplicate values\n        for (let i = 0; i < size; i++) {\n          result.push(uniqueValues[i % uniqueCount]);\n        }\n        break;\n        \n      case 'random':\n      default:\n        // Random distribution of duplicates\n        for (let i = 0; i < size; i++) {\n          const idx = Math.floor(randomFn() * uniqueCount);\n          result.push(uniqueValues[idx]);\n        }\n    }\n    \n    return result;\n  }\n};\n\nexport default DataGenerators;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAMA,cAAc,GAAG;EACrB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,eAAeA,CAACC,IAAI,EAAEC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACxC;IACA,IAAI,OAAOD,IAAI,KAAK,QAAQ,IAAIA,IAAI,GAAG,CAAC,IAAI,CAACE,MAAM,CAACC,SAAS,CAACH,IAAI,CAAC,EAAE;MACnE,MAAM,IAAII,SAAS,CAAC,qCAAqC,CAAC;IAC5D;;IAEA;IACA,MAAM;MACJC,GAAG,GAAG,CAAC;MACPC,GAAG,GAAG,GAAG;MACTC,YAAY,GAAG,EAAE;MACjBC,WAAW,GAAG,GAAG;MACjBC,aAAa,GAAG,GAAG;MACnBC,IAAI,GAAGC;IACT,CAAC,GAAGV,OAAO;;IAEX;IACA,IAAII,GAAG,GAAGC,GAAG,EAAE;MACb,MAAM,IAAIM,UAAU,CAAC,2DAA2D,CAAC;IACnF;IAEA,IAAIL,YAAY,IAAI,CAAC,EAAE;MACrB,MAAM,IAAIK,UAAU,CAAC,0CAA0C,CAAC;IAClE;IAEA,IAAIJ,WAAW,GAAG,CAAC,IAAIA,WAAW,GAAG,CAAC,EAAE;MACtC,MAAM,IAAII,UAAU,CAAC,sCAAsC,CAAC;IAC9D;IAEA,IAAIH,aAAa,GAAG,CAAC,IAAIA,aAAa,GAAG,CAAC,EAAE;MAC1C,MAAM,IAAIG,UAAU,CAAC,wCAAwC,CAAC;IAChE;;IAEA;IACA,IAAIC,QAAQ,GAAGC,IAAI,CAACC,MAAM;IAC1B,IAAIL,IAAI,KAAKC,SAAS,EAAE;MACtB,MAAMK,YAAY,GAAG,IAAI,CAACC,mBAAmB,CAACP,IAAI,CAAC;MACnDG,QAAQ,GAAGG,YAAY;IACzB;;IAEA;IACA,QAAQjB,IAAI,CAACmB,WAAW,CAAC,CAAC;MACxB,KAAK,QAAQ;QACX,OAAO,IAAI,CAACC,kBAAkB,CAACnB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;MAC1D,KAAK,eAAe;QAClB,OAAO,IAAI,CAACO,wBAAwB,CAACpB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEE,WAAW,EAAEK,QAAQ,CAAC;MAC7E,KAAK,UAAU;QACb,OAAO,IAAI,CAACQ,oBAAoB,CAACrB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEG,aAAa,EAAEI,QAAQ,CAAC;MAC3E,KAAK,YAAY;QACf,OAAO,IAAI,CAACS,qBAAqB,CAACtB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEC,YAAY,EAAEM,QAAQ,CAAC;MAC3E,KAAK,QAAQ;QACX,OAAO,IAAI,CAACU,kBAAkB,CAACvB,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;MAChD,KAAK,UAAU;QACb,OAAO,IAAI,CAACkB,oBAAoB,CAACxB,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;MAClD,KAAK,SAAS;QACZ,OAAO,IAAI,CAACmB,mBAAmB,CAACzB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;MAC3D,KAAK,kBAAkB;QACrB,MAAMa,OAAO,GAAG,IAAI,CAACD,mBAAmB,CAACzB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;QAClE,OAAO,IAAI,CAACc,aAAa,CAACD,OAAO,EAAEb,QAAQ,CAAC;MAC9C,KAAK,YAAY;QACf,OAAO,IAAI,CAACe,qBAAqB,CAAC5B,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;MACnD,KAAK,eAAe;QAClB,OAAO,IAAI,CAACuB,wBAAwB,CAAC7B,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEL,OAAO,CAAC6B,SAAS,IAAIhB,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAG,EAAE,CAAC,EAAEa,QAAQ,CAAC;MAC5G,KAAK,UAAU;QACb,OAAO,IAAI,CAACmB,4BAA4B,CAAChC,IAAI,EAAE;UAC7CiC,IAAI,EAAE,CAAC5B,GAAG,GAAGC,GAAG,IAAI,CAAC;UACrB4B,MAAM,EAAE,CAAC5B,GAAG,GAAGD,GAAG,IAAI,CAAC;UAAG;UAC1BA,GAAG;UACHC,GAAG;UACH,GAAGL;QACL,CAAC,EAAEY,QAAQ,CAAC;MACd;QACEsB,OAAO,CAACC,IAAI,CAAC,0BAA0BrC,IAAI,wBAAwB,CAAC;QACpE,OAAO,IAAI,CAACoB,kBAAkB,CAACnB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;IAC5D;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,kBAAkBA,CAACnB,IAAI,EAAEK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACnE,OAAOsB,KAAK,CAACC,IAAI,CAAC;MAAEC,MAAM,EAAEvC;IAAK,CAAC,EAAE,MAClCc,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIP,GAAG,GAAGD,GAAG,GAAG,CAAC,CAAC,CAAC,GAAGA,GAC7C,CAAC;EACH,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEkB,kBAAkBA,CAACvB,IAAI,EAAEK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEkC,UAAU,GAAG,KAAK,EAAE;IAC/D,IAAIxC,IAAI,IAAI,CAAC,EAAE,OAAO,EAAE;IAExB,MAAMyC,IAAI,GAAG,CAACnC,GAAG,GAAGD,GAAG,KAAKL,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;IAC1C,MAAM0C,MAAM,GAAGL,KAAK,CAACC,IAAI,CAAC;MAAEC,MAAM,EAAEvC;IAAK,CAAC,EAAE,CAAC2C,CAAC,EAAEC,CAAC,KAC/C9B,IAAI,CAAC+B,KAAK,CAACxC,GAAG,GAAGuC,CAAC,GAAGH,IAAI,CAC3B,CAAC;IAED,OAAOD,UAAU,GAAGE,MAAM,CAACI,OAAO,CAAC,CAAC,GAAGJ,MAAM;EAC/C,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACErB,oBAAoBA,CAACrB,IAAI,EAAEK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEyC,KAAK,GAAG,GAAG,EAAElC,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAClF;IACA,MAAMiC,MAAM,GAAG,IAAI,CAACzB,kBAAkB,CAACvB,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;;IAEtD;IACA,IAAIyC,KAAK,IAAI,CAAC,EAAE;MACd,OAAOC,MAAM,CAACF,OAAO,CAAC,CAAC;IACzB;;IAEA;IACA,MAAMG,QAAQ,GAAGD,MAAM,CAACF,OAAO,CAAC,CAAC;IACjC,MAAMJ,MAAM,GAAG,CAAC,GAAGO,QAAQ,CAAC;;IAE5B;IACA,MAAMC,YAAY,GAAGpC,IAAI,CAACiB,KAAK,CAAC/B,IAAI,IAAI,CAAC,GAAG+C,KAAK,CAAC,CAAC;IACnD,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,YAAY,EAAEN,CAAC,EAAE,EAAE;MACrC,MAAMO,IAAI,GAAGrC,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,GAAGb,IAAI,CAAC;MAC1C,MAAMoD,IAAI,GAAGtC,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,GAAGb,IAAI,CAAC;MAC1C,CAAC0C,MAAM,CAACS,IAAI,CAAC,EAAET,MAAM,CAACU,IAAI,CAAC,CAAC,GAAG,CAACV,MAAM,CAACU,IAAI,CAAC,EAAEV,MAAM,CAACS,IAAI,CAAC,CAAC;IAC7D;IAEA,OAAOT,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEtB,wBAAwBA,CAACpB,IAAI,EAAEK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEyC,KAAK,GAAG,GAAG,EAAElC,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACtF;IACA,MAAM2B,MAAM,GAAG,IAAI,CAACnB,kBAAkB,CAACvB,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;;IAEtD;IACA,MAAM4C,YAAY,GAAGpC,IAAI,CAACiB,KAAK,CAAC/B,IAAI,IAAI,CAAC,GAAG+C,KAAK,CAAC,CAAC;;IAEnD;IACA,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,YAAY,EAAEN,CAAC,EAAE,EAAE;MACrC,MAAMO,IAAI,GAAGrC,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,GAAGb,IAAI,CAAC;;MAE1C;MACA,MAAMqD,WAAW,GAAGvC,IAAI,CAACR,GAAG,CAAC,CAAC,EAAEQ,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAG,GAAG,CAAC,CAAC;MACvD,MAAMsD,MAAM,GAAGxC,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,GAAGwC,WAAW,CAAC,GAAGvC,IAAI,CAACiB,KAAK,CAACsB,WAAW,GAAG,CAAC,CAAC;MACjF,MAAMD,IAAI,GAAGtC,IAAI,CAACR,GAAG,CAAC,CAAC,EAAEQ,IAAI,CAACT,GAAG,CAACL,IAAI,GAAG,CAAC,EAAEmD,IAAI,GAAGG,MAAM,CAAC,CAAC;MAE3D,CAACZ,MAAM,CAACS,IAAI,CAAC,EAAET,MAAM,CAACU,IAAI,CAAC,CAAC,GAAG,CAACV,MAAM,CAACU,IAAI,CAAC,EAAEV,MAAM,CAACS,IAAI,CAAC,CAAC;IAC7D;IAEA,OAAOT,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEpB,qBAAqBA,CAACtB,IAAI,EAAEK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEiD,WAAW,GAAG,EAAE,EAAE1C,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACxF;IACAwC,WAAW,GAAGzC,IAAI,CAACT,GAAG,CAACkD,WAAW,EAAEjD,GAAG,GAAGD,GAAG,GAAG,CAAC,CAAC;;IAElD;IACA,MAAME,YAAY,GAAG,EAAE;IACvB,KAAK,IAAIqC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,WAAW,EAAEX,CAAC,EAAE,EAAE;MACpC,MAAMY,KAAK,GAAG1C,IAAI,CAACiB,KAAK,CAAC1B,GAAG,GAAIuC,CAAC,IAAItC,GAAG,GAAGD,GAAG,CAAC,IAAIkD,WAAW,GAAG,CAAC,IAAI,CAAC,CAAE,CAAC;MAC1EhD,YAAY,CAACkD,IAAI,CAACD,KAAK,CAAC;IAC1B;;IAEA;IACA,OAAOnB,KAAK,CAACC,IAAI,CAAC;MAAEC,MAAM,EAAEvC;IAAK,CAAC,EAAE,MAClCO,YAAY,CAACO,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,GAAG0C,WAAW,CAAC,CACnD,CAAC;EACH,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE/B,oBAAoBA,CAACxB,IAAI,EAAEK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEoD,UAAU,GAAG,IAAI,EAAE;IAChE;IACA,IAAIA,UAAU,KAAK,IAAI,EAAE;MACvBA,UAAU,GAAG5C,IAAI,CAACR,GAAG,CAAC,CAAC,EAAEQ,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAG,EAAE,CAAC,CAAC;IACjD;IAEA,MAAM2D,SAAS,GAAG7C,IAAI,CAAC8C,IAAI,CAAC5D,IAAI,GAAG0D,UAAU,CAAC;IAC9C,MAAMhB,MAAM,GAAG,EAAE;IAEjB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;MAC7B;MACA,MAAMiB,QAAQ,GAAG/C,IAAI,CAACiB,KAAK,CAACa,CAAC,GAAGe,SAAS,CAAC;MAC1C;MACA,MAAMG,UAAU,GAAGlB,CAAC,GAAGe,SAAS;MAChC;MACA,MAAMI,QAAQ,GAAGD,UAAU,GAAGH,SAAS;MACvC,MAAMH,KAAK,GAAGnD,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAACgC,QAAQ,IAAIzD,GAAG,GAAGD,GAAG,CAAC,CAAC;MAEtDqC,MAAM,CAACe,IAAI,CAACD,KAAK,CAAC;IACpB;IAEA,OAAOd,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEjB,mBAAmBA,CAACzB,IAAI,EAAEK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACpE;IACA,MAAMiD,YAAY,GAAGlD,IAAI,CAACR,GAAG,CAAC,CAAC,EAAEQ,IAAI,CAACiB,KAAK,CAACjB,IAAI,CAACmD,IAAI,CAACjE,IAAI,CAAC,CAAC,CAAC;IAC7D,MAAMkE,WAAW,GAAGpD,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAGgE,YAAY,CAAC;IACnD,MAAMtB,MAAM,GAAG,EAAE;;IAEjB;IACA,MAAMyB,aAAa,GAAG,EAAE;IACxB,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,YAAY,EAAEpB,CAAC,EAAE,EAAE;MACrC;MACA,MAAMwB,SAAS,GAAGxB,CAAC,GAAG,CAAC,GAAGuB,aAAa,CAACvB,CAAC,GAAC,CAAC,CAAC,GAAGvC,GAAG,GAAG,CAAC;MACtD,MAAMgE,QAAQ,GAAGhE,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAAC,CAACa,CAAC,GAAG,CAAC,IAAIoB,YAAY,IAAI1D,GAAG,GAAGD,GAAG,CAAC,CAAC;MACvE,MAAMiE,QAAQ,GAAG1B,CAAC,KAAK,CAAC,GAAGvC,GAAG,GAAG+D,SAAS,GAAG,CAAC;MAC9CD,aAAa,CAACV,IAAI,CAACa,QAAQ,GAAGxD,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIwD,QAAQ,GAAGC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;IACnF;;IAEA;IACA,KAAK,IAAI1B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;MAC7B,MAAM2B,UAAU,GAAGzD,IAAI,CAACT,GAAG,CAAC2D,YAAY,GAAG,CAAC,EAAElD,IAAI,CAACiB,KAAK,CAACa,CAAC,GAAGsB,WAAW,CAAC,CAAC;MAC1ExB,MAAM,CAACe,IAAI,CAACU,aAAa,CAACI,UAAU,CAAC,CAAC;IACxC;IAEA,OAAO7B,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEd,qBAAqBA,CAAC5B,IAAI,EAAEK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAE;IAC9C,MAAMoC,MAAM,GAAG,EAAE;IACjB,MAAM8B,QAAQ,GAAG1D,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAG,CAAC,CAAC;IACrC,MAAMyC,IAAI,GAAG,CAACnC,GAAG,GAAGD,GAAG,IAAImE,QAAQ;;IAEnC;IACA,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4B,QAAQ,EAAE5B,CAAC,EAAE,EAAE;MACjCF,MAAM,CAACe,IAAI,CAAC3C,IAAI,CAAC+B,KAAK,CAACxC,GAAG,GAAGuC,CAAC,GAAGH,IAAI,CAAC,CAAC;IACzC;;IAEA;IACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,GAAGwE,QAAQ,EAAE5B,CAAC,EAAE,EAAE;MACxCF,MAAM,CAACe,IAAI,CAAC3C,IAAI,CAAC+B,KAAK,CAACvC,GAAG,GAAGsC,CAAC,GAAGH,IAAI,CAAC,CAAC;IACzC;IAEA,OAAOC,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEb,wBAAwBA,CAAC7B,IAAI,EAAEK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEwB,SAAS,GAAG,EAAE,EAAEjB,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACzF;IACA,MAAM0D,IAAI,GAAG,IAAI,CAACtD,kBAAkB,CAACnB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;IAC9D,MAAM6B,MAAM,GAAG,EAAE;;IAEjB;IACA,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,IAAId,SAAS,EAAE;MACxC,MAAM4C,QAAQ,GAAG5D,IAAI,CAACT,GAAG,CAACuC,CAAC,GAAGd,SAAS,EAAE9B,IAAI,CAAC;MAC9C,MAAM2E,KAAK,GAAGF,IAAI,CAACG,KAAK,CAAChC,CAAC,EAAE8B,QAAQ,CAAC,CAACG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;MAC3DrC,MAAM,CAACe,IAAI,CAAC,GAAGkB,KAAK,CAAC;IACvB;IAEA,OAAOjC,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEV,4BAA4BA,CAAChC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAEY,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACvE,MAAM;MACJkB,IAAI,GAAG,EAAE;MACTC,MAAM,GAAG,EAAE;MACX7B,GAAG,GAAG,CAAC;MACPC,GAAG,GAAG;IACR,CAAC,GAAGL,OAAO;IAEX,MAAMyC,MAAM,GAAG,EAAE;;IAEjB;IACA,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;MAC7B,IAAIoC,GAAG;MACP,GAAG;QACD;QACA,MAAMC,EAAE,GAAGpE,QAAQ,CAAC,CAAC;QACrB,MAAMqE,EAAE,GAAGrE,QAAQ,CAAC,CAAC;QACrB,MAAMsE,EAAE,GAAGrE,IAAI,CAACmD,IAAI,CAAC,CAAC,GAAG,GAAGnD,IAAI,CAACsE,GAAG,CAACH,EAAE,CAAC,CAAC,GAAGnE,IAAI,CAACuE,GAAG,CAAC,GAAG,GAAGvE,IAAI,CAACwE,EAAE,GAAGJ,EAAE,CAAC;QACxEF,GAAG,GAAGlE,IAAI,CAAC+B,KAAK,CAACsC,EAAE,GAAGjD,MAAM,GAAGD,IAAI,CAAC;MACtC,CAAC,QAAQ+C,GAAG,GAAG3E,GAAG,IAAI2E,GAAG,GAAG1E,GAAG,EAAE,CAAC;;MAElCoC,MAAM,CAACe,IAAI,CAACuB,GAAG,CAAC;IAClB;IAEA,OAAOtC,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6C,+BAA+BA,CAACvF,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAEY,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAC1E,MAAM;MACJyE,MAAM,GAAG,GAAG;MACZnF,GAAG,GAAG,CAAC;MACPC,GAAG,GAAG;IACR,CAAC,GAAGL,OAAO;IAEX,MAAMyC,MAAM,GAAG,EAAE;IACjB,MAAM+C,KAAK,GAAGnF,GAAG,GAAGD,GAAG;IAEvB,KAAK,IAAIuC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;MAC7B;MACA,MAAM8C,CAAC,GAAG7E,QAAQ,CAAC,CAAC;MACpB,MAAM2C,KAAK,GAAGnD,GAAG,GAAGS,IAAI,CAAC+B,KAAK,CAAE,CAAC/B,IAAI,CAACsE,GAAG,CAAC,CAAC,GAAGM,CAAC,CAAC,GAAGF,MAAM,GAAIC,KAAK,CAAC;MACnE/C,MAAM,CAACe,IAAI,CAAC3C,IAAI,CAACT,GAAG,CAACmD,KAAK,EAAElD,GAAG,CAAC,CAAC;IACnC;IAEA,OAAOoC,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEiD,2BAA2BA,CAAC3F,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAEY,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACtE,MAAM;MACJ6E,KAAK,GAAG,EAAE;MACVC,OAAO,GAAG,EAAE;MACZC,KAAK,GAAG,EAAE;MACVC,OAAO,GAAG,EAAE;MACZhD,KAAK,GAAG,GAAG;MACX1C,GAAG,GAAG,CAAC;MACPC,GAAG,GAAG;IACR,CAAC,GAAGL,OAAO;IAEX,MAAMyC,MAAM,GAAG,EAAE;IAEjB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;MAC7B,IAAIoC,GAAG;MACP,GAAG;QACD;QACA,MAAMgB,QAAQ,GAAGnF,QAAQ,CAAC,CAAC,GAAGkC,KAAK;;QAEnC;QACA,MAAMd,IAAI,GAAG+D,QAAQ,GAAGJ,KAAK,GAAGE,KAAK;QACrC,MAAM5D,MAAM,GAAG8D,QAAQ,GAAGH,OAAO,GAAGE,OAAO;;QAE3C;QACA,MAAMd,EAAE,GAAGpE,QAAQ,CAAC,CAAC;QACrB,MAAMqE,EAAE,GAAGrE,QAAQ,CAAC,CAAC;QACrB,MAAMsE,EAAE,GAAGrE,IAAI,CAACmD,IAAI,CAAC,CAAC,GAAG,GAAGnD,IAAI,CAACsE,GAAG,CAACH,EAAE,CAAC,CAAC,GAAGnE,IAAI,CAACuE,GAAG,CAAC,GAAG,GAAGvE,IAAI,CAACwE,EAAE,GAAGJ,EAAE,CAAC;QACxEF,GAAG,GAAGlE,IAAI,CAAC+B,KAAK,CAACsC,EAAE,GAAGjD,MAAM,GAAGD,IAAI,CAAC;MACtC,CAAC,QAAQ+C,GAAG,GAAG3E,GAAG,IAAI2E,GAAG,GAAG1E,GAAG,EAAE,CAAC;;MAElCoC,MAAM,CAACe,IAAI,CAACuB,GAAG,CAAC;IAClB;IAEA,OAAOtC,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEuD,uBAAuBA,CAACC,SAAS,EAAElG,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAEY,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAC7E,MAAM;MACJV,GAAG,GAAG,CAAC;MACPC,GAAG,GAAG;IACR,CAAC,GAAGL,OAAO;;IAEX;IACA,QAAQiG,SAAS,CAAChF,WAAW,CAAC,CAAC;MAC7B,KAAK,WAAW;QACd,OAAO,IAAI,CAACiF,6BAA6B,CAACnG,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEL,OAAO,EAAEY,QAAQ,CAAC;MAC9E,KAAK,WAAW;QACd,OAAO,IAAI,CAACuF,6BAA6B,CAACpG,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;MACrE,KAAK,eAAe;QAClB,OAAO,IAAI,CAACwF,iCAAiC,CAACrG,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;MAC/D,KAAK,UAAU;QACb,OAAO,IAAI,CAACgG,4BAA4B,CAACtG,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;MACpE,KAAK,YAAY;QACf,OAAO,IAAI,CAACQ,oBAAoB,CAACrB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAE,CAAC,CAAC;MACrD,KAAK,WAAW;QACd,OAAO,IAAI,CAACiG,6BAA6B,CAACvG,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;MACrE;QACE;QACA,OAAO,IAAI,CAACQ,oBAAoB,CAACrB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAE,CAAC,CAAC;IACvD;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6F,6BAA6BA,CAACnG,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEL,OAAO,GAAG,CAAC,CAAC,EAAEY,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAClF,MAAM;MAAEyF,aAAa,GAAG;IAAQ,CAAC,GAAGvG,OAAO;IAE3C,QAAQuG,aAAa;MACnB,KAAK,OAAO;QACV;QACA,OAAO,IAAI,CAACjF,kBAAkB,CAACvB,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;MAChD,KAAK,MAAM;QACT;QACA,OAAO,IAAI,CAACe,oBAAoB,CAACrB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAE,CAAC,CAAC;MACrD,KAAK,QAAQ;QACX;QACA,OAAO,IAAI,CAACmG,uBAAuB,CAACzG,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;MACrD,KAAK,iBAAiB;QACpB;QACA,OAAO,IAAI,CAACoG,iCAAiC,CAAC1G,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;MACzE,KAAK,QAAQ;QACX;QACA;QACA,OAAO,IAAI,CAACS,qBAAqB,CAACtB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAE,CAAC,EAAEO,QAAQ,CAAC;MAChE;QACE,OAAO,IAAI,CAACU,kBAAkB,CAACvB,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;IAClD;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEmG,uBAAuBA,CAACzG,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAE;IACtC,MAAMoC,MAAM,GAAG,EAAE;IACjB,MAAM+C,KAAK,GAAGnF,GAAG,GAAGD,GAAG;;IAEvB;IACA;IACA;IACA,KAAK,IAAIuC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;MAC7B,MAAM+D,QAAQ,GAAG7F,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAG,CAAC,CAAC;MACrC,IAAIwD,KAAK;MAET,IAAIZ,CAAC,GAAG+D,QAAQ,EAAE;QAChB;QACAnD,KAAK,GAAGnD,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAAEa,CAAC,GAAG+D,QAAQ,IAAKlB,KAAK,GAAG,CAAC,CAAC,CAAC;MACxD,CAAC,MAAM;QACL;QACA;QACAjC,KAAK,GAAGnD,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAAC0D,KAAK,GAAG,CAAC,CAAC,GAAG3E,IAAI,CAACiB,KAAK,CAAE,CAACa,CAAC,GAAG+D,QAAQ,KAAK3G,IAAI,GAAG2G,QAAQ,CAAC,IAAKlB,KAAK,GAAG,CAAC,CAAC,CAAC;MACtG;MAEA/C,MAAM,CAACe,IAAI,CAACD,KAAK,CAAC;IACpB;IAEA,OAAOd,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEgE,iCAAiCA,CAAC1G,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACxE;IACA;;IAEA,MAAM2B,MAAM,GAAG,EAAE;IACjB,MAAMD,IAAI,GAAG,CAACnC,GAAG,GAAGD,GAAG,KAAKL,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;;IAE1C;IACA;IACA,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;MAC7B,MAAMgE,GAAG,GAAGhE,CAAC,GAAG,CAAC;MAEjB,IAAIgE,GAAG,KAAK,CAAC,EAAE;QACb;QACAlE,MAAM,CAACe,IAAI,CAACpD,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAAC,CAAC/B,IAAI,GAAG4C,CAAC,IAAIH,IAAI,GAAG,GAAG,CAAC,CAAC;MACxD,CAAC,MAAM,IAAImE,GAAG,KAAK,CAAC,EAAE;QACpB;QACA,MAAMC,SAAS,GAAGxG,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAACa,CAAC,GAAGH,IAAI,GAAG,GAAG,CAAC;QAClDC,MAAM,CAACe,IAAI,CAACoD,SAAS,CAAC;MACxB,CAAC,MAAM;QACL;QACAnE,MAAM,CAACe,IAAI,CAACpD,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAACa,CAAC,GAAGH,IAAI,GAAG,GAAG,CAAC,CAAC;MAC/C;IACF;;IAEA;IACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,GAAG,CAAC,EAAE4C,CAAC,EAAE,EAAE;MACjC,MAAMO,IAAI,GAAGrC,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,GAAGb,IAAI,CAAC;MAC1C,MAAMoD,IAAI,GAAGtC,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,GAAGb,IAAI,CAAC;MAC1C,IAAImD,IAAI,GAAG,CAAC,KAAKC,IAAI,GAAG,CAAC,EAAE;QAAE;QAC3B,CAACV,MAAM,CAACS,IAAI,CAAC,EAAET,MAAM,CAACU,IAAI,CAAC,CAAC,GAAG,CAACV,MAAM,CAACU,IAAI,CAAC,EAAEV,MAAM,CAACS,IAAI,CAAC,CAAC;MAC7D;IACF;IAEA,OAAOT,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE0D,6BAA6BA,CAACpG,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACpE;IACA;;IAEA,MAAM2B,MAAM,GAAG,EAAE;IACjB,MAAMD,IAAI,GAAG,CAACnC,GAAG,GAAGD,GAAG,KAAKL,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;;IAE1C;IACA;IACA;;IAEA;IACA,IAAI8G,SAAS,GAAG,CAAC;IACjB,OAAOA,SAAS,GAAG,CAAC,IAAI9G,IAAI,EAAE;MAC5B8G,SAAS,IAAI,CAAC;IAChB;;IAEA;IACA,IAAIxD,MAAM,GAAG,CAAC;IACd,OAAOA,MAAM,GAAGtD,IAAI,EAAE;MACpB,MAAM+G,gBAAgB,GAAGjG,IAAI,CAACT,GAAG,CAACyG,SAAS,EAAE9G,IAAI,GAAGsD,MAAM,CAAC;MAC3D,MAAM0D,SAAS,GAAK1D,MAAM,GAAGwD,SAAS,GAAI,CAAC,KAAK,CAAE;MAElD,KAAK,IAAIlE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmE,gBAAgB,EAAEnE,CAAC,EAAE,EAAE;QACzC,MAAMqE,GAAG,GAAG3D,MAAM,GAAGV,CAAC;QACtB,MAAMsE,UAAU,GAAG7G,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAACkF,GAAG,GAAGxE,IAAI,CAAC;QAE/C,IAAIuE,SAAS,EAAE;UACbtE,MAAM,CAACe,IAAI,CAACyD,UAAU,CAAC;QACzB,CAAC,MAAM;UACL;UACAxE,MAAM,CAACyE,MAAM,CAAC7D,MAAM,EAAE,CAAC,EAAE4D,UAAU,CAAC;QACtC;MACF;MAEA5D,MAAM,IAAIyD,gBAAgB;IAC5B;IAEA,OAAOrE,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2D,iCAAiCA,CAACrG,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAE;IAChD;IACA,OAAO,IAAI,CAACe,oBAAoB,CAACrB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAE,CAAC,CAAC;EACrD,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEgG,4BAA4BA,CAACtG,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACnE;IACA;;IAEA,MAAM2B,MAAM,GAAG,EAAE;IACjB,MAAMD,IAAI,GAAG,CAACnC,GAAG,GAAGD,GAAG,KAAKL,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;;IAE1C;IACA;IACA;;IAEA;IACA,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAG,CAAC,CAAC,EAAE4C,CAAC,EAAE,EAAE;MAC7CF,MAAM,CAACe,IAAI,CAACpD,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAACa,CAAC,GAAGH,IAAI,CAAC,CAAC;IACzC;;IAEA;IACA;IACA,KAAK,IAAIG,CAAC,GAAG9B,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAG,CAAC,CAAC,EAAE4C,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;MAChDF,MAAM,CAACe,IAAI,CAACnD,GAAG,GAAGQ,IAAI,CAACiB,KAAK,CAAC,CAACa,CAAC,GAAG5C,IAAI,GAAG,CAAC,IAAIyC,IAAI,CAAC,CAAC;IACtD;;IAEA;IACA;IACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,GAAG,CAAC,EAAE4C,CAAC,EAAE,EAAE;MACjC,MAAMO,IAAI,GAAGrC,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIb,IAAI,GAAG,CAAC,CAAC,CAAC;MAChD,MAAMoD,IAAI,GAAGtC,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIb,IAAI,GAAG,CAAC,CAAC,CAAC;MAChD,CAAC0C,MAAM,CAACS,IAAI,CAAC,EAAET,MAAM,CAACU,IAAI,CAAC,CAAC,GAAG,CAACV,MAAM,CAACU,IAAI,CAAC,EAAEV,MAAM,CAACS,IAAI,CAAC,CAAC;MAE3D,MAAMiE,IAAI,GAAGtG,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAG,CAAC,CAAC,GAAGc,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIb,IAAI,GAAG,CAAC,CAAC,CAAC;MACvE,MAAMqH,IAAI,GAAGvG,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAG,CAAC,CAAC,GAAGc,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIb,IAAI,GAAG,CAAC,CAAC,CAAC;MACvE,CAAC0C,MAAM,CAAC0E,IAAI,CAAC,EAAE1E,MAAM,CAAC2E,IAAI,CAAC,CAAC,GAAG,CAAC3E,MAAM,CAAC2E,IAAI,CAAC,EAAE3E,MAAM,CAAC0E,IAAI,CAAC,CAAC;IAC7D;IAEA,OAAO1E,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6D,6BAA6BA,CAACvG,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACpE;IACA;IACA;;IAEA;IACA,MAAM2B,MAAM,GAAGL,KAAK,CAACrC,IAAI,CAAC,CAACsH,IAAI,CAAC,CAAC,CAAC;IAClC,MAAM7B,KAAK,GAAGnF,GAAG,GAAGD,GAAG;;IAEvB;IACA;IACA;IACA;;IAEA;IACA,KAAK,IAAIuC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;MAC7B;MACA;MACA,IAAIA,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QACfF,MAAM,CAACE,CAAC,CAAC,GAAGtC,GAAG,GAAGQ,IAAI,CAACiB,KAAK,CAAEa,CAAC,GAAG5C,IAAI,GAAIyF,KAAK,GAAG,GAAG,CAAC;MACxD,CAAC,MAAM;QACL/C,MAAM,CAACE,CAAC,CAAC,GAAGvC,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAAEa,CAAC,GAAG5C,IAAI,GAAIyF,KAAK,GAAG,GAAG,CAAC;MACxD;IACF;;IAEA;IACA,KAAK,IAAI7C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,IAAI,CAAC,EAAE;MAChC,IAAIA,CAAC,GAAG,CAAC,GAAG5C,IAAI,EAAE;QAChB;QACA,CAAC0C,MAAM,CAACE,CAAC,CAAC,EAAEF,MAAM,CAACE,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAACF,MAAM,CAACE,CAAC,GAAG,CAAC,CAAC,EAAEF,MAAM,CAACE,CAAC,CAAC,CAAC;QACvD,CAACF,MAAM,CAACE,CAAC,GAAG,CAAC,CAAC,EAAEF,MAAM,CAACE,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAACF,MAAM,CAACE,CAAC,GAAG,CAAC,CAAC,EAAEF,MAAM,CAACE,CAAC,GAAG,CAAC,CAAC,CAAC;MACjE;IACF;IAEA,OAAOF,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6E,+BAA+BA,CAACvH,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAEY,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAC1E,MAAM;MACJyG,QAAQ,GAAG,EAAE;MAAG;MAChBnH,GAAG,GAAG,CAAC;MACPC,GAAG,GAAG;IACR,CAAC,GAAGL,OAAO;IAEX,OAAOoC,KAAK,CAACC,IAAI,CAAC;MAAEC,MAAM,EAAEvC;IAAK,CAAC,EAAE,CAAC2C,CAAC,EAAEC,CAAC,KAAK;MAC5C,OAAO;QACL6E,GAAG,EAAEpH,GAAG,GAAIuC,CAAC,GAAG4E,QAAS;QAAG;QAC5BE,aAAa,EAAE9E,CAAC;QAAW;QAC3BY,KAAK,EAAE1C,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIP,GAAG,GAAGD,GAAG,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAE;MACzD,CAAC;IACH,CAAC,CAAC;EACJ,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEsH,oBAAoBA,CAAC3H,IAAI,EAAE4H,CAAC,GAAG,EAAE,EAAEvH,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAC7E;IACA,MAAMiC,MAAM,GAAG,IAAI,CAACzB,kBAAkB,CAACvB,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;IACtD,MAAMoC,MAAM,GAAG,CAAC,GAAGM,MAAM,CAAC;;IAE1B;IACA,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;MAC7B,MAAMiF,SAAS,GAAG/G,IAAI,CAACT,GAAG,CAACuH,CAAC,EAAE9G,IAAI,CAACT,GAAG,CAACuC,CAAC,EAAE5C,IAAI,GAAG,CAAC,GAAG4C,CAAC,CAAC,CAAC;MACxD,IAAIiF,SAAS,KAAK,CAAC,EAAE;MAErB,MAAMvE,MAAM,GAAGxC,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIgH,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAGA,SAAS;MACvE,MAAMC,MAAM,GAAGlF,CAAC,GAAGU,MAAM;;MAEzB;MACA,CAACZ,MAAM,CAACE,CAAC,CAAC,EAAEF,MAAM,CAACoF,MAAM,CAAC,CAAC,GAAG,CAACpF,MAAM,CAACoF,MAAM,CAAC,EAAEpF,MAAM,CAACE,CAAC,CAAC,CAAC;IAC3D;IAEA,OAAOF,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEqF,2BAA2BA,CAAC/H,IAAI,EAAEgI,OAAO,GAAG,EAAE,EAAE3H,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAC1F,MAAM2B,MAAM,GAAG,EAAE;IACjB,IAAIuF,UAAU,GAAG,CAAC;IAElB,OAAOA,UAAU,GAAGjI,IAAI,EAAE;MACxB;MACA,MAAMkI,WAAW,GAAGpH,IAAI,CAACT,GAAG,CAC1BL,IAAI,GAAGiI,UAAU,EACjBnH,IAAI,CAACR,GAAG,CAAC,CAAC,EAAEQ,IAAI,CAACiB,KAAK,CAACiG,OAAO,IAAI,GAAG,GAAGnH,QAAQ,CAAC,CAAC,CAAC,CAAC,CACtD,CAAC;;MAED;MACA,MAAMsH,MAAM,GAAG9H,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIP,GAAG,GAAGD,GAAG,CAAC,GAAG,CAAC,CAAC;MAC7D,MAAM+H,MAAM,GAAGD,MAAM,GAAGrH,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIP,GAAG,GAAG6H,MAAM,CAAC,CAAC;MAC/D,MAAME,GAAG,GAAG,IAAI,CAAC9G,kBAAkB,CAAC2G,WAAW,EAAEC,MAAM,EAAEC,MAAM,CAAC;;MAEhE;MACA1F,MAAM,CAACe,IAAI,CAAC,GAAG4E,GAAG,CAAC;MACnBJ,UAAU,IAAIC,WAAW;IAC3B;IAEA,OAAOxF,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE4F,0BAA0BA,CAACtI,IAAI,EAAEuI,aAAa,GAAG,IAAI,EAAElI,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACjG;IACA,MAAMiC,MAAM,GAAG,IAAI,CAACzB,kBAAkB,CAACvB,IAAI,EAAEK,GAAG,EAAEC,GAAG,CAAC;;IAEtD;IACA,IAAIiI,aAAa,KAAK,IAAI,EAAE;MAC1BA,aAAa,GAAGzH,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,GAAGb,IAAI,CAAC;IAC/C;;IAEA;IACAuI,aAAa,GAAGzH,IAAI,CAACR,GAAG,CAAC,CAAC,EAAEQ,IAAI,CAACT,GAAG,CAACL,IAAI,GAAG,CAAC,EAAEuI,aAAa,CAAC,CAAC;;IAE9D;IACA,MAAM7F,MAAM,GAAG,CACb,GAAGM,MAAM,CAAC4B,KAAK,CAAC2D,aAAa,CAAC,EAC9B,GAAGvF,MAAM,CAAC4B,KAAK,CAAC,CAAC,EAAE2D,aAAa,CAAC,CAClC;IAED,OAAO7F,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE8F,qBAAqBA,CAACxI,IAAI,EAAEyI,SAAS,GAAG,CAAC,EAAE5H,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACjE,OAAOsB,KAAK,CAACC,IAAI,CAAC;MAAEC,MAAM,EAAEvC;IAAK,CAAC,EAAE,MAClCc,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,GAAG4H,SAAS,CACnC,CAAC;EACH,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,yBAAyBA,CAAC1I,IAAI,EAAEK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEqI,YAAY,GAAG,SAAS,EAAE9H,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACpG;IACA,IAAI0D,IAAI;IAER,QAAQkE,YAAY,CAACzH,WAAW,CAAC,CAAC;MAChC,KAAK,UAAU;MACf,KAAK,QAAQ;QACXuD,IAAI,GAAG,IAAI,CAACzC,4BAA4B,CAAChC,IAAI,EAAE;UAAEK,GAAG;UAAEC;QAAI,CAAC,EAAEO,QAAQ,CAAC;QACtE;MACF,KAAK,aAAa;QAChB4D,IAAI,GAAG,IAAI,CAACc,+BAA+B,CAACvF,IAAI,EAAE;UAAEK,GAAG;UAAEC;QAAI,CAAC,EAAEO,QAAQ,CAAC;QACzE;MACF,KAAK,SAAS;QACZ4D,IAAI,GAAG,IAAI,CAACkB,2BAA2B,CAAC3F,IAAI,EAAE;UAAEK,GAAG;UAAEC;QAAI,CAAC,EAAEO,QAAQ,CAAC;QACrE;MACF,KAAK,YAAY;QACf4D,IAAI,GAAG,IAAI,CAACnD,qBAAqB,CAACtB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEQ,IAAI,CAAC8C,IAAI,CAAC5D,IAAI,GAAG,EAAE,CAAC,EAAEa,QAAQ,CAAC;QACjF;MACF,KAAK,SAAS;MACd;QACE4D,IAAI,GAAG,IAAI,CAACtD,kBAAkB,CAACnB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;IAC5D;IAEA,OAAO4D,IAAI;EACb,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEmE,gBAAgBA,CAAC5I,IAAI,EAAE4H,CAAC,GAAG,EAAE,EAAEvH,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACzE;IACA,MAAM0D,IAAI,GAAG,IAAI,CAACtD,kBAAkB,CAACnB,IAAI,EAAEK,GAAG,EAAEC,GAAG,EAAEO,QAAQ,CAAC;;IAE9D;IACA,MAAMgI,UAAU,GAAG,CAAC,GAAGpE,IAAI,CAAC,CAACI,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAGD,CAAC,CAAC;IAClD,MAAMgE,IAAI,GAAGD,UAAU,CAACjE,KAAK,CAAC,CAAC,EAAEgD,CAAC,CAAC;IAEnC,OAAO;MACLnD,IAAI;MACJqE;IACF,CAAC;EACH,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,qBAAqBA,CAACnB,CAAC,GAAG,CAAC,EAAEoB,OAAO,GAAG,EAAE,EAAE3I,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAE2I,aAAa,GAAG,KAAK,EAAEpI,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAC5G,MAAMmI,MAAM,GAAG,EAAE;IAEjB,IAAID,aAAa,EAAE;MACjB;MACA,MAAME,SAAS,GAAG,CAAC7I,GAAG,GAAGD,GAAG,IAAIuH,CAAC;MAEjC,KAAK,IAAIhF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgF,CAAC,EAAEhF,CAAC,EAAE,EAAE;QAC1B;QACA,MAAMwG,QAAQ,GAAG/I,GAAG,GAAGuC,CAAC,GAAGuG,SAAS;QACpC,MAAME,QAAQ,GAAGD,QAAQ,GAAGD,SAAS;;QAErC;QACA,MAAMG,QAAQ,GAAGxI,IAAI,CAACR,GAAG,CAAC,CAAC,EAAEQ,IAAI,CAACiB,KAAK,CAACiH,OAAO,IAAI,GAAG,GAAGnI,QAAQ,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;;QAE5E;QACA,MAAM0I,KAAK,GAAG,IAAI,CAAChI,kBAAkB,CAAC+H,QAAQ,EAAEF,QAAQ,EAAEC,QAAQ,CAAC;QACnEH,MAAM,CAACzF,IAAI,CAAC8F,KAAK,CAAC;MACpB;IACF,CAAC,MAAM;MACL;MACA,KAAK,IAAI3G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgF,CAAC,EAAEhF,CAAC,EAAE,EAAE;QAC1B;QACA,MAAM0G,QAAQ,GAAGxI,IAAI,CAACR,GAAG,CAAC,CAAC,EAAEQ,IAAI,CAACiB,KAAK,CAACiH,OAAO,IAAI,GAAG,GAAGnI,QAAQ,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;;QAE5E;QACA,MAAMuI,QAAQ,GAAG/I,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIP,GAAG,GAAGD,GAAG,CAAC,GAAG,CAAC,CAAC;QAC/D,MAAMgJ,QAAQ,GAAGD,QAAQ,GAAGtI,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAIP,GAAG,GAAG8I,QAAQ,CAAC,CAAC;;QAErE;QACA,MAAMG,KAAK,GAAG,IAAI,CAAChI,kBAAkB,CAAC+H,QAAQ,EAAEF,QAAQ,EAAEC,QAAQ,CAAC;QACnEH,MAAM,CAACzF,IAAI,CAAC8F,KAAK,CAAC;MACpB;IACF;IAEA,OAAOL,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,QAAQA,CAACD,KAAK,EAAEE,UAAU,GAAG,IAAI,EAAE;IACjC,IAAIF,KAAK,CAAChH,MAAM,IAAI,CAAC,EAAE,OAAO,IAAI;IAElC,MAAMmH,OAAO,GAAGD,UAAU,KAAK,CAAC3E,CAAC,EAAEC,CAAC,KAAMD,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAC,GAAID,CAAC,GAAGC,CAAC,GAAG,CAAC,GAAG,CAAG,CAAC;IAExE,KAAK,IAAInC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2G,KAAK,CAAChH,MAAM,EAAEK,CAAC,EAAE,EAAE;MACrC,IAAI8G,OAAO,CAACH,KAAK,CAAC3G,CAAC,CAAC,EAAE2G,KAAK,CAAC3G,CAAC,GAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;QACrC,OAAO,KAAK;MACd;IACF;IAEA,OAAO,IAAI;EACb,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE+G,iBAAiBA,CAACJ,KAAK,EAAE;IACvB,IAAIA,KAAK,CAAChH,MAAM,IAAI,CAAC,EAAE,OAAO,CAAC;IAE/B,IAAIqH,UAAU,GAAG,CAAC;IAClB,MAAMC,aAAa,GAAIN,KAAK,CAAChH,MAAM,IAAIgH,KAAK,CAAChH,MAAM,GAAG,CAAC,CAAC,GAAI,CAAC;;IAE7D;IACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2G,KAAK,CAAChH,MAAM,GAAG,CAAC,EAAEK,CAAC,EAAE,EAAE;MACzC,IAAI2G,KAAK,CAAC3G,CAAC,CAAC,GAAG2G,KAAK,CAAC3G,CAAC,GAAG,CAAC,CAAC,EAAE;QAC3BgH,UAAU,EAAE;MACd;IACF;;IAEA;IACA;IACA,OAAO,CAAC,GAAIA,UAAU,IAAIL,KAAK,CAAChH,MAAM,GAAG,CAAC,CAAE;EAC9C,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEuH,0BAA0BA,CAAC9J,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAEY,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IACrE,MAAM;MACJkB,IAAI,GAAG,EAAE;MACTC,MAAM,GAAG,EAAE;MACX6H,QAAQ,GAAG,CAAC;MACZC,QAAQ,GAAG,CAAC;MACZ3J,GAAG,GAAG,CAAC;MACPC,GAAG,GAAG;IACR,CAAC,GAAGL,OAAO;;IAEX;IACA,IAAIwE,IAAI,GAAG,IAAI,CAACzC,4BAA4B,CAAChC,IAAI,EAAE;MAAEiC,IAAI;MAAEC,MAAM;MAAE7B,GAAG;MAAEC;IAAI,CAAC,EAAEO,QAAQ,CAAC;;IAExF;IACA,IAAIkJ,QAAQ,KAAK,CAAC,EAAE;MAClBtF,IAAI,GAAG,IAAI,CAACwF,cAAc,CAACxF,IAAI,EAAEsF,QAAQ,EAAE1J,GAAG,EAAEC,GAAG,CAAC;IACtD;;IAEA;IACA,IAAI0J,QAAQ,KAAK,CAAC,EAAE;MAClBvF,IAAI,GAAG,IAAI,CAACyF,cAAc,CAACzF,IAAI,EAAEuF,QAAQ,EAAE/H,IAAI,EAAE5B,GAAG,EAAEC,GAAG,CAAC;IAC5D;IAEA,OAAOmE,IAAI;EACb,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEwF,cAAcA,CAACxF,IAAI,EAAEsF,QAAQ,EAAE1J,GAAG,EAAEC,GAAG,EAAE;IACvC;IACA,MAAMoC,MAAM,GAAG,EAAE;IACjB,MAAM+C,KAAK,GAAGnF,GAAG,GAAGD,GAAG;IAEvB,KAAK,IAAImD,KAAK,IAAIiB,IAAI,EAAE;MACtB;MACA,MAAM0F,UAAU,GAAG,CAAC3G,KAAK,GAAGnD,GAAG,IAAIoF,KAAK;;MAExC;MACA;MACA;MACA,IAAI2E,WAAW;MACf,IAAIL,QAAQ,GAAG,CAAC,EAAE;QAChBK,WAAW,GAAGtJ,IAAI,CAACuJ,GAAG,CAACF,UAAU,EAAE,CAAC,IAAI,CAAC,GAAGJ,QAAQ,CAAC,CAAC;MACxD,CAAC,MAAM;QACLK,WAAW,GAAG,CAAC,GAAGtJ,IAAI,CAACuJ,GAAG,CAAC,CAAC,GAAGF,UAAU,EAAE,CAAC,IAAI,CAAC,GAAGJ,QAAQ,CAAC,CAAC;MAChE;;MAEA;MACArH,MAAM,CAACe,IAAI,CAACpD,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAACqI,WAAW,GAAG3E,KAAK,CAAC,CAAC;IACpD;IAEA,OAAO/C,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEwH,cAAcA,CAACzF,IAAI,EAAEuF,QAAQ,EAAE/H,IAAI,EAAE5B,GAAG,EAAEC,GAAG,EAAE;IAC7C;IACA,MAAMoC,MAAM,GAAG,EAAE;IAEjB,KAAK,IAAIc,KAAK,IAAIiB,IAAI,EAAE;MACtB;MACA,MAAM6F,YAAY,GAAG9G,KAAK,GAAGvB,IAAI;MAEjC,IAAImI,WAAW;MACf,IAAIJ,QAAQ,GAAG,CAAC,EAAE;QAChB;QACAI,WAAW,GAAGnI,IAAI,GAAGnB,IAAI,CAACyJ,IAAI,CAACD,YAAY,CAAC,GAAGxJ,IAAI,CAACuJ,GAAG,CAACvJ,IAAI,CAAC0J,GAAG,CAACF,YAAY,CAAC,EAAE,CAAC,GAAGN,QAAQ,CAAC;MAC/F,CAAC,MAAM;QACL;QACAI,WAAW,GAAGnI,IAAI,GAAGnB,IAAI,CAACyJ,IAAI,CAACD,YAAY,CAAC,GAAGxJ,IAAI,CAACuJ,GAAG,CAACvJ,IAAI,CAAC0J,GAAG,CAACF,YAAY,CAAC,EAAE,CAAC,GAAGN,QAAQ,CAAC;MAC/F;;MAEA;MACAI,WAAW,GAAGtJ,IAAI,CAACR,GAAG,CAACD,GAAG,EAAES,IAAI,CAACT,GAAG,CAACC,GAAG,EAAE8J,WAAW,CAAC,CAAC;MACvD1H,MAAM,CAACe,IAAI,CAAC3C,IAAI,CAACiB,KAAK,CAACqI,WAAW,CAAC,CAAC;IACtC;IAEA,OAAO1H,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE+H,0BAA0BA,CAACzK,IAAI,EAAE0K,aAAa,EAAErK,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAC1F,MAAM2B,MAAM,GAAG,EAAE;IACjB,IAAIiI,SAAS,GAAG3K,IAAI;IAEpB,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8H,aAAa,CAACnI,MAAM,IAAIoI,SAAS,GAAG,CAAC,EAAE/H,CAAC,EAAE,EAAE;MAC9D,MAAMgI,IAAI,GAAGF,aAAa,CAAC9H,CAAC,CAAC;MAC7B,MAAMiI,KAAK,GAAGjI,CAAC,KAAK8H,aAAa,CAACnI,MAAM,GAAG,CAAC,GAC1CoI,SAAS,GACT7J,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAG4K,IAAI,CAAC7H,KAAK,CAAC;;MAE/B;MACA,IAAI0B,IAAI;MACR,QAAQmG,IAAI,CAAC7K,IAAI;QACf,KAAK,UAAU;QACf,KAAK,QAAQ;UACX0E,IAAI,GAAG,IAAI,CAACzC,4BAA4B,CACtC6I,KAAK,EACL;YACExK,GAAG,EAAEuK,IAAI,CAACvK,GAAG,KAAKM,SAAS,GAAGiK,IAAI,CAACvK,GAAG,GAAGA,GAAG;YAC5CC,GAAG,EAAEsK,IAAI,CAACtK,GAAG,KAAKK,SAAS,GAAGiK,IAAI,CAACtK,GAAG,GAAGA,GAAG;YAC5C,IAAIsK,IAAI,CAACE,MAAM,IAAI,CAAC,CAAC;UACvB,CAAC,EACDjK,QACF,CAAC;UACD;QACF,KAAK,aAAa;UAChB4D,IAAI,GAAG,IAAI,CAACc,+BAA+B,CACzCsF,KAAK,EACL;YACExK,GAAG,EAAEuK,IAAI,CAACvK,GAAG,KAAKM,SAAS,GAAGiK,IAAI,CAACvK,GAAG,GAAGA,GAAG;YAC5CC,GAAG,EAAEsK,IAAI,CAACtK,GAAG,KAAKK,SAAS,GAAGiK,IAAI,CAACtK,GAAG,GAAGA,GAAG;YAC5C,IAAIsK,IAAI,CAACE,MAAM,IAAI,CAAC,CAAC;UACvB,CAAC,EACDjK,QACF,CAAC;UACD;QACF,KAAK,SAAS;UACZ4D,IAAI,GAAG,IAAI,CAACkB,2BAA2B,CACrCkF,KAAK,EACL;YACExK,GAAG,EAAEuK,IAAI,CAACvK,GAAG,KAAKM,SAAS,GAAGiK,IAAI,CAACvK,GAAG,GAAGA,GAAG;YAC5CC,GAAG,EAAEsK,IAAI,CAACtK,GAAG,KAAKK,SAAS,GAAGiK,IAAI,CAACtK,GAAG,GAAGA,GAAG;YAC5C,IAAIsK,IAAI,CAACE,MAAM,IAAI,CAAC,CAAC;UACvB,CAAC,EACDjK,QACF,CAAC;UACD;QACF,KAAK,SAAS;QACd;UACE4D,IAAI,GAAG,IAAI,CAACtD,kBAAkB,CAC5B0J,KAAK,EACLD,IAAI,CAACvK,GAAG,KAAKM,SAAS,GAAGiK,IAAI,CAACvK,GAAG,GAAGA,GAAG,EACvCuK,IAAI,CAACtK,GAAG,KAAKK,SAAS,GAAGiK,IAAI,CAACtK,GAAG,GAAGA,GAAG,EACvCO,QACF,CAAC;MACL;MAEA6B,MAAM,CAACe,IAAI,CAAC,GAAGgB,IAAI,CAAC;MACpBkG,SAAS,IAAIE,KAAK;IACpB;;IAEA;IACA,OAAO,IAAI,CAAClJ,aAAa,CAACe,MAAM,EAAE7B,QAAQ,CAAC;EAC7C,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEc,aAAaA,CAAC4H,KAAK,EAAE1I,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAC3C,MAAM2B,MAAM,GAAG,CAAC,GAAG6G,KAAK,CAAC;IAEzB,KAAK,IAAI3G,CAAC,GAAGF,MAAM,CAACH,MAAM,GAAG,CAAC,EAAEK,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1C,MAAMmI,CAAC,GAAGjK,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,IAAI+B,CAAC,GAAG,CAAC,CAAC,CAAC;MAC1C,CAACF,MAAM,CAACE,CAAC,CAAC,EAAEF,MAAM,CAACqI,CAAC,CAAC,CAAC,GAAG,CAACrI,MAAM,CAACqI,CAAC,CAAC,EAAErI,MAAM,CAACE,CAAC,CAAC,CAAC;IACjD;IAEA,OAAOF,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEzB,mBAAmBA,CAACP,IAAI,EAAE;IACxB;IACA,IAAIsK,KAAK,GAAGtK,IAAI;IAEhB,OAAO,YAAW;MAChB;MACAsK,KAAK,IAAIA,KAAK,IAAI,EAAE;MACpBA,KAAK,IAAIA,KAAK,KAAK,EAAE;MACrBA,KAAK,IAAIA,KAAK,IAAI,CAAC;;MAEnB;MACA,OAAO,CAACA,KAAK,KAAK,CAAC,IAAI,UAAU;IACnC,CAAC;EACH,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,mBAAmBA,CAAC1B,KAAK,EAAE;IACzB,IAAIA,KAAK,CAAChH,MAAM,KAAK,CAAC,EAAE;MACtB,OAAO;QACLlC,GAAG,EAAE6K,GAAG;QACR5K,GAAG,EAAE4K,GAAG;QACRjJ,IAAI,EAAEiJ,GAAG;QACTC,MAAM,EAAED,GAAG;QACXE,iBAAiB,EAAEF;MACrB,CAAC;IACH;;IAEA;IACA,IAAI7K,GAAG,GAAGkJ,KAAK,CAAC,CAAC,CAAC;IAClB,IAAIjJ,GAAG,GAAGiJ,KAAK,CAAC,CAAC,CAAC;;IAElB;IACA,IAAI8B,GAAG,GAAG,CAAC;IAEX,KAAK,IAAIzI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2G,KAAK,CAAChH,MAAM,EAAEK,CAAC,EAAE,EAAE;MACrC,MAAMY,KAAK,GAAG+F,KAAK,CAAC3G,CAAC,CAAC;MACtBvC,GAAG,GAAGS,IAAI,CAACT,GAAG,CAACA,GAAG,EAAEmD,KAAK,CAAC;MAC1BlD,GAAG,GAAGQ,IAAI,CAACR,GAAG,CAACA,GAAG,EAAEkD,KAAK,CAAC;MAC1B6H,GAAG,IAAI7H,KAAK;IACd;;IAEA;IACA,MAAMvB,IAAI,GAAGoJ,GAAG,GAAG9B,KAAK,CAAChH,MAAM;;IAE/B;IACA,MAAM+I,SAAS,GAAG,CAAC,GAAG/B,KAAK,CAAC,CAAC1E,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;IAClD,MAAMwG,MAAM,GAAGzK,IAAI,CAACiB,KAAK,CAACwH,KAAK,CAAChH,MAAM,GAAG,CAAC,CAAC;IAC3C,MAAM4I,MAAM,GAAG5B,KAAK,CAAChH,MAAM,GAAG,CAAC,KAAK,CAAC,GACjC,CAAC+I,SAAS,CAACC,MAAM,GAAG,CAAC,CAAC,GAAGD,SAAS,CAACC,MAAM,CAAC,IAAI,CAAC,GAC/CD,SAAS,CAACC,MAAM,CAAC;;IAErB;IACA,IAAIC,QAAQ,GAAG,CAAC;IAChB,KAAK,IAAI5I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2G,KAAK,CAAChH,MAAM,EAAEK,CAAC,EAAE,EAAE;MACrC,MAAM6I,IAAI,GAAGlC,KAAK,CAAC3G,CAAC,CAAC,GAAGX,IAAI;MAC5BuJ,QAAQ,IAAIC,IAAI,GAAGA,IAAI;IACzB;IACAD,QAAQ,IAAIjC,KAAK,CAAChH,MAAM;IACxB,MAAM6I,iBAAiB,GAAGtK,IAAI,CAACmD,IAAI,CAACuH,QAAQ,CAAC;IAE7C,OAAO;MACLnL,GAAG;MACHC,GAAG;MACH2B,IAAI;MACJkJ,MAAM;MACNC;IACF,CAAC;EACH,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,gBAAgBA,CAACxF,SAAS,EAAEyF,QAAQ,EAAE3L,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACxD,MAAM2L,SAAS,GAAG1F,SAAS,CAAChF,WAAW,CAAC,CAAC;IACzC,MAAM2K,SAAS,GAAGF,QAAQ,CAACzK,WAAW,CAAC,CAAC;IAExC,IAAI2K,SAAS,KAAK,OAAO,EAAE;MACzB;MACA,OAAO,IAAI,CAAC5F,uBAAuB,CAAC2F,SAAS,EAAE5L,IAAI,EAAEC,OAAO,CAAC;IAC/D,CAAC,MAAM,IAAI4L,SAAS,KAAK,MAAM,EAAE;MAC/B;MACA,QAAQD,SAAS;QACf,KAAK,eAAe;QACpB,KAAK,YAAY;UACf,OAAO,IAAI,CAACrK,kBAAkB,CAACvB,IAAI,EAAEC,OAAO,CAACI,GAAG,EAAEJ,OAAO,CAACK,GAAG,CAAC;QAChE,KAAK,WAAW;UACd;UACA,OAAO,IAAI,CAACa,kBAAkB,CAACnB,IAAI,EAAEC,OAAO,CAACI,GAAG,EAAEJ,OAAO,CAACK,GAAG,CAAC;QAChE,KAAK,WAAW;UACd;UACA,OAAO,IAAI,CAACa,kBAAkB,CAACnB,IAAI,EAAEC,OAAO,CAACI,GAAG,EAAEJ,OAAO,CAACK,GAAG,CAAC;QAChE;UACE;UACA,OAAO,IAAI,CAACa,kBAAkB,CAACnB,IAAI,EAAEC,OAAO,CAACI,GAAG,EAAEJ,OAAO,CAACK,GAAG,CAAC;MAClE;IACF,CAAC,MAAM;MACL;MACA,OAAO,IAAI,CAACa,kBAAkB,CAACnB,IAAI,EAAEC,OAAO,CAACI,GAAG,EAAEJ,OAAO,CAACK,GAAG,CAAC;IAChE;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEwL,sBAAsBA,CAAC9L,IAAI,EAAE+L,YAAY,EAAEC,UAAU,EAAEC,eAAe,GAAG,GAAG,EAAEhM,OAAO,GAAG,CAAC,CAAC,EAAE;IAC1F;IACA,MAAMiM,SAAS,GAAGpL,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAGiM,eAAe,CAAC;IACpD,MAAME,UAAU,GAAGnM,IAAI,GAAGkM,SAAS;IAEnC,MAAME,SAAS,GAAG,IAAI,CAACtM,eAAe,CAACiM,YAAY,EAAEG,SAAS,EAAEjM,OAAO,CAAC;IACxE,MAAMoM,UAAU,GAAG,IAAI,CAACvM,eAAe,CAACkM,UAAU,EAAEG,UAAU,EAAElM,OAAO,CAAC;;IAExE;IACA,OAAO,CAAC,GAAGmM,SAAS,EAAE,GAAGC,UAAU,CAAC;EACtC,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,yBAAyBA,CAACtM,IAAI,EAAEuD,WAAW,GAAG,EAAE,EAAEgJ,OAAO,GAAG,QAAQ,EAAElM,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEO,QAAQ,GAAGC,IAAI,CAACC,MAAM,EAAE;IAChH;IACA,MAAMR,YAAY,GAAG,EAAE;IACvB,KAAK,IAAIqC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,WAAW,EAAEX,CAAC,EAAE,EAAE;MACpCrC,YAAY,CAACkD,IAAI,CAACpD,GAAG,GAAGS,IAAI,CAACiB,KAAK,CAAC,CAACzB,GAAG,GAAGD,GAAG,IAAIuC,CAAC,GAAGW,WAAW,CAAC,CAAC;IACpE;IAEA,MAAMb,MAAM,GAAG,EAAE;IAEjB,QAAQ6J,OAAO,CAACrL,WAAW,CAAC,CAAC;MAC3B,KAAK,QAAQ;QACX;QACA,MAAMY,SAAS,GAAGhB,IAAI,CAACiB,KAAK,CAAC/B,IAAI,GAAGuD,WAAW,CAAC;QAChD,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,WAAW,EAAEX,CAAC,EAAE,EAAE;UACpC,MAAMY,KAAK,GAAGjD,YAAY,CAACqC,CAAC,CAAC;UAC7B,KAAK,IAAImI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjJ,SAAS,EAAEiJ,CAAC,EAAE,EAAE;YAClCrI,MAAM,CAACe,IAAI,CAACD,KAAK,CAAC;UACpB;QACF;;QAEA;QACA,OAAOd,MAAM,CAACH,MAAM,GAAGvC,IAAI,EAAE;UAC3B0C,MAAM,CAACe,IAAI,CAAClD,YAAY,CAACgD,WAAW,GAAG,CAAC,CAAC,CAAC;QAC5C;QACA;MAEF,KAAK,aAAa;QAChB;QACA,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;UAC7BF,MAAM,CAACe,IAAI,CAAClD,YAAY,CAACqC,CAAC,GAAGW,WAAW,CAAC,CAAC;QAC5C;QACA;MAEF,KAAK,QAAQ;MACb;QACE;QACA,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,IAAI,EAAE4C,CAAC,EAAE,EAAE;UAC7B,MAAM4J,GAAG,GAAG1L,IAAI,CAACiB,KAAK,CAAClB,QAAQ,CAAC,CAAC,GAAG0C,WAAW,CAAC;UAChDb,MAAM,CAACe,IAAI,CAAClD,YAAY,CAACiM,GAAG,CAAC,CAAC;QAChC;IACJ;IAEA,OAAO9J,MAAM;EACf;AACF,CAAC;AAED,eAAe7C,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module"}