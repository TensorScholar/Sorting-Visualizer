{"ast":null,"code":"// src/algorithms/comparison/bubble.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Bubble Sort with multiple optimization strategies.\n * \n * Bubble Sort is a simple comparison-based sorting algorithm that repeatedly\n * steps through the list, compares adjacent elements, and swaps them if they\n * are in the wrong order. The algorithm gets its name because smaller or larger\n * elements \"bubble\" to the top of the list.\n * \n * This implementation includes several optimizations:\n * 1. Early termination - Stops when no swaps are performed in a pass\n * 2. Adaptive boundary - Tracks the last swap position to reduce comparisons\n * 3. Bidirectional variant (Cocktail Shaker Sort) - Alternates passes between forward and backward directions\n * \n * Time Complexity:\n * - Best:    O(n) with early termination optimization when array is already sorted\n * - Average: O(n²)\n * - Worst:   O(n²) when array is sorted in reverse order\n * \n * Space Complexity:\n * - O(1) - truly in-place algorithm requiring only a constant amount of extra memory\n * \n * @class BubbleSort\n * @extends Algorithm\n */\nclass BubbleSort extends Algorithm {\n  /**\n   * Create a new BubbleSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.optimize=true] - Use early termination optimization\n   * @param {boolean} [options.adaptive=true] - Track sorted boundary for optimization\n   * @param {boolean} [options.bidirectional=false] - Use bidirectional passes (Cocktail Shaker Sort)\n   */\n  constructor(options = {}) {\n    super('Bubble Sort', 'comparison', options);\n\n    // Default options with carefully chosen values based on empirical performance data\n    this.options = {\n      optimize: true,\n      // Early termination when no swaps are performed\n      adaptive: true,\n      // Track boundary of sorted elements\n      bidirectional: false,\n      // Alternate between forward and reverse passes\n      ...options\n    };\n  }\n\n  /**\n   * Execute Bubble Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Create a copy to avoid modifying the original array\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for edge cases\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('sorting');\n\n    // Choose algorithm variant based on options\n    if (options.bidirectional) {\n      this.cocktailShakerSort(result, options);\n    } else {\n      this.standardBubbleSort(result, options);\n    }\n    this.setPhase('completed');\n    return result;\n  }\n\n  /**\n   * Standard Bubble Sort implementation with optimizations\n   * \n   * @param {Array} array - The array to sort (modified in place)\n   * @param {Object} options - Runtime options\n   */\n  standardBubbleSort(array, options) {\n    const n = array.length;\n\n    // Track the boundary for optimization (all elements after this are known to be sorted)\n    let sortedBoundary = n;\n\n    // Main sorting loop - at most n-1 passes required\n    for (let i = 0; i < n - 1; i++) {\n      // Flag to detect if any swaps were made in this pass\n      let swapped = false;\n\n      // Track the highest index where a swap occurred in this pass\n      let lastSwap = 0;\n\n      // Record the beginning of a new pass\n      this.recordState(array, {\n        type: 'pass-start',\n        pass: i + 1,\n        message: `Starting pass ${i + 1}`\n      });\n\n      // One pass through the unsorted portion of the array\n      for (let j = 1; j < sortedBoundary; j++) {\n        // Compare adjacent elements\n        const comparisonResult = this.compare(array[j - 1], array[j]);\n\n        // Record the comparison operation\n        this.recordState(array, {\n          type: 'comparison',\n          indices: [j - 1, j],\n          result: comparisonResult,\n          message: `Comparing elements at indices ${j - 1} and ${j}`\n        });\n\n        // If elements are out of order, swap them\n        if (comparisonResult > 0) {\n          this.swap(array, j - 1, j);\n          swapped = true;\n          lastSwap = j;\n\n          // Record the swap operation\n          this.recordState(array, {\n            type: 'swap',\n            indices: [j - 1, j],\n            message: `Swapped elements at indices ${j - 1} and ${j}`\n          });\n        }\n      }\n\n      // Early termination optimization: If no swaps were made, the array is sorted\n      if (options.optimize && !swapped) {\n        this.recordState(array, {\n          type: 'optimization',\n          message: `Early termination: No swaps in pass ${i + 1}, array is sorted`\n        });\n        break;\n      }\n\n      // Adaptive boundary optimization: Update the sorted boundary\n      if (options.adaptive) {\n        sortedBoundary = lastSwap || sortedBoundary;\n        if (sortedBoundary < n) {\n          // Mark elements beyond the boundary as sorted\n          this.recordState(array, {\n            type: 'sorted',\n            indices: Array.from({\n              length: n - sortedBoundary\n            }, (_, idx) => sortedBoundary + idx),\n            message: `Elements from index ${sortedBoundary} to ${n - 1} are now sorted`\n          });\n        }\n      } else {\n        // When not using adaptive optimization, at least the last element is guaranteed to be in its final position\n        this.recordState(array, {\n          type: 'sorted',\n          indices: [n - i - 1],\n          message: `Element at index ${n - i - 1} is now in its correct position`\n        });\n      }\n\n      // Record completion of the pass\n      this.recordState(array, {\n        type: 'pass-end',\n        pass: i + 1,\n        message: `Completed pass ${i + 1}`\n      });\n    }\n  }\n\n  /**\n   * Bidirectional Bubble Sort (Cocktail Shaker Sort) implementation\n   * Performs passes alternating between forward and backward directions\n   * \n   * @param {Array} array - The array to sort (modified in place)\n   * @param {Object} options - Runtime options\n   */\n  cocktailShakerSort(array, options) {\n    const n = array.length;\n\n    // Initialize boundaries for the unsorted portion\n    let start = 0;\n    let end = n - 1;\n\n    // Flag to detect if any swaps were made in either pass\n    let swapped = true;\n\n    // Main sorting loop\n    let pass = 0;\n    while (swapped && start < end) {\n      swapped = false;\n      pass++;\n\n      // Record the beginning of a forward pass\n      this.recordState(array, {\n        type: 'pass-start',\n        direction: 'forward',\n        pass,\n        message: `Starting forward pass ${pass}`\n      });\n\n      // Forward pass - bubble the largest element to the end\n      for (let i = start; i < end; i++) {\n        // Compare adjacent elements\n        const comparisonResult = this.compare(array[i], array[i + 1]);\n\n        // Record the comparison operation\n        this.recordState(array, {\n          type: 'comparison',\n          indices: [i, i + 1],\n          result: comparisonResult,\n          message: `Comparing elements at indices ${i} and ${i + 1}`\n        });\n\n        // If elements are out of order, swap them\n        if (comparisonResult > 0) {\n          this.swap(array, i, i + 1);\n          swapped = true;\n\n          // Record the swap operation\n          this.recordState(array, {\n            type: 'swap',\n            indices: [i, i + 1],\n            message: `Swapped elements at indices ${i} and ${i + 1}`\n          });\n        }\n      }\n\n      // Mark the end element as sorted\n      this.recordState(array, {\n        type: 'sorted',\n        indices: [end],\n        message: `Element at index ${end} is now in its correct position`\n      });\n\n      // Record completion of the forward pass\n      this.recordState(array, {\n        type: 'pass-end',\n        direction: 'forward',\n        pass,\n        message: `Completed forward pass ${pass}`\n      });\n\n      // Decrement end boundary as the largest element is now in place\n      end--;\n\n      // Early termination optimization: If no swaps were made, the array is sorted\n      if (options.optimize && !swapped) {\n        this.recordState(array, {\n          type: 'optimization',\n          message: `Early termination: No swaps in forward pass ${pass}, array is sorted`\n        });\n        break;\n      }\n      swapped = false;\n\n      // Record the beginning of a backward pass\n      this.recordState(array, {\n        type: 'pass-start',\n        direction: 'backward',\n        pass,\n        message: `Starting backward pass ${pass}`\n      });\n\n      // Backward pass - bubble the smallest element to the beginning\n      for (let i = end; i > start; i--) {\n        // Compare adjacent elements\n        const comparisonResult = this.compare(array[i - 1], array[i]);\n\n        // Record the comparison operation\n        this.recordState(array, {\n          type: 'comparison',\n          indices: [i - 1, i],\n          result: comparisonResult,\n          message: `Comparing elements at indices ${i - 1} and ${i}`\n        });\n\n        // If elements are out of order, swap them\n        if (comparisonResult > 0) {\n          this.swap(array, i - 1, i);\n          swapped = true;\n\n          // Record the swap operation\n          this.recordState(array, {\n            type: 'swap',\n            indices: [i - 1, i],\n            message: `Swapped elements at indices ${i - 1} and ${i}`\n          });\n        }\n      }\n\n      // Mark the start element as sorted\n      this.recordState(array, {\n        type: 'sorted',\n        indices: [start],\n        message: `Element at index ${start} is now in its correct position`\n      });\n\n      // Record completion of the backward pass\n      this.recordState(array, {\n        type: 'pass-end',\n        direction: 'backward',\n        pass,\n        message: `Completed backward pass ${pass}`\n      });\n\n      // Increment start boundary as the smallest element is now in place\n      start++;\n\n      // Early termination optimization: If no swaps were made, the array is sorted\n      if (options.optimize && !swapped) {\n        this.recordState(array, {\n          type: 'optimization',\n          message: `Early termination: No swaps in backward pass ${pass}, array is sorted`\n        });\n        break;\n      }\n    }\n  }\n\n  /**\n   * Get the time and space complexity of Bubble Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: this.options.optimize ? 'O(n)' : 'O(n²)',\n        average: 'O(n²)',\n        worst: 'O(n²)'\n      },\n      space: {\n        best: 'O(1)',\n        average: 'O(1)',\n        worst: 'O(1)'\n      }\n    };\n  }\n\n  /**\n   * Whether Bubble Sort is stable (preserves relative order of equal elements)\n   * \n   * @returns {boolean} - True as Bubble Sort is stable\n   */\n  isStable() {\n    return true;\n  }\n\n  /**\n   * Whether Bubble Sort is in-place (uses O(1) auxiliary space)\n   * \n   * @returns {boolean} - True as Bubble Sort is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add bubble sort specific information\n    info.optimization = {\n      earlyTermination: this.options.optimize,\n      adaptiveBoundary: this.options.adaptive,\n      bidirectional: this.options.bidirectional\n    };\n    info.properties = {\n      comparisonBased: true,\n      stable: true,\n      inPlace: true,\n      online: true,\n      adaptive: this.options.optimize || this.options.adaptive\n    };\n    info.suitable = {\n      smallArrays: true,\n      nearlySortedArrays: this.options.optimize,\n      largeArrays: false,\n      educationalPurposes: true\n    };\n    info.variants = ['Standard Bubble Sort', 'Optimized Bubble Sort (early termination)', 'Adaptive Bubble Sort (dynamic boundary)', 'Cocktail Shaker Sort (bidirectional)', 'Odd-Even Sort (parallel variant)'];\n    info.advantages = ['Simple implementation and concept', 'Minimal space complexity (O(1))', 'Stable sorting (preserves order of equal elements)', 'Adaptive when optimized (performs better on partially sorted arrays)', 'Online algorithm (can sort as elements arrive)'];\n    info.disadvantages = ['Poor time complexity (O(n²)) makes it impractical for large arrays', 'Performs significantly more swaps than other algorithms', 'Generally outperformed by insertion sort for small arrays', 'Poor cache performance due to many swap operations'];\n    info.performance = {\n      bestCase: 'Already sorted arrays (with early termination)',\n      worstCase: 'Arrays sorted in reverse order',\n      averageCase: 'Random arrays'\n    };\n    return info;\n  }\n}\nexport default BubbleSort;","map":{"version":3,"names":["Algorithm","BubbleSort","constructor","options","optimize","adaptive","bidirectional","run","array","result","n","length","setPhase","cocktailShakerSort","standardBubbleSort","sortedBoundary","i","swapped","lastSwap","recordState","type","pass","message","j","comparisonResult","compare","indices","swap","Array","from","_","idx","start","end","direction","getComplexity","time","best","average","worst","space","isStable","isInPlace","getInfo","info","optimization","earlyTermination","adaptiveBoundary","properties","comparisonBased","stable","inPlace","online","suitable","smallArrays","nearlySortedArrays","largeArrays","educationalPurposes","variants","advantages","disadvantages","performance","bestCase","worstCase","averageCase"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/comparison/bubble.js"],"sourcesContent":["// src/algorithms/comparison/bubble.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Bubble Sort with multiple optimization strategies.\n * \n * Bubble Sort is a simple comparison-based sorting algorithm that repeatedly\n * steps through the list, compares adjacent elements, and swaps them if they\n * are in the wrong order. The algorithm gets its name because smaller or larger\n * elements \"bubble\" to the top of the list.\n * \n * This implementation includes several optimizations:\n * 1. Early termination - Stops when no swaps are performed in a pass\n * 2. Adaptive boundary - Tracks the last swap position to reduce comparisons\n * 3. Bidirectional variant (Cocktail Shaker Sort) - Alternates passes between forward and backward directions\n * \n * Time Complexity:\n * - Best:    O(n) with early termination optimization when array is already sorted\n * - Average: O(n²)\n * - Worst:   O(n²) when array is sorted in reverse order\n * \n * Space Complexity:\n * - O(1) - truly in-place algorithm requiring only a constant amount of extra memory\n * \n * @class BubbleSort\n * @extends Algorithm\n */\nclass BubbleSort extends Algorithm {\n  /**\n   * Create a new BubbleSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.optimize=true] - Use early termination optimization\n   * @param {boolean} [options.adaptive=true] - Track sorted boundary for optimization\n   * @param {boolean} [options.bidirectional=false] - Use bidirectional passes (Cocktail Shaker Sort)\n   */\n  constructor(options = {}) {\n    super('Bubble Sort', 'comparison', options);\n    \n    // Default options with carefully chosen values based on empirical performance data\n    this.options = {\n      optimize: true,       // Early termination when no swaps are performed\n      adaptive: true,       // Track boundary of sorted elements\n      bidirectional: false, // Alternate between forward and reverse passes\n      ...options\n    };\n  }\n  \n  /**\n   * Execute Bubble Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Create a copy to avoid modifying the original array\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for edge cases\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('sorting');\n    \n    // Choose algorithm variant based on options\n    if (options.bidirectional) {\n      this.cocktailShakerSort(result, options);\n    } else {\n      this.standardBubbleSort(result, options);\n    }\n    \n    this.setPhase('completed');\n    return result;\n  }\n  \n  /**\n   * Standard Bubble Sort implementation with optimizations\n   * \n   * @param {Array} array - The array to sort (modified in place)\n   * @param {Object} options - Runtime options\n   */\n  standardBubbleSort(array, options) {\n    const n = array.length;\n    \n    // Track the boundary for optimization (all elements after this are known to be sorted)\n    let sortedBoundary = n;\n    \n    // Main sorting loop - at most n-1 passes required\n    for (let i = 0; i < n - 1; i++) {\n      // Flag to detect if any swaps were made in this pass\n      let swapped = false;\n      \n      // Track the highest index where a swap occurred in this pass\n      let lastSwap = 0;\n      \n      // Record the beginning of a new pass\n      this.recordState(array, {\n        type: 'pass-start',\n        pass: i + 1,\n        message: `Starting pass ${i + 1}`\n      });\n      \n      // One pass through the unsorted portion of the array\n      for (let j = 1; j < sortedBoundary; j++) {\n        // Compare adjacent elements\n        const comparisonResult = this.compare(array[j - 1], array[j]);\n        \n        // Record the comparison operation\n        this.recordState(array, {\n          type: 'comparison',\n          indices: [j - 1, j],\n          result: comparisonResult,\n          message: `Comparing elements at indices ${j - 1} and ${j}`\n        });\n        \n        // If elements are out of order, swap them\n        if (comparisonResult > 0) {\n          this.swap(array, j - 1, j);\n          swapped = true;\n          lastSwap = j;\n          \n          // Record the swap operation\n          this.recordState(array, {\n            type: 'swap',\n            indices: [j - 1, j],\n            message: `Swapped elements at indices ${j - 1} and ${j}`\n          });\n        }\n      }\n      \n      // Early termination optimization: If no swaps were made, the array is sorted\n      if (options.optimize && !swapped) {\n        this.recordState(array, {\n          type: 'optimization',\n          message: `Early termination: No swaps in pass ${i + 1}, array is sorted`\n        });\n        break;\n      }\n      \n      // Adaptive boundary optimization: Update the sorted boundary\n      if (options.adaptive) {\n        sortedBoundary = lastSwap || sortedBoundary;\n        \n        if (sortedBoundary < n) {\n          // Mark elements beyond the boundary as sorted\n          this.recordState(array, {\n            type: 'sorted',\n            indices: Array.from({ length: n - sortedBoundary }, (_, idx) => sortedBoundary + idx),\n            message: `Elements from index ${sortedBoundary} to ${n - 1} are now sorted`\n          });\n        }\n      } else {\n        // When not using adaptive optimization, at least the last element is guaranteed to be in its final position\n        this.recordState(array, {\n          type: 'sorted',\n          indices: [n - i - 1],\n          message: `Element at index ${n - i - 1} is now in its correct position`\n        });\n      }\n      \n      // Record completion of the pass\n      this.recordState(array, {\n        type: 'pass-end',\n        pass: i + 1,\n        message: `Completed pass ${i + 1}`\n      });\n    }\n  }\n  \n  /**\n   * Bidirectional Bubble Sort (Cocktail Shaker Sort) implementation\n   * Performs passes alternating between forward and backward directions\n   * \n   * @param {Array} array - The array to sort (modified in place)\n   * @param {Object} options - Runtime options\n   */\n  cocktailShakerSort(array, options) {\n    const n = array.length;\n    \n    // Initialize boundaries for the unsorted portion\n    let start = 0;\n    let end = n - 1;\n    \n    // Flag to detect if any swaps were made in either pass\n    let swapped = true;\n    \n    // Main sorting loop\n    let pass = 0;\n    \n    while (swapped && start < end) {\n      swapped = false;\n      pass++;\n      \n      // Record the beginning of a forward pass\n      this.recordState(array, {\n        type: 'pass-start',\n        direction: 'forward',\n        pass,\n        message: `Starting forward pass ${pass}`\n      });\n      \n      // Forward pass - bubble the largest element to the end\n      for (let i = start; i < end; i++) {\n        // Compare adjacent elements\n        const comparisonResult = this.compare(array[i], array[i + 1]);\n        \n        // Record the comparison operation\n        this.recordState(array, {\n          type: 'comparison',\n          indices: [i, i + 1],\n          result: comparisonResult,\n          message: `Comparing elements at indices ${i} and ${i + 1}`\n        });\n        \n        // If elements are out of order, swap them\n        if (comparisonResult > 0) {\n          this.swap(array, i, i + 1);\n          swapped = true;\n          \n          // Record the swap operation\n          this.recordState(array, {\n            type: 'swap',\n            indices: [i, i + 1],\n            message: `Swapped elements at indices ${i} and ${i + 1}`\n          });\n        }\n      }\n      \n      // Mark the end element as sorted\n      this.recordState(array, {\n        type: 'sorted',\n        indices: [end],\n        message: `Element at index ${end} is now in its correct position`\n      });\n      \n      // Record completion of the forward pass\n      this.recordState(array, {\n        type: 'pass-end',\n        direction: 'forward',\n        pass,\n        message: `Completed forward pass ${pass}`\n      });\n      \n      // Decrement end boundary as the largest element is now in place\n      end--;\n      \n      // Early termination optimization: If no swaps were made, the array is sorted\n      if (options.optimize && !swapped) {\n        this.recordState(array, {\n          type: 'optimization',\n          message: `Early termination: No swaps in forward pass ${pass}, array is sorted`\n        });\n        break;\n      }\n      \n      swapped = false;\n      \n      // Record the beginning of a backward pass\n      this.recordState(array, {\n        type: 'pass-start',\n        direction: 'backward',\n        pass,\n        message: `Starting backward pass ${pass}`\n      });\n      \n      // Backward pass - bubble the smallest element to the beginning\n      for (let i = end; i > start; i--) {\n        // Compare adjacent elements\n        const comparisonResult = this.compare(array[i - 1], array[i]);\n        \n        // Record the comparison operation\n        this.recordState(array, {\n          type: 'comparison',\n          indices: [i - 1, i],\n          result: comparisonResult,\n          message: `Comparing elements at indices ${i - 1} and ${i}`\n        });\n        \n        // If elements are out of order, swap them\n        if (comparisonResult > 0) {\n          this.swap(array, i - 1, i);\n          swapped = true;\n          \n          // Record the swap operation\n          this.recordState(array, {\n            type: 'swap',\n            indices: [i - 1, i],\n            message: `Swapped elements at indices ${i - 1} and ${i}`\n          });\n        }\n      }\n      \n      // Mark the start element as sorted\n      this.recordState(array, {\n        type: 'sorted',\n        indices: [start],\n        message: `Element at index ${start} is now in its correct position`\n      });\n      \n      // Record completion of the backward pass\n      this.recordState(array, {\n        type: 'pass-end',\n        direction: 'backward',\n        pass,\n        message: `Completed backward pass ${pass}`\n      });\n      \n      // Increment start boundary as the smallest element is now in place\n      start++;\n      \n      // Early termination optimization: If no swaps were made, the array is sorted\n      if (options.optimize && !swapped) {\n        this.recordState(array, {\n          type: 'optimization',\n          message: `Early termination: No swaps in backward pass ${pass}, array is sorted`\n        });\n        break;\n      }\n    }\n  }\n  \n  /**\n   * Get the time and space complexity of Bubble Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: this.options.optimize ? 'O(n)' : 'O(n²)',\n        average: 'O(n²)',\n        worst: 'O(n²)'\n      },\n      space: {\n        best: 'O(1)',\n        average: 'O(1)',\n        worst: 'O(1)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Bubble Sort is stable (preserves relative order of equal elements)\n   * \n   * @returns {boolean} - True as Bubble Sort is stable\n   */\n  isStable() {\n    return true;\n  }\n  \n  /**\n   * Whether Bubble Sort is in-place (uses O(1) auxiliary space)\n   * \n   * @returns {boolean} - True as Bubble Sort is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add bubble sort specific information\n    info.optimization = {\n      earlyTermination: this.options.optimize,\n      adaptiveBoundary: this.options.adaptive,\n      bidirectional: this.options.bidirectional\n    };\n    \n    info.properties = {\n      comparisonBased: true,\n      stable: true,\n      inPlace: true,\n      online: true,\n      adaptive: this.options.optimize || this.options.adaptive\n    };\n    \n    info.suitable = {\n      smallArrays: true,\n      nearlySortedArrays: this.options.optimize,\n      largeArrays: false,\n      educationalPurposes: true\n    };\n    \n    info.variants = [\n      'Standard Bubble Sort',\n      'Optimized Bubble Sort (early termination)',\n      'Adaptive Bubble Sort (dynamic boundary)',\n      'Cocktail Shaker Sort (bidirectional)',\n      'Odd-Even Sort (parallel variant)'\n    ];\n    \n    info.advantages = [\n      'Simple implementation and concept',\n      'Minimal space complexity (O(1))',\n      'Stable sorting (preserves order of equal elements)',\n      'Adaptive when optimized (performs better on partially sorted arrays)',\n      'Online algorithm (can sort as elements arrive)'\n    ];\n    \n    info.disadvantages = [\n      'Poor time complexity (O(n²)) makes it impractical for large arrays',\n      'Performs significantly more swaps than other algorithms',\n      'Generally outperformed by insertion sort for small arrays',\n      'Poor cache performance due to many swap operations'\n    ];\n    \n    info.performance = {\n      bestCase: 'Already sorted arrays (with early termination)',\n      worstCase: 'Arrays sorted in reverse order',\n      averageCase: 'Random arrays'\n    };\n    \n    return info;\n  }\n}\n\nexport default BubbleSort;"],"mappings":"AAAA;;AAEA,OAAOA,SAAS,MAAM,wBAAwB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,SAASD,SAAS,CAAC;EACjC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,WAAWA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IACxB,KAAK,CAAC,aAAa,EAAE,YAAY,EAAEA,OAAO,CAAC;;IAE3C;IACA,IAAI,CAACA,OAAO,GAAG;MACbC,QAAQ,EAAE,IAAI;MAAQ;MACtBC,QAAQ,EAAE,IAAI;MAAQ;MACtBC,aAAa,EAAE,KAAK;MAAE;MACtB,GAAGH;IACL,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEI,GAAGA,CAACC,KAAK,EAAEL,OAAO,EAAE;IAClB;IACA,MAAMM,MAAM,GAAG,CAAC,GAAGD,KAAK,CAAC;IACzB,MAAME,CAAC,GAAGD,MAAM,CAACE,MAAM;;IAEvB;IACA,IAAID,CAAC,IAAI,CAAC,EAAE;MACV,OAAOD,MAAM;IACf;IAEA,IAAI,CAACG,QAAQ,CAAC,SAAS,CAAC;;IAExB;IACA,IAAIT,OAAO,CAACG,aAAa,EAAE;MACzB,IAAI,CAACO,kBAAkB,CAACJ,MAAM,EAAEN,OAAO,CAAC;IAC1C,CAAC,MAAM;MACL,IAAI,CAACW,kBAAkB,CAACL,MAAM,EAAEN,OAAO,CAAC;IAC1C;IAEA,IAAI,CAACS,QAAQ,CAAC,WAAW,CAAC;IAC1B,OAAOH,MAAM;EACf;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEK,kBAAkBA,CAACN,KAAK,EAAEL,OAAO,EAAE;IACjC,MAAMO,CAAC,GAAGF,KAAK,CAACG,MAAM;;IAEtB;IACA,IAAII,cAAc,GAAGL,CAAC;;IAEtB;IACA,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,CAAC,GAAG,CAAC,EAAEM,CAAC,EAAE,EAAE;MAC9B;MACA,IAAIC,OAAO,GAAG,KAAK;;MAEnB;MACA,IAAIC,QAAQ,GAAG,CAAC;;MAEhB;MACA,IAAI,CAACC,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,YAAY;QAClBC,IAAI,EAAEL,CAAC,GAAG,CAAC;QACXM,OAAO,EAAE,iBAAiBN,CAAC,GAAG,CAAC;MACjC,CAAC,CAAC;;MAEF;MACA,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,cAAc,EAAEQ,CAAC,EAAE,EAAE;QACvC;QACA,MAAMC,gBAAgB,GAAG,IAAI,CAACC,OAAO,CAACjB,KAAK,CAACe,CAAC,GAAG,CAAC,CAAC,EAAEf,KAAK,CAACe,CAAC,CAAC,CAAC;;QAE7D;QACA,IAAI,CAACJ,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,YAAY;UAClBM,OAAO,EAAE,CAACH,CAAC,GAAG,CAAC,EAAEA,CAAC,CAAC;UACnBd,MAAM,EAAEe,gBAAgB;UACxBF,OAAO,EAAE,iCAAiCC,CAAC,GAAG,CAAC,QAAQA,CAAC;QAC1D,CAAC,CAAC;;QAEF;QACA,IAAIC,gBAAgB,GAAG,CAAC,EAAE;UACxB,IAAI,CAACG,IAAI,CAACnB,KAAK,EAAEe,CAAC,GAAG,CAAC,EAAEA,CAAC,CAAC;UAC1BN,OAAO,GAAG,IAAI;UACdC,QAAQ,GAAGK,CAAC;;UAEZ;UACA,IAAI,CAACJ,WAAW,CAACX,KAAK,EAAE;YACtBY,IAAI,EAAE,MAAM;YACZM,OAAO,EAAE,CAACH,CAAC,GAAG,CAAC,EAAEA,CAAC,CAAC;YACnBD,OAAO,EAAE,+BAA+BC,CAAC,GAAG,CAAC,QAAQA,CAAC;UACxD,CAAC,CAAC;QACJ;MACF;;MAEA;MACA,IAAIpB,OAAO,CAACC,QAAQ,IAAI,CAACa,OAAO,EAAE;QAChC,IAAI,CAACE,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,cAAc;UACpBE,OAAO,EAAE,uCAAuCN,CAAC,GAAG,CAAC;QACvD,CAAC,CAAC;QACF;MACF;;MAEA;MACA,IAAIb,OAAO,CAACE,QAAQ,EAAE;QACpBU,cAAc,GAAGG,QAAQ,IAAIH,cAAc;QAE3C,IAAIA,cAAc,GAAGL,CAAC,EAAE;UACtB;UACA,IAAI,CAACS,WAAW,CAACX,KAAK,EAAE;YACtBY,IAAI,EAAE,QAAQ;YACdM,OAAO,EAAEE,KAAK,CAACC,IAAI,CAAC;cAAElB,MAAM,EAAED,CAAC,GAAGK;YAAe,CAAC,EAAE,CAACe,CAAC,EAAEC,GAAG,KAAKhB,cAAc,GAAGgB,GAAG,CAAC;YACrFT,OAAO,EAAE,uBAAuBP,cAAc,OAAOL,CAAC,GAAG,CAAC;UAC5D,CAAC,CAAC;QACJ;MACF,CAAC,MAAM;QACL;QACA,IAAI,CAACS,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,QAAQ;UACdM,OAAO,EAAE,CAAChB,CAAC,GAAGM,CAAC,GAAG,CAAC,CAAC;UACpBM,OAAO,EAAE,oBAAoBZ,CAAC,GAAGM,CAAC,GAAG,CAAC;QACxC,CAAC,CAAC;MACJ;;MAEA;MACA,IAAI,CAACG,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,UAAU;QAChBC,IAAI,EAAEL,CAAC,GAAG,CAAC;QACXM,OAAO,EAAE,kBAAkBN,CAAC,GAAG,CAAC;MAClC,CAAC,CAAC;IACJ;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEH,kBAAkBA,CAACL,KAAK,EAAEL,OAAO,EAAE;IACjC,MAAMO,CAAC,GAAGF,KAAK,CAACG,MAAM;;IAEtB;IACA,IAAIqB,KAAK,GAAG,CAAC;IACb,IAAIC,GAAG,GAAGvB,CAAC,GAAG,CAAC;;IAEf;IACA,IAAIO,OAAO,GAAG,IAAI;;IAElB;IACA,IAAII,IAAI,GAAG,CAAC;IAEZ,OAAOJ,OAAO,IAAIe,KAAK,GAAGC,GAAG,EAAE;MAC7BhB,OAAO,GAAG,KAAK;MACfI,IAAI,EAAE;;MAEN;MACA,IAAI,CAACF,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,YAAY;QAClBc,SAAS,EAAE,SAAS;QACpBb,IAAI;QACJC,OAAO,EAAE,yBAAyBD,IAAI;MACxC,CAAC,CAAC;;MAEF;MACA,KAAK,IAAIL,CAAC,GAAGgB,KAAK,EAAEhB,CAAC,GAAGiB,GAAG,EAAEjB,CAAC,EAAE,EAAE;QAChC;QACA,MAAMQ,gBAAgB,GAAG,IAAI,CAACC,OAAO,CAACjB,KAAK,CAACQ,CAAC,CAAC,EAAER,KAAK,CAACQ,CAAC,GAAG,CAAC,CAAC,CAAC;;QAE7D;QACA,IAAI,CAACG,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,YAAY;UAClBM,OAAO,EAAE,CAACV,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;UACnBP,MAAM,EAAEe,gBAAgB;UACxBF,OAAO,EAAE,iCAAiCN,CAAC,QAAQA,CAAC,GAAG,CAAC;QAC1D,CAAC,CAAC;;QAEF;QACA,IAAIQ,gBAAgB,GAAG,CAAC,EAAE;UACxB,IAAI,CAACG,IAAI,CAACnB,KAAK,EAAEQ,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;UAC1BC,OAAO,GAAG,IAAI;;UAEd;UACA,IAAI,CAACE,WAAW,CAACX,KAAK,EAAE;YACtBY,IAAI,EAAE,MAAM;YACZM,OAAO,EAAE,CAACV,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;YACnBM,OAAO,EAAE,+BAA+BN,CAAC,QAAQA,CAAC,GAAG,CAAC;UACxD,CAAC,CAAC;QACJ;MACF;;MAEA;MACA,IAAI,CAACG,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,QAAQ;QACdM,OAAO,EAAE,CAACO,GAAG,CAAC;QACdX,OAAO,EAAE,oBAAoBW,GAAG;MAClC,CAAC,CAAC;;MAEF;MACA,IAAI,CAACd,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,UAAU;QAChBc,SAAS,EAAE,SAAS;QACpBb,IAAI;QACJC,OAAO,EAAE,0BAA0BD,IAAI;MACzC,CAAC,CAAC;;MAEF;MACAY,GAAG,EAAE;;MAEL;MACA,IAAI9B,OAAO,CAACC,QAAQ,IAAI,CAACa,OAAO,EAAE;QAChC,IAAI,CAACE,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,cAAc;UACpBE,OAAO,EAAE,+CAA+CD,IAAI;QAC9D,CAAC,CAAC;QACF;MACF;MAEAJ,OAAO,GAAG,KAAK;;MAEf;MACA,IAAI,CAACE,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,YAAY;QAClBc,SAAS,EAAE,UAAU;QACrBb,IAAI;QACJC,OAAO,EAAE,0BAA0BD,IAAI;MACzC,CAAC,CAAC;;MAEF;MACA,KAAK,IAAIL,CAAC,GAAGiB,GAAG,EAAEjB,CAAC,GAAGgB,KAAK,EAAEhB,CAAC,EAAE,EAAE;QAChC;QACA,MAAMQ,gBAAgB,GAAG,IAAI,CAACC,OAAO,CAACjB,KAAK,CAACQ,CAAC,GAAG,CAAC,CAAC,EAAER,KAAK,CAACQ,CAAC,CAAC,CAAC;;QAE7D;QACA,IAAI,CAACG,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,YAAY;UAClBM,OAAO,EAAE,CAACV,CAAC,GAAG,CAAC,EAAEA,CAAC,CAAC;UACnBP,MAAM,EAAEe,gBAAgB;UACxBF,OAAO,EAAE,iCAAiCN,CAAC,GAAG,CAAC,QAAQA,CAAC;QAC1D,CAAC,CAAC;;QAEF;QACA,IAAIQ,gBAAgB,GAAG,CAAC,EAAE;UACxB,IAAI,CAACG,IAAI,CAACnB,KAAK,EAAEQ,CAAC,GAAG,CAAC,EAAEA,CAAC,CAAC;UAC1BC,OAAO,GAAG,IAAI;;UAEd;UACA,IAAI,CAACE,WAAW,CAACX,KAAK,EAAE;YACtBY,IAAI,EAAE,MAAM;YACZM,OAAO,EAAE,CAACV,CAAC,GAAG,CAAC,EAAEA,CAAC,CAAC;YACnBM,OAAO,EAAE,+BAA+BN,CAAC,GAAG,CAAC,QAAQA,CAAC;UACxD,CAAC,CAAC;QACJ;MACF;;MAEA;MACA,IAAI,CAACG,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,QAAQ;QACdM,OAAO,EAAE,CAACM,KAAK,CAAC;QAChBV,OAAO,EAAE,oBAAoBU,KAAK;MACpC,CAAC,CAAC;;MAEF;MACA,IAAI,CAACb,WAAW,CAACX,KAAK,EAAE;QACtBY,IAAI,EAAE,UAAU;QAChBc,SAAS,EAAE,UAAU;QACrBb,IAAI;QACJC,OAAO,EAAE,2BAA2BD,IAAI;MAC1C,CAAC,CAAC;;MAEF;MACAW,KAAK,EAAE;;MAEP;MACA,IAAI7B,OAAO,CAACC,QAAQ,IAAI,CAACa,OAAO,EAAE;QAChC,IAAI,CAACE,WAAW,CAACX,KAAK,EAAE;UACtBY,IAAI,EAAE,cAAc;UACpBE,OAAO,EAAE,gDAAgDD,IAAI;QAC/D,CAAC,CAAC;QACF;MACF;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEc,aAAaA,CAAA,EAAG;IACd,OAAO;MACLC,IAAI,EAAE;QACJC,IAAI,EAAE,IAAI,CAAClC,OAAO,CAACC,QAAQ,GAAG,MAAM,GAAG,OAAO;QAC9CkC,OAAO,EAAE,OAAO;QAChBC,KAAK,EAAE;MACT,CAAC;MACDC,KAAK,EAAE;QACLH,IAAI,EAAE,MAAM;QACZC,OAAO,EAAE,MAAM;QACfC,KAAK,EAAE;MACT;IACF,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;EACEE,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACEC,SAASA,CAAA,EAAG;IACV,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACEC,OAAOA,CAAA,EAAG;IACR,MAAMC,IAAI,GAAG,KAAK,CAACD,OAAO,CAAC,CAAC;;IAE5B;IACAC,IAAI,CAACC,YAAY,GAAG;MAClBC,gBAAgB,EAAE,IAAI,CAAC3C,OAAO,CAACC,QAAQ;MACvC2C,gBAAgB,EAAE,IAAI,CAAC5C,OAAO,CAACE,QAAQ;MACvCC,aAAa,EAAE,IAAI,CAACH,OAAO,CAACG;IAC9B,CAAC;IAEDsC,IAAI,CAACI,UAAU,GAAG;MAChBC,eAAe,EAAE,IAAI;MACrBC,MAAM,EAAE,IAAI;MACZC,OAAO,EAAE,IAAI;MACbC,MAAM,EAAE,IAAI;MACZ/C,QAAQ,EAAE,IAAI,CAACF,OAAO,CAACC,QAAQ,IAAI,IAAI,CAACD,OAAO,CAACE;IAClD,CAAC;IAEDuC,IAAI,CAACS,QAAQ,GAAG;MACdC,WAAW,EAAE,IAAI;MACjBC,kBAAkB,EAAE,IAAI,CAACpD,OAAO,CAACC,QAAQ;MACzCoD,WAAW,EAAE,KAAK;MAClBC,mBAAmB,EAAE;IACvB,CAAC;IAEDb,IAAI,CAACc,QAAQ,GAAG,CACd,sBAAsB,EACtB,2CAA2C,EAC3C,yCAAyC,EACzC,sCAAsC,EACtC,kCAAkC,CACnC;IAEDd,IAAI,CAACe,UAAU,GAAG,CAChB,mCAAmC,EACnC,iCAAiC,EACjC,oDAAoD,EACpD,sEAAsE,EACtE,gDAAgD,CACjD;IAEDf,IAAI,CAACgB,aAAa,GAAG,CACnB,oEAAoE,EACpE,yDAAyD,EACzD,2DAA2D,EAC3D,oDAAoD,CACrD;IAEDhB,IAAI,CAACiB,WAAW,GAAG;MACjBC,QAAQ,EAAE,gDAAgD;MAC1DC,SAAS,EAAE,gCAAgC;MAC3CC,WAAW,EAAE;IACf,CAAC;IAED,OAAOpB,IAAI;EACb;AACF;AAEA,eAAe3C,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module"}