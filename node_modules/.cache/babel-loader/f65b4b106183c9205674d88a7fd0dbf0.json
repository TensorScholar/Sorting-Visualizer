{"ast":null,"code":"/**\n * Data Generation Utilities Module\n * \n * This module provides comprehensive data generation capabilities for algorithm visualization,\n * supporting various distribution patterns, statistical properties, and specialized test cases\n * that highlight specific algorithm behaviors and performance characteristics.\n * \n * The utilities follow a unified interface pattern for consistent integration with\n * visualization components, instrumentation systems, and comparative analysis tools.\n */\n\n/**\n * Generate a data set based on specified type and parameters\n * \n * @param {string} type - Type of data set to generate\n * @param {number} size - Size of data set\n * @param {Object} options - Additional options for generation\n * @returns {Array<number>} - The generated data set\n */\nexport function generateDataSet(type, size, options = {}) {\n  // Apply defaults\n  const opts = {\n    min: 1,\n    max: 100,\n    uniqueValues: 10,\n    sortedRatio: 0.9,\n    reversedRatio: 0.9,\n    ...options\n  };\n\n  // Select appropriate generator\n  switch (type) {\n    case 'random':\n      return generateRandomData(size, opts.min, opts.max);\n    case 'nearly-sorted':\n      return generateNearlySortedData(size, opts.min, opts.max, opts.sortedRatio);\n    case 'reversed':\n      return generateReversedData(size, opts.min, opts.max, opts.reversedRatio);\n    case 'few-unique':\n      return generateFewUniqueData(size, opts.min, opts.max, opts.uniqueValues);\n    case 'sorted':\n      return generateSortedData(size, opts.min, opts.max);\n    case 'sawtooth':\n      return generateSawtoothData(size, opts.min, opts.max);\n    case 'plateau':\n      return generatePlateauData(size, opts.min, opts.max);\n    default:\n      console.warn(`Unknown data set type: ${type}, using random instead`);\n      return generateRandomData(size, opts.min, opts.max);\n  }\n}\n\n/**\n * Generate a random array of numbers\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @returns {Array<number>} - Random array\n */\nexport function generateRandomData(size, min = 1, max = 100) {\n  return Array.from({\n    length: size\n  }, () => Math.floor(Math.random() * (max - min + 1)) + min);\n}\n\n/**\n * Generate a sorted array of numbers\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @returns {Array<number>} - Sorted array\n */\nexport function generateSortedData(size, min = 1, max = 100) {\n  const step = (max - min) / (size - 1 || 1);\n  return Array.from({\n    length: size\n  }, (_, i) => Math.floor(min + i * step));\n}\n\n/**\n * Generate a reversed array of numbers\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @param {number} ratio - How reversed the array should be (0-1)\n * @returns {Array<number>} - Reversed array\n */\nexport function generateReversedData(size, min = 1, max = 100, ratio = 0.9) {\n  const step = (max - min) / (size - 1 || 1);\n  const sorted = Array.from({\n    length: size\n  }, (_, i) => Math.floor(min + i * step));\n\n  // Completely reversed\n  if (ratio >= 1) {\n    return sorted.reverse();\n  }\n\n  // Partially reversed\n  const reversed = sorted.reverse();\n  const result = [...reversed];\n\n  // Shuffle some elements to make it less perfectly reversed\n  const shuffleCount = Math.floor(size * (1 - ratio));\n  for (let i = 0; i < shuffleCount; i++) {\n    const idx1 = Math.floor(Math.random() * size);\n    const idx2 = Math.floor(Math.random() * size);\n    [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n  }\n  return result;\n}\n\n/**\n * Generate a nearly sorted array of numbers\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @param {number} ratio - How sorted the array should be (0-1)\n * @returns {Array<number>} - Nearly sorted array\n */\nexport function generateNearlySortedData(size, min = 1, max = 100, ratio = 0.9) {\n  // Generate sorted array\n  const step = (max - min) / (size - 1 || 1);\n  const result = Array.from({\n    length: size\n  }, (_, i) => Math.floor(min + i * step));\n\n  // Determine how many elements to shuffle\n  const shuffleCount = Math.floor(size * (1 - ratio));\n\n  // Shuffle random pairs of elements\n  for (let i = 0; i < shuffleCount; i++) {\n    const idx1 = Math.floor(Math.random() * size);\n    // Keep swaps relatively local for more realistic nearly-sorted data\n    const maxDistance = Math.max(5, Math.floor(size * 0.1));\n    const offset = Math.floor(Math.random() * maxDistance) - Math.floor(maxDistance / 2);\n    const idx2 = Math.max(0, Math.min(size - 1, idx1 + offset));\n    [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n  }\n  return result;\n}\n\n/**\n * Generate an array with few unique values\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @param {number} uniqueCount - Number of unique values\n * @returns {Array<number>} - Array with few unique values\n */\nexport function generateFewUniqueData(size, min = 1, max = 100, uniqueCount = 10) {\n  // Ensure uniqueCount isn't larger than the possible range\n  uniqueCount = Math.min(uniqueCount, max - min + 1);\n\n  // Generate the unique values\n  const uniqueValues = [];\n  for (let i = 0; i < uniqueCount; i++) {\n    const value = Math.floor(min + i * (max - min) / (uniqueCount - 1 || 1));\n    uniqueValues.push(value);\n  }\n\n  // Create array by randomly selecting from unique values\n  return Array.from({\n    length: size\n  }, () => uniqueValues[Math.floor(Math.random() * uniqueCount)]);\n}\n\n/**\n * Generate a sawtooth pattern array\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @returns {Array<number>} - Sawtooth pattern array\n */\nexport function generateSawtoothData(size, min = 1, max = 100) {\n  // Determine pattern frequency - how many teeth in the saw\n  const teethCount = Math.max(2, Math.floor(size / 20));\n  const teethSize = Math.floor(size / teethCount);\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    // Determine which tooth this element belongs to\n    const toothIdx = Math.floor(i / teethSize);\n    // Position within the current tooth\n    const posInTooth = i % teethSize;\n    // Value increases within each tooth, then drops for the next tooth\n    const progress = posInTooth / teethSize;\n    const value = min + Math.floor(progress * (max - min));\n    result.push(value);\n  }\n  return result;\n}\n\n/**\n * Generate a plateau pattern array (sections of same values)\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @returns {Array<number>} - Plateau pattern array\n */\nexport function generatePlateauData(size, min = 1, max = 100) {\n  // Determine number of plateaus\n  const plateauCount = Math.max(2, Math.floor(Math.sqrt(size)));\n  const plateauSize = Math.floor(size / plateauCount);\n  const result = [];\n\n  // Generate plateau values in ascending order\n  const plateauValues = [];\n  for (let i = 0; i < plateauCount; i++) {\n    plateauValues.push(min + Math.floor(i / (plateauCount - 1) * (max - min)));\n  }\n\n  // Build the array\n  for (let i = 0; i < size; i++) {\n    const plateauIdx = Math.min(plateauCount - 1, Math.floor(i / plateauSize));\n    result.push(plateauValues[plateauIdx]);\n  }\n  return result;\n}\n\n// Default export for flexible importing\nconst generators = {\n  generateDataSet,\n  generateRandomData,\n  generateSortedData,\n  generateReversedData,\n  generateNearlySortedData,\n  generateFewUniqueData,\n  generateSawtoothData,\n  generatePlateauData\n};\nexport default generators;","map":{"version":3,"names":["generateDataSet","type","size","options","opts","min","max","uniqueValues","sortedRatio","reversedRatio","generateRandomData","generateNearlySortedData","generateReversedData","generateFewUniqueData","generateSortedData","generateSawtoothData","generatePlateauData","console","warn","Array","from","length","Math","floor","random","step","_","i","ratio","sorted","reverse","reversed","result","shuffleCount","idx1","idx2","maxDistance","offset","uniqueCount","value","push","teethCount","teethSize","toothIdx","posInTooth","progress","plateauCount","sqrt","plateauSize","plateauValues","plateauIdx","generators"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/data/generators.js"],"sourcesContent":["/**\n * Data Generation Utilities Module\n * \n * This module provides comprehensive data generation capabilities for algorithm visualization,\n * supporting various distribution patterns, statistical properties, and specialized test cases\n * that highlight specific algorithm behaviors and performance characteristics.\n * \n * The utilities follow a unified interface pattern for consistent integration with\n * visualization components, instrumentation systems, and comparative analysis tools.\n */\n\n/**\n * Generate a data set based on specified type and parameters\n * \n * @param {string} type - Type of data set to generate\n * @param {number} size - Size of data set\n * @param {Object} options - Additional options for generation\n * @returns {Array<number>} - The generated data set\n */\nexport function generateDataSet(type, size, options = {}) {\n  // Apply defaults\n  const opts = {\n    min: 1,\n    max: 100,\n    uniqueValues: 10,\n    sortedRatio: 0.9,\n    reversedRatio: 0.9,\n    ...options\n  };\n  \n  // Select appropriate generator\n  switch (type) {\n    case 'random':\n      return generateRandomData(size, opts.min, opts.max);\n    case 'nearly-sorted':\n      return generateNearlySortedData(size, opts.min, opts.max, opts.sortedRatio);\n    case 'reversed':\n      return generateReversedData(size, opts.min, opts.max, opts.reversedRatio);\n    case 'few-unique':\n      return generateFewUniqueData(size, opts.min, opts.max, opts.uniqueValues);\n    case 'sorted':\n      return generateSortedData(size, opts.min, opts.max);\n    case 'sawtooth':\n      return generateSawtoothData(size, opts.min, opts.max);\n    case 'plateau':\n      return generatePlateauData(size, opts.min, opts.max);\n    default:\n      console.warn(`Unknown data set type: ${type}, using random instead`);\n      return generateRandomData(size, opts.min, opts.max);\n  }\n}\n\n/**\n * Generate a random array of numbers\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @returns {Array<number>} - Random array\n */\nexport function generateRandomData(size, min = 1, max = 100) {\n  return Array.from({ length: size }, () => \n    Math.floor(Math.random() * (max - min + 1)) + min\n  );\n}\n\n/**\n * Generate a sorted array of numbers\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @returns {Array<number>} - Sorted array\n */\nexport function generateSortedData(size, min = 1, max = 100) {\n  const step = (max - min) / (size - 1 || 1);\n  return Array.from({ length: size }, (_, i) => \n    Math.floor(min + i * step)\n  );\n}\n\n/**\n * Generate a reversed array of numbers\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @param {number} ratio - How reversed the array should be (0-1)\n * @returns {Array<number>} - Reversed array\n */\nexport function generateReversedData(size, min = 1, max = 100, ratio = 0.9) {\n  const step = (max - min) / (size - 1 || 1);\n  const sorted = Array.from({ length: size }, (_, i) => \n    Math.floor(min + i * step)\n  );\n  \n  // Completely reversed\n  if (ratio >= 1) {\n    return sorted.reverse();\n  }\n  \n  // Partially reversed\n  const reversed = sorted.reverse();\n  const result = [...reversed];\n  \n  // Shuffle some elements to make it less perfectly reversed\n  const shuffleCount = Math.floor(size * (1 - ratio));\n  for (let i = 0; i < shuffleCount; i++) {\n    const idx1 = Math.floor(Math.random() * size);\n    const idx2 = Math.floor(Math.random() * size);\n    [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n  }\n  \n  return result;\n}\n\n/**\n * Generate a nearly sorted array of numbers\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @param {number} ratio - How sorted the array should be (0-1)\n * @returns {Array<number>} - Nearly sorted array\n */\nexport function generateNearlySortedData(size, min = 1, max = 100, ratio = 0.9) {\n  // Generate sorted array\n  const step = (max - min) / (size - 1 || 1);\n  const result = Array.from({ length: size }, (_, i) => \n    Math.floor(min + i * step)\n  );\n  \n  // Determine how many elements to shuffle\n  const shuffleCount = Math.floor(size * (1 - ratio));\n  \n  // Shuffle random pairs of elements\n  for (let i = 0; i < shuffleCount; i++) {\n    const idx1 = Math.floor(Math.random() * size);\n    // Keep swaps relatively local for more realistic nearly-sorted data\n    const maxDistance = Math.max(5, Math.floor(size * 0.1));\n    const offset = Math.floor(Math.random() * maxDistance) - Math.floor(maxDistance / 2);\n    const idx2 = Math.max(0, Math.min(size - 1, idx1 + offset));\n    \n    [result[idx1], result[idx2]] = [result[idx2], result[idx1]];\n  }\n  \n  return result;\n}\n\n/**\n * Generate an array with few unique values\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @param {number} uniqueCount - Number of unique values\n * @returns {Array<number>} - Array with few unique values\n */\nexport function generateFewUniqueData(size, min = 1, max = 100, uniqueCount = 10) {\n  // Ensure uniqueCount isn't larger than the possible range\n  uniqueCount = Math.min(uniqueCount, max - min + 1);\n  \n  // Generate the unique values\n  const uniqueValues = [];\n  for (let i = 0; i < uniqueCount; i++) {\n    const value = Math.floor(min + (i * (max - min) / (uniqueCount - 1 || 1)));\n    uniqueValues.push(value);\n  }\n  \n  // Create array by randomly selecting from unique values\n  return Array.from({ length: size }, () => \n    uniqueValues[Math.floor(Math.random() * uniqueCount)]\n  );\n}\n\n/**\n * Generate a sawtooth pattern array\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @returns {Array<number>} - Sawtooth pattern array\n */\nexport function generateSawtoothData(size, min = 1, max = 100) {\n  // Determine pattern frequency - how many teeth in the saw\n  const teethCount = Math.max(2, Math.floor(size / 20));\n  const teethSize = Math.floor(size / teethCount);\n  \n  const result = [];\n  \n  for (let i = 0; i < size; i++) {\n    // Determine which tooth this element belongs to\n    const toothIdx = Math.floor(i / teethSize);\n    // Position within the current tooth\n    const posInTooth = i % teethSize;\n    // Value increases within each tooth, then drops for the next tooth\n    const progress = posInTooth / teethSize;\n    const value = min + Math.floor(progress * (max - min));\n    \n    result.push(value);\n  }\n  \n  return result;\n}\n\n/**\n * Generate a plateau pattern array (sections of same values)\n * \n * @param {number} size - Size of array\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @returns {Array<number>} - Plateau pattern array\n */\nexport function generatePlateauData(size, min = 1, max = 100) {\n  // Determine number of plateaus\n  const plateauCount = Math.max(2, Math.floor(Math.sqrt(size)));\n  const plateauSize = Math.floor(size / plateauCount);\n  const result = [];\n  \n  // Generate plateau values in ascending order\n  const plateauValues = [];\n  for (let i = 0; i < plateauCount; i++) {\n    plateauValues.push(min + Math.floor((i / (plateauCount - 1)) * (max - min)));\n  }\n  \n  // Build the array\n  for (let i = 0; i < size; i++) {\n    const plateauIdx = Math.min(plateauCount - 1, Math.floor(i / plateauSize));\n    result.push(plateauValues[plateauIdx]);\n  }\n  \n  return result;\n}\n\n// Default export for flexible importing\nconst generators = {\n  generateDataSet,\n  generateRandomData,\n  generateSortedData,\n  generateReversedData,\n  generateNearlySortedData,\n  generateFewUniqueData,\n  generateSawtoothData,\n  generatePlateauData\n};\n\nexport default generators;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,eAAeA,CAACC,IAAI,EAAEC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACxD;EACA,MAAMC,IAAI,GAAG;IACXC,GAAG,EAAE,CAAC;IACNC,GAAG,EAAE,GAAG;IACRC,YAAY,EAAE,EAAE;IAChBC,WAAW,EAAE,GAAG;IAChBC,aAAa,EAAE,GAAG;IAClB,GAAGN;EACL,CAAC;;EAED;EACA,QAAQF,IAAI;IACV,KAAK,QAAQ;MACX,OAAOS,kBAAkB,CAACR,IAAI,EAAEE,IAAI,CAACC,GAAG,EAAED,IAAI,CAACE,GAAG,CAAC;IACrD,KAAK,eAAe;MAClB,OAAOK,wBAAwB,CAACT,IAAI,EAAEE,IAAI,CAACC,GAAG,EAAED,IAAI,CAACE,GAAG,EAAEF,IAAI,CAACI,WAAW,CAAC;IAC7E,KAAK,UAAU;MACb,OAAOI,oBAAoB,CAACV,IAAI,EAAEE,IAAI,CAACC,GAAG,EAAED,IAAI,CAACE,GAAG,EAAEF,IAAI,CAACK,aAAa,CAAC;IAC3E,KAAK,YAAY;MACf,OAAOI,qBAAqB,CAACX,IAAI,EAAEE,IAAI,CAACC,GAAG,EAAED,IAAI,CAACE,GAAG,EAAEF,IAAI,CAACG,YAAY,CAAC;IAC3E,KAAK,QAAQ;MACX,OAAOO,kBAAkB,CAACZ,IAAI,EAAEE,IAAI,CAACC,GAAG,EAAED,IAAI,CAACE,GAAG,CAAC;IACrD,KAAK,UAAU;MACb,OAAOS,oBAAoB,CAACb,IAAI,EAAEE,IAAI,CAACC,GAAG,EAAED,IAAI,CAACE,GAAG,CAAC;IACvD,KAAK,SAAS;MACZ,OAAOU,mBAAmB,CAACd,IAAI,EAAEE,IAAI,CAACC,GAAG,EAAED,IAAI,CAACE,GAAG,CAAC;IACtD;MACEW,OAAO,CAACC,IAAI,CAAC,0BAA0BjB,IAAI,wBAAwB,CAAC;MACpE,OAAOS,kBAAkB,CAACR,IAAI,EAAEE,IAAI,CAACC,GAAG,EAAED,IAAI,CAACE,GAAG,CAAC;EACvD;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,kBAAkBA,CAACR,IAAI,EAAEG,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAE;EAC3D,OAAOa,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEnB;EAAK,CAAC,EAAE,MAClCoB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIlB,GAAG,GAAGD,GAAG,GAAG,CAAC,CAAC,CAAC,GAAGA,GAChD,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASS,kBAAkBA,CAACZ,IAAI,EAAEG,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAE;EAC3D,MAAMmB,IAAI,GAAG,CAACnB,GAAG,GAAGD,GAAG,KAAKH,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;EAC1C,OAAOiB,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEnB;EAAK,CAAC,EAAE,CAACwB,CAAC,EAAEC,CAAC,KACvCL,IAAI,CAACC,KAAK,CAAClB,GAAG,GAAGsB,CAAC,GAAGF,IAAI,CAC3B,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASb,oBAAoBA,CAACV,IAAI,EAAEG,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEsB,KAAK,GAAG,GAAG,EAAE;EAC1E,MAAMH,IAAI,GAAG,CAACnB,GAAG,GAAGD,GAAG,KAAKH,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;EAC1C,MAAM2B,MAAM,GAAGV,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEnB;EAAK,CAAC,EAAE,CAACwB,CAAC,EAAEC,CAAC,KAC/CL,IAAI,CAACC,KAAK,CAAClB,GAAG,GAAGsB,CAAC,GAAGF,IAAI,CAC3B,CAAC;;EAED;EACA,IAAIG,KAAK,IAAI,CAAC,EAAE;IACd,OAAOC,MAAM,CAACC,OAAO,CAAC,CAAC;EACzB;;EAEA;EACA,MAAMC,QAAQ,GAAGF,MAAM,CAACC,OAAO,CAAC,CAAC;EACjC,MAAME,MAAM,GAAG,CAAC,GAAGD,QAAQ,CAAC;;EAE5B;EACA,MAAME,YAAY,GAAGX,IAAI,CAACC,KAAK,CAACrB,IAAI,IAAI,CAAC,GAAG0B,KAAK,CAAC,CAAC;EACnD,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,YAAY,EAAEN,CAAC,EAAE,EAAE;IACrC,MAAMO,IAAI,GAAGZ,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGtB,IAAI,CAAC;IAC7C,MAAMiC,IAAI,GAAGb,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGtB,IAAI,CAAC;IAC7C,CAAC8B,MAAM,CAACE,IAAI,CAAC,EAAEF,MAAM,CAACG,IAAI,CAAC,CAAC,GAAG,CAACH,MAAM,CAACG,IAAI,CAAC,EAAEH,MAAM,CAACE,IAAI,CAAC,CAAC;EAC7D;EAEA,OAAOF,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASrB,wBAAwBA,CAACT,IAAI,EAAEG,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEsB,KAAK,GAAG,GAAG,EAAE;EAC9E;EACA,MAAMH,IAAI,GAAG,CAACnB,GAAG,GAAGD,GAAG,KAAKH,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;EAC1C,MAAM8B,MAAM,GAAGb,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEnB;EAAK,CAAC,EAAE,CAACwB,CAAC,EAAEC,CAAC,KAC/CL,IAAI,CAACC,KAAK,CAAClB,GAAG,GAAGsB,CAAC,GAAGF,IAAI,CAC3B,CAAC;;EAED;EACA,MAAMQ,YAAY,GAAGX,IAAI,CAACC,KAAK,CAACrB,IAAI,IAAI,CAAC,GAAG0B,KAAK,CAAC,CAAC;;EAEnD;EACA,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,YAAY,EAAEN,CAAC,EAAE,EAAE;IACrC,MAAMO,IAAI,GAAGZ,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGtB,IAAI,CAAC;IAC7C;IACA,MAAMkC,WAAW,GAAGd,IAAI,CAAChB,GAAG,CAAC,CAAC,EAAEgB,IAAI,CAACC,KAAK,CAACrB,IAAI,GAAG,GAAG,CAAC,CAAC;IACvD,MAAMmC,MAAM,GAAGf,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGY,WAAW,CAAC,GAAGd,IAAI,CAACC,KAAK,CAACa,WAAW,GAAG,CAAC,CAAC;IACpF,MAAMD,IAAI,GAAGb,IAAI,CAAChB,GAAG,CAAC,CAAC,EAAEgB,IAAI,CAACjB,GAAG,CAACH,IAAI,GAAG,CAAC,EAAEgC,IAAI,GAAGG,MAAM,CAAC,CAAC;IAE3D,CAACL,MAAM,CAACE,IAAI,CAAC,EAAEF,MAAM,CAACG,IAAI,CAAC,CAAC,GAAG,CAACH,MAAM,CAACG,IAAI,CAAC,EAAEH,MAAM,CAACE,IAAI,CAAC,CAAC;EAC7D;EAEA,OAAOF,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASnB,qBAAqBA,CAACX,IAAI,EAAEG,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAEgC,WAAW,GAAG,EAAE,EAAE;EAChF;EACAA,WAAW,GAAGhB,IAAI,CAACjB,GAAG,CAACiC,WAAW,EAAEhC,GAAG,GAAGD,GAAG,GAAG,CAAC,CAAC;;EAElD;EACA,MAAME,YAAY,GAAG,EAAE;EACvB,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,WAAW,EAAEX,CAAC,EAAE,EAAE;IACpC,MAAMY,KAAK,GAAGjB,IAAI,CAACC,KAAK,CAAClB,GAAG,GAAIsB,CAAC,IAAIrB,GAAG,GAAGD,GAAG,CAAC,IAAIiC,WAAW,GAAG,CAAC,IAAI,CAAC,CAAE,CAAC;IAC1E/B,YAAY,CAACiC,IAAI,CAACD,KAAK,CAAC;EAC1B;;EAEA;EACA,OAAOpB,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEnB;EAAK,CAAC,EAAE,MAClCK,YAAY,CAACe,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGc,WAAW,CAAC,CACtD,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASvB,oBAAoBA,CAACb,IAAI,EAAEG,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAE;EAC7D;EACA,MAAMmC,UAAU,GAAGnB,IAAI,CAAChB,GAAG,CAAC,CAAC,EAAEgB,IAAI,CAACC,KAAK,CAACrB,IAAI,GAAG,EAAE,CAAC,CAAC;EACrD,MAAMwC,SAAS,GAAGpB,IAAI,CAACC,KAAK,CAACrB,IAAI,GAAGuC,UAAU,CAAC;EAE/C,MAAMT,MAAM,GAAG,EAAE;EAEjB,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,IAAI,EAAEyB,CAAC,EAAE,EAAE;IAC7B;IACA,MAAMgB,QAAQ,GAAGrB,IAAI,CAACC,KAAK,CAACI,CAAC,GAAGe,SAAS,CAAC;IAC1C;IACA,MAAME,UAAU,GAAGjB,CAAC,GAAGe,SAAS;IAChC;IACA,MAAMG,QAAQ,GAAGD,UAAU,GAAGF,SAAS;IACvC,MAAMH,KAAK,GAAGlC,GAAG,GAAGiB,IAAI,CAACC,KAAK,CAACsB,QAAQ,IAAIvC,GAAG,GAAGD,GAAG,CAAC,CAAC;IAEtD2B,MAAM,CAACQ,IAAI,CAACD,KAAK,CAAC;EACpB;EAEA,OAAOP,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAShB,mBAAmBA,CAACd,IAAI,EAAEG,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,GAAG,EAAE;EAC5D;EACA,MAAMwC,YAAY,GAAGxB,IAAI,CAAChB,GAAG,CAAC,CAAC,EAAEgB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACyB,IAAI,CAAC7C,IAAI,CAAC,CAAC,CAAC;EAC7D,MAAM8C,WAAW,GAAG1B,IAAI,CAACC,KAAK,CAACrB,IAAI,GAAG4C,YAAY,CAAC;EACnD,MAAMd,MAAM,GAAG,EAAE;;EAEjB;EACA,MAAMiB,aAAa,GAAG,EAAE;EACxB,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmB,YAAY,EAAEnB,CAAC,EAAE,EAAE;IACrCsB,aAAa,CAACT,IAAI,CAACnC,GAAG,GAAGiB,IAAI,CAACC,KAAK,CAAEI,CAAC,IAAImB,YAAY,GAAG,CAAC,CAAC,IAAKxC,GAAG,GAAGD,GAAG,CAAC,CAAC,CAAC;EAC9E;;EAEA;EACA,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,IAAI,EAAEyB,CAAC,EAAE,EAAE;IAC7B,MAAMuB,UAAU,GAAG5B,IAAI,CAACjB,GAAG,CAACyC,YAAY,GAAG,CAAC,EAAExB,IAAI,CAACC,KAAK,CAACI,CAAC,GAAGqB,WAAW,CAAC,CAAC;IAC1EhB,MAAM,CAACQ,IAAI,CAACS,aAAa,CAACC,UAAU,CAAC,CAAC;EACxC;EAEA,OAAOlB,MAAM;AACf;;AAEA;AACA,MAAMmB,UAAU,GAAG;EACjBnD,eAAe;EACfU,kBAAkB;EAClBI,kBAAkB;EAClBF,oBAAoB;EACpBD,wBAAwB;EACxBE,qBAAqB;EACrBE,oBAAoB;EACpBC;AACF,CAAC;AAED,eAAemC,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module"}