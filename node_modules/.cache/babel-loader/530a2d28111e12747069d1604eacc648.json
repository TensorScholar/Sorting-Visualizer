{"ast":null,"code":"// src/algorithms/comparison/insertion.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Insertion Sort with multiple optimization variants.\n * \n * Insertion Sort builds the final sorted array one item at a time by repeatedly\n * taking the next unsorted element and inserting it into its correct position\n * within the already-sorted portion of the array.\n *\n * This implementation includes optimizations:\n * - Binary search for finding insertion position (reduces comparisons)\n * - Early termination when no shifts occur in a pass\n * - Gap insertion for improved performance on certain datasets\n * \n * Time Complexity:\n * - Best:    O(n) when array is already sorted\n * - Average: O(n²)\n * - Worst:   O(n²) when array is in reverse order\n * \n * Space Complexity: O(1) - truly in-place\n *\n * @class InsertionSort\n * @extends Algorithm\n */\nclass InsertionSort extends Algorithm {\n  /**\n   * Create a new InsertionSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.useBinarySearch=false] - Use binary search to find insertion position\n   * @param {boolean} [options.earlyTermination=true] - Stop when no shifts occur\n   * @param {number} [options.gapSize=1] - Gap between compared elements (1 for classic)\n   */\n  constructor(options = {}) {\n    super('Insertion Sort', 'comparison', options);\n\n    // Default options\n    this.options = {\n      useBinarySearch: false,\n      // Use binary search to find insertion position\n      earlyTermination: true,\n      // Stop when no shifts occur in a pass\n      gapSize: 1,\n      // Gap between compared elements (1 for classic)\n      ...options\n    };\n  }\n\n  /**\n   * Execute Insertion Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('sorting');\n\n    // Select appropriate insertion sort variant\n    if (options.useBinarySearch) {\n      this.binaryInsertionSort(result, options);\n    } else if (options.gapSize > 1) {\n      this.gapInsertionSort(result, options);\n    } else {\n      this.classicInsertionSort(result, options);\n    }\n    this.setPhase('completed');\n    return result;\n  }\n\n  /**\n   * Classic implementation of Insertion Sort\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {Object} options - Runtime options\n   */\n  classicInsertionSort(array, options) {\n    const n = array.length;\n    let shifts = 0;\n    for (let i = 1; i < n; i++) {\n      // Record the current position being processed\n      this.recordState(array, {\n        type: 'insertion-start',\n        index: i,\n        message: `Starting insertion for element at index ${i}`\n      });\n\n      // Current element to be inserted into sorted portion\n      const key = this.read(array, i);\n      let j = i - 1;\n\n      // Find position for key in the sorted portion\n      let positionFound = false;\n      while (j >= 0 && this.compare(this.read(array, j), key) > 0) {\n        // Shift elements to make room for key\n        this.write(array, j + 1, this.read(array, j));\n        j--;\n        shifts++;\n\n        // Record significant shifting steps\n        if (j % 5 === 0 || j === 0) {\n          this.recordState(array, {\n            type: 'shift-operation',\n            movedFrom: j + 1,\n            movedTo: j + 2,\n            message: `Shifted element right to make room for ${key}`\n          });\n        }\n      }\n\n      // Insert the key at its correct position\n      if (j + 1 !== i) {\n        this.write(array, j + 1, key);\n\n        // Record the insertion\n        this.recordState(array, {\n          type: 'insertion-complete',\n          index: j + 1,\n          element: key,\n          message: `Inserted element ${key} at position ${j + 1}`\n        });\n      } else {\n        // Element already in correct position\n        this.recordState(array, {\n          type: 'no-movement',\n          index: i,\n          message: `Element ${key} already in correct position`\n        });\n      }\n\n      // Mark sorted region\n      this.recordState(array, {\n        type: 'sorted-region',\n        endIndex: i,\n        message: `Array is now sorted up to index ${i}`\n      });\n    }\n\n    // Check if early termination could be applied (for educational purposes)\n    if (options.earlyTermination && shifts === 0) {\n      this.recordState(array, {\n        type: 'early-termination',\n        message: 'Array was already sorted, could have terminated early'\n      });\n    }\n  }\n\n  /**\n   * Binary Insertion Sort - uses binary search to find insertion position\n   * Reduces number of comparisons but not assignments\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {Object} options - Runtime options\n   */\n  binaryInsertionSort(array, options) {\n    const n = array.length;\n    let shifts = 0;\n    for (let i = 1; i < n; i++) {\n      // Record the current position being processed\n      this.recordState(array, {\n        type: 'insertion-start',\n        index: i,\n        message: `Starting binary insertion for element at index ${i}`\n      });\n\n      // Current element to be inserted\n      const key = this.read(array, i);\n\n      // Use binary search to find insertion position\n      const insertionPos = this.findInsertionPosition(array, key, 0, i - 1);\n\n      // Record binary search result\n      this.recordState(array, {\n        type: 'binary-search',\n        element: key,\n        position: insertionPos,\n        message: `Binary search found insertion position ${insertionPos} for element ${key}`\n      });\n\n      // If the element is already in correct position, skip shifting\n      if (insertionPos === i) {\n        this.recordState(array, {\n          type: 'no-movement',\n          index: i,\n          message: `Element ${key} already in correct position`\n        });\n        continue;\n      }\n\n      // Shift all elements to the right\n      for (let j = i - 1; j >= insertionPos; j--) {\n        this.write(array, j + 1, this.read(array, j));\n        shifts++;\n\n        // Record significant shifting steps\n        if ((j - insertionPos) % 5 === 0 || j === insertionPos) {\n          this.recordState(array, {\n            type: 'shift-operation',\n            movedFrom: j,\n            movedTo: j + 1,\n            message: `Shifted element right to make room for ${key}`\n          });\n        }\n      }\n\n      // Insert the element\n      this.write(array, insertionPos, key);\n\n      // Record the insertion\n      this.recordState(array, {\n        type: 'insertion-complete',\n        index: insertionPos,\n        element: key,\n        message: `Inserted element ${key} at position ${insertionPos}`\n      });\n\n      // Mark sorted region\n      this.recordState(array, {\n        type: 'sorted-region',\n        endIndex: i,\n        message: `Array is now sorted up to index ${i}`\n      });\n    }\n  }\n\n  /**\n   * Gap Insertion Sort - generalization that allows sorting with a gap\n   * Setting gap > 1 implements a single pass of Shell Sort\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {Object} options - Runtime options\n   */\n  gapInsertionSort(array, options) {\n    const n = array.length;\n    const gap = options.gapSize;\n    this.recordState(array, {\n      type: 'gap-insertion',\n      gap: gap,\n      message: `Performing insertion sort with gap size ${gap}`\n    });\n\n    // Sort each subarray defined by the gap\n    for (let start = 0; start < gap; start++) {\n      // Record subarray start\n      this.recordState(array, {\n        type: 'gap-subarray',\n        start: start,\n        gap: gap,\n        message: `Sorting subarray starting at index ${start} with gap ${gap}`\n      });\n\n      // Insertion sort on the subarray\n      for (let i = start + gap; i < n; i += gap) {\n        const key = this.read(array, i);\n        let j = i - gap;\n        while (j >= 0 && this.compare(this.read(array, j), key) > 0) {\n          this.write(array, j + gap, this.read(array, j));\n          j -= gap;\n\n          // Record shift operation\n          this.recordState(array, {\n            type: 'gap-shift',\n            from: j + gap,\n            to: j + 2 * gap,\n            gap: gap,\n            message: `Shifted element at index ${j + gap} with gap ${gap}`\n          });\n        }\n        this.write(array, j + gap, key);\n\n        // Record insertion with gap\n        this.recordState(array, {\n          type: 'gap-insertion-complete',\n          index: j + gap,\n          element: key,\n          gap: gap,\n          message: `Inserted element ${key} at position ${j + gap} with gap ${gap}`\n        });\n      }\n    }\n\n    // Final state after all subarrays sorted\n    this.recordState(array, {\n      type: 'gap-complete',\n      gap: gap,\n      message: `Completed insertion sort with gap size ${gap}`\n    });\n  }\n\n  /**\n   * Binary search to find insertion position\n   * Optimization to reduce the number of comparisons\n   * \n   * @param {Array} array - The array to search in\n   * @param {*} key - The element to insert\n   * @param {number} low - Start index of sorted portion\n   * @param {number} high - End index of sorted portion\n   * @returns {number} - Index where key should be inserted\n   */\n  findInsertionPosition(array, key, low, high) {\n    // Record binary search start\n    this.recordState(array, {\n      type: 'binary-search-start',\n      element: key,\n      low: low,\n      high: high,\n      message: `Starting binary search for position of ${key} between indices ${low} and ${high}`\n    });\n\n    // Base case: narrowed down to a single position\n    if (high <= low) {\n      return this.compare(key, this.read(array, low)) >= 0 ? low + 1 : low;\n    }\n\n    // Find the middle point\n    const mid = Math.floor((low + high) / 2);\n\n    // Record comparison at middle\n    this.recordState(array, {\n      type: 'binary-comparison',\n      element: key,\n      compareIndex: mid,\n      compareValue: array[mid],\n      message: `Comparing ${key} with element at index ${mid} (${array[mid]})`\n    });\n\n    // Recursive search in appropriate half\n    if (this.compare(key, this.read(array, mid)) < 0) {\n      return this.findInsertionPosition(array, key, low, mid - 1);\n    } else {\n      return this.findInsertionPosition(array, key, mid + 1, high);\n    }\n  }\n\n  /**\n   * Get the time and space complexity of Insertion Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    const useBinarySearch = this.options.useBinarySearch;\n    return {\n      time: {\n        best: 'O(n)',\n        average: 'O(n²)',\n        worst: 'O(n²)'\n      },\n      space: {\n        best: 'O(1)',\n        average: 'O(1)',\n        worst: 'O(1)'\n      },\n      comparisons: {\n        best: 'O(n)',\n        average: useBinarySearch ? 'O(n log n)' : 'O(n²)',\n        worst: useBinarySearch ? 'O(n log n)' : 'O(n²)'\n      },\n      assignments: {\n        best: 'O(n)',\n        average: 'O(n²)',\n        worst: 'O(n²)'\n      }\n    };\n  }\n\n  /**\n   * Whether Insertion Sort is stable\n   * \n   * @returns {boolean} - True as Insertion Sort is stable\n   */\n  isStable() {\n    return true;\n  }\n\n  /**\n   * Whether Insertion Sort is in-place\n   * \n   * @returns {boolean} - True as Insertion Sort is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add insertion sort specific information\n    info.optimization = {\n      useBinarySearch: this.options.useBinarySearch,\n      earlyTermination: this.options.earlyTermination,\n      gapSize: this.options.gapSize\n    };\n    info.properties = {\n      comparisonBased: true,\n      stable: true,\n      inPlace: true,\n      online: true,\n      // Can sort as elements arrive\n      adaptive: true // Performance improves with partially sorted arrays\n    };\n    info.suitable = {\n      smallArrays: true,\n      nearlySortedArrays: true,\n      continuousInput: true,\n      // Good for ongoing/streaming data\n      largeArrays: false\n    };\n    info.variants = ['Classic Insertion Sort', 'Binary Insertion Sort', 'Gap Insertion Sort (Shell Sort with single gap)', 'Two-way Insertion Sort', 'Linked List Insertion Sort'];\n    info.advantages = ['Simple implementation with minimal code', 'Efficient for small datasets (often used as a base case in recursive sorts)', 'Adaptive - O(n) time for nearly sorted data', 'Stable - preserves relative order of equal elements', 'In-place - requires minimal extra memory', 'Online - can sort as new elements arrive'];\n    info.disadvantages = ['O(n²) time complexity makes it inefficient for large datasets', 'Many writes/shifts even when using binary search optimization', 'Much slower than advanced algorithms like quicksort and mergesort', 'Poor cache performance due to shifting elements'];\n    info.educationalInsights = ['Demonstrates the concept of growing a sorted region incrementally', 'Provides intuition for adaptive sorting behavior', 'Foundation for understanding more complex algorithms like Shell Sort and Timsort', 'Illustrates the distinction between comparison efficiency and write efficiency'];\n    return info;\n  }\n}\nexport default InsertionSort;","map":{"version":3,"names":["Algorithm","InsertionSort","constructor","options","useBinarySearch","earlyTermination","gapSize","run","array","result","n","length","setPhase","binaryInsertionSort","gapInsertionSort","classicInsertionSort","shifts","i","recordState","type","index","message","key","read","j","positionFound","compare","write","movedFrom","movedTo","element","endIndex","insertionPos","findInsertionPosition","position","gap","start","from","to","low","high","mid","Math","floor","compareIndex","compareValue","getComplexity","time","best","average","worst","space","comparisons","assignments","isStable","isInPlace","getInfo","info","optimization","properties","comparisonBased","stable","inPlace","online","adaptive","suitable","smallArrays","nearlySortedArrays","continuousInput","largeArrays","variants","advantages","disadvantages","educationalInsights"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/comparison/insertion.js"],"sourcesContent":["// src/algorithms/comparison/insertion.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Insertion Sort with multiple optimization variants.\n * \n * Insertion Sort builds the final sorted array one item at a time by repeatedly\n * taking the next unsorted element and inserting it into its correct position\n * within the already-sorted portion of the array.\n *\n * This implementation includes optimizations:\n * - Binary search for finding insertion position (reduces comparisons)\n * - Early termination when no shifts occur in a pass\n * - Gap insertion for improved performance on certain datasets\n * \n * Time Complexity:\n * - Best:    O(n) when array is already sorted\n * - Average: O(n²)\n * - Worst:   O(n²) when array is in reverse order\n * \n * Space Complexity: O(1) - truly in-place\n *\n * @class InsertionSort\n * @extends Algorithm\n */\nclass InsertionSort extends Algorithm {\n  /**\n   * Create a new InsertionSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.useBinarySearch=false] - Use binary search to find insertion position\n   * @param {boolean} [options.earlyTermination=true] - Stop when no shifts occur\n   * @param {number} [options.gapSize=1] - Gap between compared elements (1 for classic)\n   */\n  constructor(options = {}) {\n    super('Insertion Sort', 'comparison', options);\n    \n    // Default options\n    this.options = {\n      useBinarySearch: false,   // Use binary search to find insertion position\n      earlyTermination: true,   // Stop when no shifts occur in a pass\n      gapSize: 1,               // Gap between compared elements (1 for classic)\n      ...options\n    };\n  }\n  \n  /**\n   * Execute Insertion Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('sorting');\n    \n    // Select appropriate insertion sort variant\n    if (options.useBinarySearch) {\n      this.binaryInsertionSort(result, options);\n    } else if (options.gapSize > 1) {\n      this.gapInsertionSort(result, options);\n    } else {\n      this.classicInsertionSort(result, options);\n    }\n    \n    this.setPhase('completed');\n    return result;\n  }\n  \n  /**\n   * Classic implementation of Insertion Sort\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {Object} options - Runtime options\n   */\n  classicInsertionSort(array, options) {\n    const n = array.length;\n    let shifts = 0;\n    \n    for (let i = 1; i < n; i++) {\n      // Record the current position being processed\n      this.recordState(array, {\n        type: 'insertion-start',\n        index: i,\n        message: `Starting insertion for element at index ${i}`\n      });\n      \n      // Current element to be inserted into sorted portion\n      const key = this.read(array, i);\n      let j = i - 1;\n      \n      // Find position for key in the sorted portion\n      let positionFound = false;\n      \n      while (j >= 0 && this.compare(this.read(array, j), key) > 0) {\n        // Shift elements to make room for key\n        this.write(array, j + 1, this.read(array, j));\n        j--;\n        shifts++;\n        \n        // Record significant shifting steps\n        if (j % 5 === 0 || j === 0) {\n          this.recordState(array, {\n            type: 'shift-operation',\n            movedFrom: j + 1,\n            movedTo: j + 2,\n            message: `Shifted element right to make room for ${key}`\n          });\n        }\n      }\n      \n      // Insert the key at its correct position\n      if (j + 1 !== i) {\n        this.write(array, j + 1, key);\n        \n        // Record the insertion\n        this.recordState(array, {\n          type: 'insertion-complete',\n          index: j + 1,\n          element: key,\n          message: `Inserted element ${key} at position ${j + 1}`\n        });\n      } else {\n        // Element already in correct position\n        this.recordState(array, {\n          type: 'no-movement',\n          index: i,\n          message: `Element ${key} already in correct position`\n        });\n      }\n      \n      // Mark sorted region\n      this.recordState(array, {\n        type: 'sorted-region',\n        endIndex: i,\n        message: `Array is now sorted up to index ${i}`\n      });\n    }\n    \n    // Check if early termination could be applied (for educational purposes)\n    if (options.earlyTermination && shifts === 0) {\n      this.recordState(array, {\n        type: 'early-termination',\n        message: 'Array was already sorted, could have terminated early'\n      });\n    }\n  }\n  \n  /**\n   * Binary Insertion Sort - uses binary search to find insertion position\n   * Reduces number of comparisons but not assignments\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {Object} options - Runtime options\n   */\n  binaryInsertionSort(array, options) {\n    const n = array.length;\n    let shifts = 0;\n    \n    for (let i = 1; i < n; i++) {\n      // Record the current position being processed\n      this.recordState(array, {\n        type: 'insertion-start',\n        index: i,\n        message: `Starting binary insertion for element at index ${i}`\n      });\n      \n      // Current element to be inserted\n      const key = this.read(array, i);\n      \n      // Use binary search to find insertion position\n      const insertionPos = this.findInsertionPosition(array, key, 0, i - 1);\n      \n      // Record binary search result\n      this.recordState(array, {\n        type: 'binary-search',\n        element: key,\n        position: insertionPos,\n        message: `Binary search found insertion position ${insertionPos} for element ${key}`\n      });\n      \n      // If the element is already in correct position, skip shifting\n      if (insertionPos === i) {\n        this.recordState(array, {\n          type: 'no-movement',\n          index: i,\n          message: `Element ${key} already in correct position`\n        });\n        continue;\n      }\n      \n      // Shift all elements to the right\n      for (let j = i - 1; j >= insertionPos; j--) {\n        this.write(array, j + 1, this.read(array, j));\n        shifts++;\n        \n        // Record significant shifting steps\n        if ((j - insertionPos) % 5 === 0 || j === insertionPos) {\n          this.recordState(array, {\n            type: 'shift-operation',\n            movedFrom: j,\n            movedTo: j + 1,\n            message: `Shifted element right to make room for ${key}`\n          });\n        }\n      }\n      \n      // Insert the element\n      this.write(array, insertionPos, key);\n      \n      // Record the insertion\n      this.recordState(array, {\n        type: 'insertion-complete',\n        index: insertionPos,\n        element: key,\n        message: `Inserted element ${key} at position ${insertionPos}`\n      });\n      \n      // Mark sorted region\n      this.recordState(array, {\n        type: 'sorted-region',\n        endIndex: i,\n        message: `Array is now sorted up to index ${i}`\n      });\n    }\n  }\n  \n  /**\n   * Gap Insertion Sort - generalization that allows sorting with a gap\n   * Setting gap > 1 implements a single pass of Shell Sort\n   * \n   * @param {Array} array - Array to be sorted\n   * @param {Object} options - Runtime options\n   */\n  gapInsertionSort(array, options) {\n    const n = array.length;\n    const gap = options.gapSize;\n    \n    this.recordState(array, {\n      type: 'gap-insertion',\n      gap: gap,\n      message: `Performing insertion sort with gap size ${gap}`\n    });\n    \n    // Sort each subarray defined by the gap\n    for (let start = 0; start < gap; start++) {\n      // Record subarray start\n      this.recordState(array, {\n        type: 'gap-subarray',\n        start: start,\n        gap: gap,\n        message: `Sorting subarray starting at index ${start} with gap ${gap}`\n      });\n      \n      // Insertion sort on the subarray\n      for (let i = start + gap; i < n; i += gap) {\n        const key = this.read(array, i);\n        let j = i - gap;\n        \n        while (j >= 0 && this.compare(this.read(array, j), key) > 0) {\n          this.write(array, j + gap, this.read(array, j));\n          j -= gap;\n          \n          // Record shift operation\n          this.recordState(array, {\n            type: 'gap-shift',\n            from: j + gap,\n            to: j + 2 * gap,\n            gap: gap,\n            message: `Shifted element at index ${j + gap} with gap ${gap}`\n          });\n        }\n        \n        this.write(array, j + gap, key);\n        \n        // Record insertion with gap\n        this.recordState(array, {\n          type: 'gap-insertion-complete',\n          index: j + gap,\n          element: key,\n          gap: gap,\n          message: `Inserted element ${key} at position ${j + gap} with gap ${gap}`\n        });\n      }\n    }\n    \n    // Final state after all subarrays sorted\n    this.recordState(array, {\n      type: 'gap-complete',\n      gap: gap,\n      message: `Completed insertion sort with gap size ${gap}`\n    });\n  }\n  \n  /**\n   * Binary search to find insertion position\n   * Optimization to reduce the number of comparisons\n   * \n   * @param {Array} array - The array to search in\n   * @param {*} key - The element to insert\n   * @param {number} low - Start index of sorted portion\n   * @param {number} high - End index of sorted portion\n   * @returns {number} - Index where key should be inserted\n   */\n  findInsertionPosition(array, key, low, high) {\n    // Record binary search start\n    this.recordState(array, {\n      type: 'binary-search-start',\n      element: key,\n      low: low,\n      high: high,\n      message: `Starting binary search for position of ${key} between indices ${low} and ${high}`\n    });\n    \n    // Base case: narrowed down to a single position\n    if (high <= low) {\n      return (this.compare(key, this.read(array, low)) >= 0) ? low + 1 : low;\n    }\n    \n    // Find the middle point\n    const mid = Math.floor((low + high) / 2);\n    \n    // Record comparison at middle\n    this.recordState(array, {\n      type: 'binary-comparison',\n      element: key,\n      compareIndex: mid,\n      compareValue: array[mid],\n      message: `Comparing ${key} with element at index ${mid} (${array[mid]})`\n    });\n    \n    // Recursive search in appropriate half\n    if (this.compare(key, this.read(array, mid)) < 0) {\n      return this.findInsertionPosition(array, key, low, mid - 1);\n    } else {\n      return this.findInsertionPosition(array, key, mid + 1, high);\n    }\n  }\n  \n  /**\n   * Get the time and space complexity of Insertion Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    const useBinarySearch = this.options.useBinarySearch;\n    \n    return {\n      time: {\n        best: 'O(n)',\n        average: 'O(n²)',\n        worst: 'O(n²)'\n      },\n      space: {\n        best: 'O(1)',\n        average: 'O(1)',\n        worst: 'O(1)'\n      },\n      comparisons: {\n        best: 'O(n)',\n        average: useBinarySearch ? 'O(n log n)' : 'O(n²)',\n        worst: useBinarySearch ? 'O(n log n)' : 'O(n²)'\n      },\n      assignments: {\n        best: 'O(n)',\n        average: 'O(n²)',\n        worst: 'O(n²)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Insertion Sort is stable\n   * \n   * @returns {boolean} - True as Insertion Sort is stable\n   */\n  isStable() {\n    return true;\n  }\n  \n  /**\n   * Whether Insertion Sort is in-place\n   * \n   * @returns {boolean} - True as Insertion Sort is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add insertion sort specific information\n    info.optimization = {\n      useBinarySearch: this.options.useBinarySearch,\n      earlyTermination: this.options.earlyTermination,\n      gapSize: this.options.gapSize\n    };\n    \n    info.properties = {\n      comparisonBased: true,\n      stable: true,\n      inPlace: true,\n      online: true, // Can sort as elements arrive\n      adaptive: true // Performance improves with partially sorted arrays\n    };\n    \n    info.suitable = {\n      smallArrays: true,\n      nearlySortedArrays: true,\n      continuousInput: true, // Good for ongoing/streaming data\n      largeArrays: false\n    };\n    \n    info.variants = [\n      'Classic Insertion Sort',\n      'Binary Insertion Sort',\n      'Gap Insertion Sort (Shell Sort with single gap)',\n      'Two-way Insertion Sort',\n      'Linked List Insertion Sort'\n    ];\n    \n    info.advantages = [\n      'Simple implementation with minimal code',\n      'Efficient for small datasets (often used as a base case in recursive sorts)',\n      'Adaptive - O(n) time for nearly sorted data',\n      'Stable - preserves relative order of equal elements',\n      'In-place - requires minimal extra memory',\n      'Online - can sort as new elements arrive'\n    ];\n    \n    info.disadvantages = [\n      'O(n²) time complexity makes it inefficient for large datasets',\n      'Many writes/shifts even when using binary search optimization',\n      'Much slower than advanced algorithms like quicksort and mergesort',\n      'Poor cache performance due to shifting elements'\n    ];\n    \n    info.educationalInsights = [\n      'Demonstrates the concept of growing a sorted region incrementally',\n      'Provides intuition for adaptive sorting behavior',\n      'Foundation for understanding more complex algorithms like Shell Sort and Timsort',\n      'Illustrates the distinction between comparison efficiency and write efficiency'\n    ];\n    \n    return info;\n  }\n}\n\nexport default InsertionSort;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}