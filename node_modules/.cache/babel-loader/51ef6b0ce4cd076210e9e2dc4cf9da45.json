{"ast":null,"code":"// src/algorithms/distribution/counting.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Counting Sort algorithm with multiple visualization options.\n * \n * Counting Sort works by:\n * 1. Counting occurrences of each element in the input array\n * 2. Computing cumulative counts to determine positions\n * 3. Building the output array by placing elements in their correct positions\n * \n * This is a non-comparison based sort with O(n+k) time complexity,\n * where k is the range of input values.\n * \n * @class CountingSort\n * @extends Algorithm\n */\nclass CountingSort extends Algorithm {\n  /**\n   * Create a new CountingSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.visualizeCountingArray=true] - Visualize the counting array\n   * @param {boolean} [options.visualizeCumulativeCounts=true] - Visualize cumulative count calculation\n   * @param {boolean} [options.stableSort=true] - Use stable sorting for equal elements\n   * @param {boolean} [options.autoDetectRange=true] - Automatically detect input range\n   */\n  constructor(options = {}) {\n    super('Counting Sort', 'distribution', options);\n\n    // Default options\n    this.options = {\n      visualizeCountingArray: true,\n      // Visualize the counting array\n      visualizeCumulativeCounts: true,\n      // Visualize cumulative count calculation\n      stableSort: true,\n      // Use stable sorting for equal elements\n      autoDetectRange: true,\n      // Automatically detect input range\n      minValue: 0,\n      // Minimum value in array (used if autoDetectRange is false)\n      maxValue: 100,\n      // Maximum value in array (used if autoDetectRange is false)\n      ...options\n    };\n  }\n\n  /**\n   * Execute Counting Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for empty or single-element arrays\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('range-detection');\n\n    // Determine range of values\n    let min = options.minValue;\n    let max = options.maxValue;\n    if (options.autoDetectRange) {\n      min = Infinity;\n      max = -Infinity;\n      for (let i = 0; i < n; i++) {\n        const value = this.read(result, i);\n        if (value < min) min = value;\n        if (value > max) max = value;\n      }\n      this.recordState(result, {\n        type: 'range-detection',\n        min,\n        max,\n        message: `Detected value range: [${min}, ${max}]`\n      });\n    }\n    this.setPhase('counting');\n\n    // Create counting array\n    const range = max - min + 1;\n    const count = new Array(range).fill(0);\n\n    // Count occurrences of each element\n    for (let i = 0; i < n; i++) {\n      const value = this.read(result, i);\n      const index = value - min;\n      count[index]++;\n      if (options.visualizeCountingArray) {\n        this.recordState(result, {\n          type: 'counting',\n          value,\n          countIndex: index,\n          countArray: [...count],\n          message: `Counting occurrences: count[${value}] = ${count[index]}`\n        });\n      }\n    }\n    this.setPhase('cumulative-counting');\n\n    // Compute cumulative counts\n    if (options.visualizeCumulativeCounts) {\n      this.recordState(result, {\n        type: 'cumulative-init',\n        countArray: [...count],\n        message: `Initial counting array: [${count.join(', ')}]`\n      });\n    }\n    for (let i = 1; i < range; i++) {\n      count[i] += count[i - 1];\n      if (options.visualizeCumulativeCounts) {\n        this.recordState(result, {\n          type: 'cumulative-update',\n          index: i,\n          countArray: [...count],\n          message: `Updated cumulative count: count[${i + min}] = ${count[i]}`\n        });\n      }\n    }\n    this.setPhase('building-output');\n\n    // Build the output array\n    const output = new Array(n);\n\n    // Process array from right to left for stability\n    for (let i = n - 1; i >= 0; i--) {\n      const value = this.read(result, i);\n      const countIndex = value - min;\n      const position = count[countIndex] - 1;\n      this.write(output, position, value);\n      count[countIndex]--;\n      this.recordState([...output], {\n        type: 'placement',\n        value,\n        sourceIndex: i,\n        targetIndex: position,\n        countArray: [...count],\n        originalArray: [...result],\n        message: `Placing value ${value} from index ${i} to position ${position}`\n      });\n    }\n\n    // Copy output back to result array\n    for (let i = 0; i < n; i++) {\n      this.write(result, i, output[i]);\n    }\n    this.setPhase('completed');\n    this.recordState(result, {\n      type: 'final',\n      message: 'Sorting completed'\n    });\n    return result;\n  }\n\n  /**\n   * Get the time and space complexity of Counting Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(n+k)',\n        average: 'O(n+k)',\n        worst: 'O(n+k)'\n      },\n      space: {\n        best: 'O(n+k)',\n        average: 'O(n+k)',\n        worst: 'O(n+k)'\n      }\n    };\n  }\n\n  /**\n   * Whether Counting Sort is stable\n   * \n   * @returns {boolean} - True if using stable sort option\n   */\n  isStable() {\n    return this.options.stableSort;\n  }\n\n  /**\n   * Whether Counting Sort is in-place\n   * \n   * @returns {boolean} - False as Counting Sort requires O(n+k) extra space\n   */\n  isInPlace() {\n    return false;\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add counting sort specific information\n    info.optimization = {\n      visualizeCountingArray: this.options.visualizeCountingArray,\n      visualizeCumulativeCounts: this.options.visualizeCumulativeCounts,\n      stableSort: this.options.stableSort,\n      autoDetectRange: this.options.autoDetectRange\n    };\n    info.properties = {\n      comparisonBased: false,\n      stable: this.options.stableSort,\n      inPlace: false,\n      online: false,\n      distributional: true\n    };\n    info.suitable = {\n      smallArrays: true,\n      nearlySortedArrays: true,\n      largeArrays: true,\n      limitedRange: true\n    };\n    info.variants = ['Standard Counting Sort', 'Counting Sort with stability preservation', 'Object Counting Sort (sorting objects by keys)', 'Radix Sort (uses Counting Sort as a subroutine)'];\n    info.advantages = ['O(n+k) time complexity, which can be O(n) when k is O(n)', 'Can be faster than comparison-based sorts for suitable inputs', 'Stable sorting when implemented properly', 'Works well for discrete data with limited range'];\n    info.disadvantages = ['Requires O(n+k) extra space', 'Inefficient when the range (k) is much larger than the input size (n)', 'Only applicable to non-negative integers or data that can be mapped to them', 'Requires knowledge of the range of input values'];\n    return info;\n  }\n}\nexport default CountingSort;","map":{"version":3,"names":["Algorithm","CountingSort","constructor","options","visualizeCountingArray","visualizeCumulativeCounts","stableSort","autoDetectRange","minValue","maxValue","run","array","result","n","length","setPhase","min","max","Infinity","i","value","read","recordState","type","message","range","count","Array","fill","index","countIndex","countArray","join","output","position","write","sourceIndex","targetIndex","originalArray","getComplexity","time","best","average","worst","space","isStable","isInPlace","getInfo","info","optimization","properties","comparisonBased","stable","inPlace","online","distributional","suitable","smallArrays","nearlySortedArrays","largeArrays","limitedRange","variants","advantages","disadvantages"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/distribution/counting.js"],"sourcesContent":["// src/algorithms/distribution/counting.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Counting Sort algorithm with multiple visualization options.\n * \n * Counting Sort works by:\n * 1. Counting occurrences of each element in the input array\n * 2. Computing cumulative counts to determine positions\n * 3. Building the output array by placing elements in their correct positions\n * \n * This is a non-comparison based sort with O(n+k) time complexity,\n * where k is the range of input values.\n * \n * @class CountingSort\n * @extends Algorithm\n */\nclass CountingSort extends Algorithm {\n  /**\n   * Create a new CountingSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.visualizeCountingArray=true] - Visualize the counting array\n   * @param {boolean} [options.visualizeCumulativeCounts=true] - Visualize cumulative count calculation\n   * @param {boolean} [options.stableSort=true] - Use stable sorting for equal elements\n   * @param {boolean} [options.autoDetectRange=true] - Automatically detect input range\n   */\n  constructor(options = {}) {\n    super('Counting Sort', 'distribution', options);\n    \n    // Default options\n    this.options = {\n      visualizeCountingArray: true,     // Visualize the counting array\n      visualizeCumulativeCounts: true,  // Visualize cumulative count calculation\n      stableSort: true,                 // Use stable sorting for equal elements\n      autoDetectRange: true,            // Automatically detect input range\n      minValue: 0,                      // Minimum value in array (used if autoDetectRange is false)\n      maxValue: 100,                    // Maximum value in array (used if autoDetectRange is false)\n      ...options\n    };\n  }\n  \n  /**\n   * Execute Counting Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for empty or single-element arrays\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('range-detection');\n    \n    // Determine range of values\n    let min = options.minValue;\n    let max = options.maxValue;\n    \n    if (options.autoDetectRange) {\n      min = Infinity;\n      max = -Infinity;\n      \n      for (let i = 0; i < n; i++) {\n        const value = this.read(result, i);\n        if (value < min) min = value;\n        if (value > max) max = value;\n      }\n      \n      this.recordState(result, {\n        type: 'range-detection',\n        min,\n        max,\n        message: `Detected value range: [${min}, ${max}]`\n      });\n    }\n    \n    this.setPhase('counting');\n    \n    // Create counting array\n    const range = max - min + 1;\n    const count = new Array(range).fill(0);\n    \n    // Count occurrences of each element\n    for (let i = 0; i < n; i++) {\n      const value = this.read(result, i);\n      const index = value - min;\n      count[index]++;\n      \n      if (options.visualizeCountingArray) {\n        this.recordState(result, {\n          type: 'counting',\n          value,\n          countIndex: index,\n          countArray: [...count],\n          message: `Counting occurrences: count[${value}] = ${count[index]}`\n        });\n      }\n    }\n    \n    this.setPhase('cumulative-counting');\n    \n    // Compute cumulative counts\n    if (options.visualizeCumulativeCounts) {\n      this.recordState(result, {\n        type: 'cumulative-init',\n        countArray: [...count],\n        message: `Initial counting array: [${count.join(', ')}]`\n      });\n    }\n    \n    for (let i = 1; i < range; i++) {\n      count[i] += count[i - 1];\n      \n      if (options.visualizeCumulativeCounts) {\n        this.recordState(result, {\n          type: 'cumulative-update',\n          index: i,\n          countArray: [...count],\n          message: `Updated cumulative count: count[${i + min}] = ${count[i]}`\n        });\n      }\n    }\n    \n    this.setPhase('building-output');\n    \n    // Build the output array\n    const output = new Array(n);\n    \n    // Process array from right to left for stability\n    for (let i = n - 1; i >= 0; i--) {\n      const value = this.read(result, i);\n      const countIndex = value - min;\n      const position = count[countIndex] - 1;\n      \n      this.write(output, position, value);\n      count[countIndex]--;\n      \n      this.recordState([...output], {\n        type: 'placement',\n        value,\n        sourceIndex: i,\n        targetIndex: position,\n        countArray: [...count],\n        originalArray: [...result],\n        message: `Placing value ${value} from index ${i} to position ${position}`\n      });\n    }\n    \n    // Copy output back to result array\n    for (let i = 0; i < n; i++) {\n      this.write(result, i, output[i]);\n    }\n    \n    this.setPhase('completed');\n    \n    this.recordState(result, {\n      type: 'final',\n      message: 'Sorting completed'\n    });\n    \n    return result;\n  }\n  \n  /**\n   * Get the time and space complexity of Counting Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(n+k)',\n        average: 'O(n+k)',\n        worst: 'O(n+k)'\n      },\n      space: {\n        best: 'O(n+k)',\n        average: 'O(n+k)',\n        worst: 'O(n+k)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Counting Sort is stable\n   * \n   * @returns {boolean} - True if using stable sort option\n   */\n  isStable() {\n    return this.options.stableSort;\n  }\n  \n  /**\n   * Whether Counting Sort is in-place\n   * \n   * @returns {boolean} - False as Counting Sort requires O(n+k) extra space\n   */\n  isInPlace() {\n    return false;\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add counting sort specific information\n    info.optimization = {\n      visualizeCountingArray: this.options.visualizeCountingArray,\n      visualizeCumulativeCounts: this.options.visualizeCumulativeCounts,\n      stableSort: this.options.stableSort,\n      autoDetectRange: this.options.autoDetectRange\n    };\n    \n    info.properties = {\n      comparisonBased: false,\n      stable: this.options.stableSort,\n      inPlace: false,\n      online: false,\n      distributional: true\n    };\n    \n    info.suitable = {\n      smallArrays: true,\n      nearlySortedArrays: true,\n      largeArrays: true,\n      limitedRange: true\n    };\n    \n    info.variants = [\n      'Standard Counting Sort',\n      'Counting Sort with stability preservation',\n      'Object Counting Sort (sorting objects by keys)',\n      'Radix Sort (uses Counting Sort as a subroutine)'\n    ];\n    \n    info.advantages = [\n      'O(n+k) time complexity, which can be O(n) when k is O(n)',\n      'Can be faster than comparison-based sorts for suitable inputs',\n      'Stable sorting when implemented properly',\n      'Works well for discrete data with limited range'\n    ];\n    \n    info.disadvantages = [\n      'Requires O(n+k) extra space',\n      'Inefficient when the range (k) is much larger than the input size (n)',\n      'Only applicable to non-negative integers or data that can be mapped to them',\n      'Requires knowledge of the range of input values'\n    ];\n    \n    return info;\n  }\n}\n\nexport default CountingSort;"],"mappings":"AAAA;;AAEA,OAAOA,SAAS,MAAM,wBAAwB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,SAASD,SAAS,CAAC;EACnC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,WAAWA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IACxB,KAAK,CAAC,eAAe,EAAE,cAAc,EAAEA,OAAO,CAAC;;IAE/C;IACA,IAAI,CAACA,OAAO,GAAG;MACbC,sBAAsB,EAAE,IAAI;MAAM;MAClCC,yBAAyB,EAAE,IAAI;MAAG;MAClCC,UAAU,EAAE,IAAI;MAAkB;MAClCC,eAAe,EAAE,IAAI;MAAa;MAClCC,QAAQ,EAAE,CAAC;MAAuB;MAClCC,QAAQ,EAAE,GAAG;MAAqB;MAClC,GAAGN;IACL,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEO,GAAGA,CAACC,KAAK,EAAER,OAAO,EAAE;IAClB;IACA,MAAMS,MAAM,GAAG,CAAC,GAAGD,KAAK,CAAC;IACzB,MAAME,CAAC,GAAGD,MAAM,CAACE,MAAM;;IAEvB;IACA,IAAID,CAAC,IAAI,CAAC,EAAE;MACV,OAAOD,MAAM;IACf;IAEA,IAAI,CAACG,QAAQ,CAAC,iBAAiB,CAAC;;IAEhC;IACA,IAAIC,GAAG,GAAGb,OAAO,CAACK,QAAQ;IAC1B,IAAIS,GAAG,GAAGd,OAAO,CAACM,QAAQ;IAE1B,IAAIN,OAAO,CAACI,eAAe,EAAE;MAC3BS,GAAG,GAAGE,QAAQ;MACdD,GAAG,GAAG,CAACC,QAAQ;MAEf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,CAAC,EAAEM,CAAC,EAAE,EAAE;QAC1B,MAAMC,KAAK,GAAG,IAAI,CAACC,IAAI,CAACT,MAAM,EAAEO,CAAC,CAAC;QAClC,IAAIC,KAAK,GAAGJ,GAAG,EAAEA,GAAG,GAAGI,KAAK;QAC5B,IAAIA,KAAK,GAAGH,GAAG,EAAEA,GAAG,GAAGG,KAAK;MAC9B;MAEA,IAAI,CAACE,WAAW,CAACV,MAAM,EAAE;QACvBW,IAAI,EAAE,iBAAiB;QACvBP,GAAG;QACHC,GAAG;QACHO,OAAO,EAAE,0BAA0BR,GAAG,KAAKC,GAAG;MAChD,CAAC,CAAC;IACJ;IAEA,IAAI,CAACF,QAAQ,CAAC,UAAU,CAAC;;IAEzB;IACA,MAAMU,KAAK,GAAGR,GAAG,GAAGD,GAAG,GAAG,CAAC;IAC3B,MAAMU,KAAK,GAAG,IAAIC,KAAK,CAACF,KAAK,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC;;IAEtC;IACA,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,CAAC,EAAEM,CAAC,EAAE,EAAE;MAC1B,MAAMC,KAAK,GAAG,IAAI,CAACC,IAAI,CAACT,MAAM,EAAEO,CAAC,CAAC;MAClC,MAAMU,KAAK,GAAGT,KAAK,GAAGJ,GAAG;MACzBU,KAAK,CAACG,KAAK,CAAC,EAAE;MAEd,IAAI1B,OAAO,CAACC,sBAAsB,EAAE;QAClC,IAAI,CAACkB,WAAW,CAACV,MAAM,EAAE;UACvBW,IAAI,EAAE,UAAU;UAChBH,KAAK;UACLU,UAAU,EAAED,KAAK;UACjBE,UAAU,EAAE,CAAC,GAAGL,KAAK,CAAC;UACtBF,OAAO,EAAE,+BAA+BJ,KAAK,OAAOM,KAAK,CAACG,KAAK,CAAC;QAClE,CAAC,CAAC;MACJ;IACF;IAEA,IAAI,CAACd,QAAQ,CAAC,qBAAqB,CAAC;;IAEpC;IACA,IAAIZ,OAAO,CAACE,yBAAyB,EAAE;MACrC,IAAI,CAACiB,WAAW,CAACV,MAAM,EAAE;QACvBW,IAAI,EAAE,iBAAiB;QACvBQ,UAAU,EAAE,CAAC,GAAGL,KAAK,CAAC;QACtBF,OAAO,EAAE,4BAA4BE,KAAK,CAACM,IAAI,CAAC,IAAI,CAAC;MACvD,CAAC,CAAC;IACJ;IAEA,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGM,KAAK,EAAEN,CAAC,EAAE,EAAE;MAC9BO,KAAK,CAACP,CAAC,CAAC,IAAIO,KAAK,CAACP,CAAC,GAAG,CAAC,CAAC;MAExB,IAAIhB,OAAO,CAACE,yBAAyB,EAAE;QACrC,IAAI,CAACiB,WAAW,CAACV,MAAM,EAAE;UACvBW,IAAI,EAAE,mBAAmB;UACzBM,KAAK,EAAEV,CAAC;UACRY,UAAU,EAAE,CAAC,GAAGL,KAAK,CAAC;UACtBF,OAAO,EAAE,mCAAmCL,CAAC,GAAGH,GAAG,OAAOU,KAAK,CAACP,CAAC,CAAC;QACpE,CAAC,CAAC;MACJ;IACF;IAEA,IAAI,CAACJ,QAAQ,CAAC,iBAAiB,CAAC;;IAEhC;IACA,MAAMkB,MAAM,GAAG,IAAIN,KAAK,CAACd,CAAC,CAAC;;IAE3B;IACA,KAAK,IAAIM,CAAC,GAAGN,CAAC,GAAG,CAAC,EAAEM,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC/B,MAAMC,KAAK,GAAG,IAAI,CAACC,IAAI,CAACT,MAAM,EAAEO,CAAC,CAAC;MAClC,MAAMW,UAAU,GAAGV,KAAK,GAAGJ,GAAG;MAC9B,MAAMkB,QAAQ,GAAGR,KAAK,CAACI,UAAU,CAAC,GAAG,CAAC;MAEtC,IAAI,CAACK,KAAK,CAACF,MAAM,EAAEC,QAAQ,EAAEd,KAAK,CAAC;MACnCM,KAAK,CAACI,UAAU,CAAC,EAAE;MAEnB,IAAI,CAACR,WAAW,CAAC,CAAC,GAAGW,MAAM,CAAC,EAAE;QAC5BV,IAAI,EAAE,WAAW;QACjBH,KAAK;QACLgB,WAAW,EAAEjB,CAAC;QACdkB,WAAW,EAAEH,QAAQ;QACrBH,UAAU,EAAE,CAAC,GAAGL,KAAK,CAAC;QACtBY,aAAa,EAAE,CAAC,GAAG1B,MAAM,CAAC;QAC1BY,OAAO,EAAE,iBAAiBJ,KAAK,eAAeD,CAAC,gBAAgBe,QAAQ;MACzE,CAAC,CAAC;IACJ;;IAEA;IACA,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,CAAC,EAAEM,CAAC,EAAE,EAAE;MAC1B,IAAI,CAACgB,KAAK,CAACvB,MAAM,EAAEO,CAAC,EAAEc,MAAM,CAACd,CAAC,CAAC,CAAC;IAClC;IAEA,IAAI,CAACJ,QAAQ,CAAC,WAAW,CAAC;IAE1B,IAAI,CAACO,WAAW,CAACV,MAAM,EAAE;MACvBW,IAAI,EAAE,OAAO;MACbC,OAAO,EAAE;IACX,CAAC,CAAC;IAEF,OAAOZ,MAAM;EACf;;EAEA;AACF;AACA;AACA;AACA;EACE2B,aAAaA,CAAA,EAAG;IACd,OAAO;MACLC,IAAI,EAAE;QACJC,IAAI,EAAE,QAAQ;QACdC,OAAO,EAAE,QAAQ;QACjBC,KAAK,EAAE;MACT,CAAC;MACDC,KAAK,EAAE;QACLH,IAAI,EAAE,QAAQ;QACdC,OAAO,EAAE,QAAQ;QACjBC,KAAK,EAAE;MACT;IACF,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;EACEE,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC1C,OAAO,CAACG,UAAU;EAChC;;EAEA;AACF;AACA;AACA;AACA;EACEwC,SAASA,CAAA,EAAG;IACV,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;EACEC,OAAOA,CAAA,EAAG;IACR,MAAMC,IAAI,GAAG,KAAK,CAACD,OAAO,CAAC,CAAC;;IAE5B;IACAC,IAAI,CAACC,YAAY,GAAG;MAClB7C,sBAAsB,EAAE,IAAI,CAACD,OAAO,CAACC,sBAAsB;MAC3DC,yBAAyB,EAAE,IAAI,CAACF,OAAO,CAACE,yBAAyB;MACjEC,UAAU,EAAE,IAAI,CAACH,OAAO,CAACG,UAAU;MACnCC,eAAe,EAAE,IAAI,CAACJ,OAAO,CAACI;IAChC,CAAC;IAEDyC,IAAI,CAACE,UAAU,GAAG;MAChBC,eAAe,EAAE,KAAK;MACtBC,MAAM,EAAE,IAAI,CAACjD,OAAO,CAACG,UAAU;MAC/B+C,OAAO,EAAE,KAAK;MACdC,MAAM,EAAE,KAAK;MACbC,cAAc,EAAE;IAClB,CAAC;IAEDP,IAAI,CAACQ,QAAQ,GAAG;MACdC,WAAW,EAAE,IAAI;MACjBC,kBAAkB,EAAE,IAAI;MACxBC,WAAW,EAAE,IAAI;MACjBC,YAAY,EAAE;IAChB,CAAC;IAEDZ,IAAI,CAACa,QAAQ,GAAG,CACd,wBAAwB,EACxB,2CAA2C,EAC3C,gDAAgD,EAChD,iDAAiD,CAClD;IAEDb,IAAI,CAACc,UAAU,GAAG,CAChB,0DAA0D,EAC1D,+DAA+D,EAC/D,0CAA0C,EAC1C,iDAAiD,CAClD;IAEDd,IAAI,CAACe,aAAa,GAAG,CACnB,6BAA6B,EAC7B,uEAAuE,EACvE,6EAA6E,EAC7E,iDAAiD,CAClD;IAED,OAAOf,IAAI;EACb;AACF;AAEA,eAAe/C,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module"}