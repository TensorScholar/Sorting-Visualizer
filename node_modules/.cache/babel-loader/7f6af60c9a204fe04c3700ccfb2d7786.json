{"ast":null,"code":"// src/algorithms/parallel/bitonic.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Bitonic Sort algorithm with visualization of the sorting network.\n * \n * Bitonic Sort is a parallel sorting algorithm that leverages a sorting network architecture.\n * It works by:\n * 1. Recursively constructing a bitonic sequence (a sequence that first increases then decreases)\n * 2. Recursively splitting and merging bitonic sequences to sort the array\n * \n * Key properties:\n * - Highly parallelizable with O(log²n) time complexity on n processors\n * - Fixed data-independent comparison sequence, making it suitable for hardware implementation\n * - Works optimally on arrays with length = 2^n\n * \n * This implementation includes:\n * - Visualization of the bitonic sorting network\n * - Parallelization simulation\n * - Support for non-power-of-2 array sizes\n * - Stage-by-stage execution for educational purposes\n * \n * @class BitonicSort\n * @extends Algorithm\n */\nclass BitonicSort extends Algorithm {\n  /**\n   * Create a new BitonicSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.visualizeNetwork=true] - Visualize the sorting network\n   * @param {boolean} [options.simulateParallelism=true] - Simulate parallel execution\n   * @param {boolean} [options.supportNonPowerOfTwo=true] - Support non-power-of-2 array sizes\n   * @param {boolean} [options.stageByStage=true] - Execute and visualize stage by stage\n   */\n  constructor(options = {}) {\n    super('Bitonic Sort', 'parallel', options);\n\n    // Default options\n    this.options = {\n      visualizeNetwork: true,\n      // Visualize the sorting network\n      simulateParallelism: true,\n      // Simulate parallel execution\n      supportNonPowerOfTwo: true,\n      // Support non-power-of-2 array sizes\n      stageByStage: true,\n      // Execute and visualize stage by stage\n      ...options\n    };\n\n    // Network visualization data\n    this.network = {\n      stages: [],\n      // Stages of the sorting network\n      comparators: [],\n      // Comparator connections\n      currentStage: 0,\n      // Current stage being executed\n      totalStages: 0 // Total number of stages\n    };\n  }\n\n  /**\n   * Execute Bitonic Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n\n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    this.setPhase('initialization');\n\n    // Handle non-power-of-2 array sizes if enabled\n    if (options.supportNonPowerOfTwo) {\n      const paddedArray = this.padToPowerOfTwo(result);\n\n      // Record padding operation\n      if (paddedArray.length > n) {\n        this.recordState(paddedArray, {\n          type: 'padding',\n          originalLength: n,\n          paddedLength: paddedArray.length,\n          message: `Padded array to length ${paddedArray.length} (next power of 2)`\n        });\n      }\n\n      // Sort the padded array\n      this.bitonicSort(paddedArray, 0, paddedArray.length, true, options);\n\n      // Return only the original elements (removing padding)\n      return paddedArray.slice(0, n);\n    }\n\n    // Sort the array directly if it's already a power of 2\n    this.bitonicSort(result, 0, n, true, options);\n    this.setPhase('completed');\n    return result;\n  }\n\n  /**\n   * Main Bitonic Sort recursive implementation\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} low - Starting index\n   * @param {number} count - Number of elements to sort\n   * @param {boolean} direction - Sorting direction (true for ascending, false for descending)\n   * @param {Object} options - Runtime options\n   */\n  bitonicSort(array, low, count, direction, options) {\n    if (count <= 1) {\n      return;\n    }\n\n    // Divide the array into two halves\n    const mid = Math.floor(count / 2);\n\n    // Record the division\n    this.recordState(array, {\n      type: 'divide',\n      low: low,\n      mid: low + mid,\n      high: low + count - 1,\n      message: `Dividing array section [${low}...${low + count - 1}] at ${low + mid - 1}`\n    });\n\n    // Recursively sort the first half in ascending order\n    this.bitonicSort(array, low, mid, true, options);\n\n    // Recursively sort the second half in descending order (to create bitonic sequence)\n    this.bitonicSort(array, low + mid, mid, false, options);\n\n    // Merge the bitonic sequence\n    this.bitonicMerge(array, low, count, direction, options);\n  }\n\n  /**\n   * Merge a bitonic sequence\n   * \n   * @param {Array} array - Array containing the bitonic sequence\n   * @param {number} low - Starting index\n   * @param {number} count - Number of elements to merge\n   * @param {boolean} direction - Merge direction (true for ascending, false for descending)\n   * @param {Object} options - Runtime options\n   */\n  bitonicMerge(array, low, count, direction, options) {\n    if (count <= 1) {\n      return;\n    }\n    const mid = Math.floor(count / 2);\n\n    // Perform comparisons between pairs of elements\n    for (let i = low; i < low + mid; i++) {\n      this.bitonicCompare(array, i, i + mid, direction, options);\n    }\n\n    // Record the comparison phase\n    if (options.visualizeNetwork) {\n      const stageInfo = {\n        type: 'merge-stage',\n        low: low,\n        count: count,\n        comparisons: Array.from({\n          length: mid\n        }, (_, i) => [low + i, low + mid + i]),\n        direction: direction,\n        message: `Merging bitonic sequence [${low}...${low + count - 1}], direction: ${direction ? 'ascending' : 'descending'}`\n      };\n      this.network.stages.push(stageInfo);\n      this.network.currentStage = this.network.stages.length - 1;\n      this.network.totalStages = this.network.stages.length;\n      this.recordState(array, {\n        ...stageInfo,\n        network: {\n          ...this.network\n        }\n      });\n    }\n\n    // Recursively merge the two halves\n    this.bitonicMerge(array, low, mid, direction, options);\n    this.bitonicMerge(array, low + mid, mid, direction, options);\n  }\n\n  /**\n   * Perform a bitonic compare-exchange operation\n   * \n   * @param {Array} array - Array to operate on\n   * @param {number} i - First index\n   * @param {number} j - Second index\n   * @param {boolean} direction - Comparison direction (true for ascending, false for descending)\n   * @param {Object} options - Runtime options\n   */\n  bitonicCompare(array, i, j, direction, options) {\n    // Skip if indices are out of bounds\n    if (i >= array.length || j >= array.length) {\n      return;\n    }\n\n    // Compare elements\n    const compResult = this.compare(array[i], array[j]);\n\n    // Swap if needed based on direction\n    if (direction && compResult > 0 || !direction && compResult < 0) {\n      this.swap(array, i, j);\n\n      // Record the swap\n      this.recordState(array, {\n        type: 'compare-exchange',\n        indices: [i, j],\n        direction: direction,\n        message: `Compare-exchange: Swapped elements at indices ${i} and ${j} (direction: ${direction ? 'ascending' : 'descending'})`\n      });\n    } else {\n      // Record the comparison (no swap needed)\n      this.recordState(array, {\n        type: 'compare-no-exchange',\n        indices: [i, j],\n        direction: direction,\n        message: `Compare-exchange: No swap needed between indices ${i} and ${j} (direction: ${direction ? 'ascending' : 'descending'})`\n      });\n    }\n\n    // Add this comparator to the network visualization\n    if (options.visualizeNetwork) {\n      this.network.comparators.push({\n        from: i,\n        to: j,\n        direction: direction,\n        swapped: direction && compResult > 0 || !direction && compResult < 0\n      });\n    }\n  }\n\n  /**\n   * Pad array to next power of 2 for Bitonic Sort\n   * \n   * @param {Array} array - Original array\n   * @returns {Array} - Padded array with length = next power of 2\n   */\n  padToPowerOfTwo(array) {\n    const n = array.length;\n\n    // Check if already a power of 2\n    if ((n & n - 1) === 0) {\n      return array.slice();\n    }\n\n    // Calculate next power of 2\n    const nextPow2 = Math.pow(2, Math.ceil(Math.log2(n)));\n\n    // Create padded array\n    const result = array.slice();\n\n    // Fill remaining slots with a value larger than any in the original array\n    // This ensures these elements end up at the end after sorting\n    const maxVal = Math.max(...array, Number.MIN_SAFE_INTEGER) + 1;\n    for (let i = n; i < nextPow2; i++) {\n      result.push(maxVal);\n    }\n    return result;\n  }\n\n  /**\n   * Get the time and space complexity of Bitonic Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(log²n)',\n        // With n processors\n        average: 'O(log²n)',\n        // With n processors\n        worst: 'O(log²n)',\n        // With n processors\n        sequential: 'O(n log²n)' // Sequential implementation\n      },\n      space: {\n        best: 'O(1)',\n        average: 'O(1)',\n        worst: 'O(1)'\n      },\n      comparisons: {\n        total: 'O(n log²n)'\n      }\n    };\n  }\n\n  /**\n   * Whether Bitonic Sort is stable\n   * \n   * @returns {boolean} - False as Bitonic Sort is not stable\n   */\n  isStable() {\n    return false;\n  }\n\n  /**\n   * Whether Bitonic Sort is in-place\n   * \n   * @returns {boolean} - True as Bitonic Sort is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n\n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n\n    // Add bitonic sort specific information\n    info.optimization = {\n      visualizeNetwork: this.options.visualizeNetwork,\n      simulateParallelism: this.options.simulateParallelism,\n      supportNonPowerOfTwo: this.options.supportNonPowerOfTwo,\n      stageByStage: this.options.stageByStage\n    };\n    info.properties = {\n      comparisonBased: true,\n      stable: false,\n      inPlace: true,\n      online: false,\n      parallelizable: true,\n      deterministicNetwork: true\n    };\n    info.suitable = {\n      parallelHardware: true,\n      gpuImplementation: true,\n      fixedSizeArrays: true,\n      powerOfTwoSizes: true,\n      fpgaImplementation: true\n    };\n    info.variants = ['Standard Bitonic Sort', 'Odd-Even Bitonic Merge Sort', 'Parallel Bitonic Sort', 'Adaptive Bitonic Sort'];\n    info.advantages = ['Highly parallelizable with O(log²n) parallel time complexity', 'Fixed comparison pattern regardless of input data', 'Well-suited for hardware implementation (FPGA, GPU)', 'In-place with O(1) auxiliary space', 'Predictable performance across all inputs'];\n    info.disadvantages = ['Not stable (does not preserve order of equal elements)', 'Requires power-of-2 array size (or padding)', 'O(n log²n) sequential time complexity is worse than O(n log n) algorithms', 'Complex to understand and implement correctly', 'Less efficient for serial processing compared to quicksort or mergesort'];\n    info.applications = ['GPU sorting implementations', 'FPGA-based sorting networks', 'High-performance computing where parallel resources are available', 'Fixed-size sorting applications in hardware', 'Data routing in network switches'];\n    return info;\n  }\n}\nexport default BitonicSort;","map":{"version":3,"names":["Algorithm","BitonicSort","constructor","options","visualizeNetwork","simulateParallelism","supportNonPowerOfTwo","stageByStage","network","stages","comparators","currentStage","totalStages","run","array","result","n","length","setPhase","paddedArray","padToPowerOfTwo","recordState","type","originalLength","paddedLength","message","bitonicSort","slice","low","count","direction","mid","Math","floor","high","bitonicMerge","i","bitonicCompare","stageInfo","comparisons","Array","from","_","push","j","compResult","compare","swap","indices","to","swapped","nextPow2","pow","ceil","log2","maxVal","max","Number","MIN_SAFE_INTEGER","getComplexity","time","best","average","worst","sequential","space","total","isStable","isInPlace","getInfo","info","optimization","properties","comparisonBased","stable","inPlace","online","parallelizable","deterministicNetwork","suitable","parallelHardware","gpuImplementation","fixedSizeArrays","powerOfTwoSizes","fpgaImplementation","variants","advantages","disadvantages","applications"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/algorithms/network/bitonic.js"],"sourcesContent":["// src/algorithms/parallel/bitonic.js\n\nimport Algorithm from '../core/algorithm-base';\n\n/**\n * Implementation of Bitonic Sort algorithm with visualization of the sorting network.\n * \n * Bitonic Sort is a parallel sorting algorithm that leverages a sorting network architecture.\n * It works by:\n * 1. Recursively constructing a bitonic sequence (a sequence that first increases then decreases)\n * 2. Recursively splitting and merging bitonic sequences to sort the array\n * \n * Key properties:\n * - Highly parallelizable with O(log²n) time complexity on n processors\n * - Fixed data-independent comparison sequence, making it suitable for hardware implementation\n * - Works optimally on arrays with length = 2^n\n * \n * This implementation includes:\n * - Visualization of the bitonic sorting network\n * - Parallelization simulation\n * - Support for non-power-of-2 array sizes\n * - Stage-by-stage execution for educational purposes\n * \n * @class BitonicSort\n * @extends Algorithm\n */\nclass BitonicSort extends Algorithm {\n  /**\n   * Create a new BitonicSort instance\n   * \n   * @param {Object} options - Configuration options\n   * @param {boolean} [options.visualizeNetwork=true] - Visualize the sorting network\n   * @param {boolean} [options.simulateParallelism=true] - Simulate parallel execution\n   * @param {boolean} [options.supportNonPowerOfTwo=true] - Support non-power-of-2 array sizes\n   * @param {boolean} [options.stageByStage=true] - Execute and visualize stage by stage\n   */\n  constructor(options = {}) {\n    super('Bitonic Sort', 'parallel', options);\n    \n    // Default options\n    this.options = {\n      visualizeNetwork: true,     // Visualize the sorting network\n      simulateParallelism: true,  // Simulate parallel execution\n      supportNonPowerOfTwo: true, // Support non-power-of-2 array sizes\n      stageByStage: true,         // Execute and visualize stage by stage\n      ...options\n    };\n    \n    // Network visualization data\n    this.network = {\n      stages: [],          // Stages of the sorting network\n      comparators: [],     // Comparator connections\n      currentStage: 0,     // Current stage being executed\n      totalStages: 0       // Total number of stages\n    };\n  }\n  \n  /**\n   * Execute Bitonic Sort on the input array\n   * \n   * @param {Array} array - Input array to be sorted\n   * @param {Object} options - Runtime options\n   * @returns {Array} - Sorted array\n   */\n  run(array, options) {\n    // Clone array to avoid modifying the original\n    const result = [...array];\n    const n = result.length;\n    \n    // Early return for small arrays\n    if (n <= 1) {\n      return result;\n    }\n    \n    this.setPhase('initialization');\n    \n    // Handle non-power-of-2 array sizes if enabled\n    if (options.supportNonPowerOfTwo) {\n      const paddedArray = this.padToPowerOfTwo(result);\n      \n      // Record padding operation\n      if (paddedArray.length > n) {\n        this.recordState(paddedArray, {\n          type: 'padding',\n          originalLength: n,\n          paddedLength: paddedArray.length,\n          message: `Padded array to length ${paddedArray.length} (next power of 2)`\n        });\n      }\n      \n      // Sort the padded array\n      this.bitonicSort(paddedArray, 0, paddedArray.length, true, options);\n      \n      // Return only the original elements (removing padding)\n      return paddedArray.slice(0, n);\n    }\n    \n    // Sort the array directly if it's already a power of 2\n    this.bitonicSort(result, 0, n, true, options);\n    \n    this.setPhase('completed');\n    return result;\n  }\n  \n  /**\n   * Main Bitonic Sort recursive implementation\n   * \n   * @param {Array} array - Array to sort\n   * @param {number} low - Starting index\n   * @param {number} count - Number of elements to sort\n   * @param {boolean} direction - Sorting direction (true for ascending, false for descending)\n   * @param {Object} options - Runtime options\n   */\n  bitonicSort(array, low, count, direction, options) {\n    if (count <= 1) {\n      return;\n    }\n    \n    // Divide the array into two halves\n    const mid = Math.floor(count / 2);\n    \n    // Record the division\n    this.recordState(array, {\n      type: 'divide',\n      low: low,\n      mid: low + mid,\n      high: low + count - 1,\n      message: `Dividing array section [${low}...${low + count - 1}] at ${low + mid - 1}`\n    });\n    \n    // Recursively sort the first half in ascending order\n    this.bitonicSort(array, low, mid, true, options);\n    \n    // Recursively sort the second half in descending order (to create bitonic sequence)\n    this.bitonicSort(array, low + mid, mid, false, options);\n    \n    // Merge the bitonic sequence\n    this.bitonicMerge(array, low, count, direction, options);\n  }\n  \n  /**\n   * Merge a bitonic sequence\n   * \n   * @param {Array} array - Array containing the bitonic sequence\n   * @param {number} low - Starting index\n   * @param {number} count - Number of elements to merge\n   * @param {boolean} direction - Merge direction (true for ascending, false for descending)\n   * @param {Object} options - Runtime options\n   */\n  bitonicMerge(array, low, count, direction, options) {\n    if (count <= 1) {\n      return;\n    }\n    \n    const mid = Math.floor(count / 2);\n    \n    // Perform comparisons between pairs of elements\n    for (let i = low; i < low + mid; i++) {\n      this.bitonicCompare(array, i, i + mid, direction, options);\n    }\n    \n    // Record the comparison phase\n    if (options.visualizeNetwork) {\n      const stageInfo = {\n        type: 'merge-stage',\n        low: low,\n        count: count,\n        comparisons: Array.from({ length: mid }, (_, i) => [low + i, low + mid + i]),\n        direction: direction,\n        message: `Merging bitonic sequence [${low}...${low + count - 1}], direction: ${direction ? 'ascending' : 'descending'}`\n      };\n      \n      this.network.stages.push(stageInfo);\n      this.network.currentStage = this.network.stages.length - 1;\n      this.network.totalStages = this.network.stages.length;\n      \n      this.recordState(array, {\n        ...stageInfo,\n        network: { ...this.network }\n      });\n    }\n    \n    // Recursively merge the two halves\n    this.bitonicMerge(array, low, mid, direction, options);\n    this.bitonicMerge(array, low + mid, mid, direction, options);\n  }\n  \n  /**\n   * Perform a bitonic compare-exchange operation\n   * \n   * @param {Array} array - Array to operate on\n   * @param {number} i - First index\n   * @param {number} j - Second index\n   * @param {boolean} direction - Comparison direction (true for ascending, false for descending)\n   * @param {Object} options - Runtime options\n   */\n  bitonicCompare(array, i, j, direction, options) {\n    // Skip if indices are out of bounds\n    if (i >= array.length || j >= array.length) {\n      return;\n    }\n    \n    // Compare elements\n    const compResult = this.compare(array[i], array[j]);\n    \n    // Swap if needed based on direction\n    if ((direction && compResult > 0) || (!direction && compResult < 0)) {\n      this.swap(array, i, j);\n      \n      // Record the swap\n      this.recordState(array, {\n        type: 'compare-exchange',\n        indices: [i, j],\n        direction: direction,\n        message: `Compare-exchange: Swapped elements at indices ${i} and ${j} (direction: ${direction ? 'ascending' : 'descending'})`\n      });\n    } else {\n      // Record the comparison (no swap needed)\n      this.recordState(array, {\n        type: 'compare-no-exchange',\n        indices: [i, j],\n        direction: direction,\n        message: `Compare-exchange: No swap needed between indices ${i} and ${j} (direction: ${direction ? 'ascending' : 'descending'})`\n      });\n    }\n    \n    // Add this comparator to the network visualization\n    if (options.visualizeNetwork) {\n      this.network.comparators.push({\n        from: i,\n        to: j,\n        direction: direction,\n        swapped: (direction && compResult > 0) || (!direction && compResult < 0)\n      });\n    }\n  }\n  \n  /**\n   * Pad array to next power of 2 for Bitonic Sort\n   * \n   * @param {Array} array - Original array\n   * @returns {Array} - Padded array with length = next power of 2\n   */\n  padToPowerOfTwo(array) {\n    const n = array.length;\n    \n    // Check if already a power of 2\n    if ((n & (n - 1)) === 0) {\n      return array.slice();\n    }\n    \n    // Calculate next power of 2\n    const nextPow2 = Math.pow(2, Math.ceil(Math.log2(n)));\n    \n    // Create padded array\n    const result = array.slice();\n    \n    // Fill remaining slots with a value larger than any in the original array\n    // This ensures these elements end up at the end after sorting\n    const maxVal = Math.max(...array, Number.MIN_SAFE_INTEGER) + 1;\n    for (let i = n; i < nextPow2; i++) {\n      result.push(maxVal);\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get the time and space complexity of Bitonic Sort\n   * \n   * @returns {Object} - Complexity information\n   */\n  getComplexity() {\n    return {\n      time: {\n        best: 'O(log²n)',     // With n processors\n        average: 'O(log²n)',  // With n processors\n        worst: 'O(log²n)',    // With n processors\n        sequential: 'O(n log²n)'  // Sequential implementation\n      },\n      space: {\n        best: 'O(1)',\n        average: 'O(1)',\n        worst: 'O(1)'\n      },\n      comparisons: {\n        total: 'O(n log²n)'\n      }\n    };\n  }\n  \n  /**\n   * Whether Bitonic Sort is stable\n   * \n   * @returns {boolean} - False as Bitonic Sort is not stable\n   */\n  isStable() {\n    return false;\n  }\n  \n  /**\n   * Whether Bitonic Sort is in-place\n   * \n   * @returns {boolean} - True as Bitonic Sort is in-place\n   */\n  isInPlace() {\n    return true;\n  }\n  \n  /**\n   * Get detailed algorithm information\n   * \n   * @returns {Object} - Detailed algorithm metadata\n   */\n  getInfo() {\n    const info = super.getInfo();\n    \n    // Add bitonic sort specific information\n    info.optimization = {\n      visualizeNetwork: this.options.visualizeNetwork,\n      simulateParallelism: this.options.simulateParallelism,\n      supportNonPowerOfTwo: this.options.supportNonPowerOfTwo,\n      stageByStage: this.options.stageByStage\n    };\n    \n    info.properties = {\n      comparisonBased: true,\n      stable: false,\n      inPlace: true,\n      online: false,\n      parallelizable: true,\n      deterministicNetwork: true\n    };\n    \n    info.suitable = {\n      parallelHardware: true,\n      gpuImplementation: true,\n      fixedSizeArrays: true,\n      powerOfTwoSizes: true,\n      fpgaImplementation: true\n    };\n    \n    info.variants = [\n      'Standard Bitonic Sort',\n      'Odd-Even Bitonic Merge Sort',\n      'Parallel Bitonic Sort',\n      'Adaptive Bitonic Sort'\n    ];\n    \n    info.advantages = [\n      'Highly parallelizable with O(log²n) parallel time complexity',\n      'Fixed comparison pattern regardless of input data',\n      'Well-suited for hardware implementation (FPGA, GPU)',\n      'In-place with O(1) auxiliary space',\n      'Predictable performance across all inputs'\n    ];\n    \n    info.disadvantages = [\n      'Not stable (does not preserve order of equal elements)',\n      'Requires power-of-2 array size (or padding)',\n      'O(n log²n) sequential time complexity is worse than O(n log n) algorithms',\n      'Complex to understand and implement correctly',\n      'Less efficient for serial processing compared to quicksort or mergesort'\n    ];\n    \n    info.applications = [\n      'GPU sorting implementations',\n      'FPGA-based sorting networks',\n      'High-performance computing where parallel resources are available',\n      'Fixed-size sorting applications in hardware',\n      'Data routing in network switches'\n    ];\n    \n    return info;\n  }\n}\n\nexport default BitonicSort;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}