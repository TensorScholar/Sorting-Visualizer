{"ast":null,"code":"var _jsxFileName = \"/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/visualization/components/HeapVisualizer.js\";\n// src/visualization/components/HeapVisualizer.js\n\nimport React, { useRef, useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * HeapVisualizer Component\n * \n * A specialized visualization component that renders the implicit binary tree\n * structure of a heap, enabling intuitive understanding of heap operations through\n * visual representation of parent-child relationships, node values, and heap property\n * enforcement.\n * \n * This implementation applies computational geometry principles to accurately position\n * nodes according to complete binary tree topology, with O(n) time complexity for\n * rendering and O(1) space complexity beyond the input structure.\n * \n * @author Advanced Sorting Visualization Platform\n * @version 1.0.0\n */\nconst HeapVisualizer = ({\n  heapStructure,\n  width = 600,\n  height = 400,\n  nodeRadius = 25,\n  highlightColor = '#FF5722',\n  nodeColor = '#3F51B5',\n  leafColor = '#4CAF50',\n  textColor = '#FFFFFF'\n}) => {\n  // Reference to the canvas element for imperative rendering\n  const canvasRef = useRef(null);\n\n  /**\n   * Pre-compute rendering constants for mathematical precision\n   * This optimization prevents recalculation during render operations\n   */\n  const renderConstants = useMemo(() => {\n    if (!heapStructure) return null;\n\n    // Calculate max depth of the heap for level scaling\n    const maxLevel = Math.max(...((heapStructure === null || heapStructure === void 0 ? void 0 : heapStructure.nodes) || []).map(node => node.level), 0);\n    return {\n      // Vertical spacing between tree levels, accounting for node size and padding\n      levelHeight: height / (maxLevel + 2),\n      // Horizontal padding to ensure tree is centered\n      xPadding: 20,\n      // Available width for node positioning\n      availableWidth: width - 2 * 20,\n      // 20px padding on each side\n\n      // Maximum tree depth for scaling calculations\n      maxLevel\n    };\n  }, [heapStructure, width, height]);\n\n  /**\n   * Canvas rendering effect that executes whenever the heap structure\n   * or rendering parameters change, implementing the visualization algorithm\n   */\n  useEffect(() => {\n    // Guard clause to prevent rendering without data or canvas\n    if (!heapStructure || !canvasRef.current || !renderConstants) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Clear canvas with optimal buffer clearing method\n    ctx.clearRect(0, 0, width, height);\n\n    // Destructure rendering constants for clarity\n    const {\n      levelHeight,\n      xPadding,\n      availableWidth,\n      maxLevel\n    } = renderConstants;\n\n    // Scientific visualization principle: render background elements first\n    renderEdges(ctx, heapStructure, levelHeight, xPadding, availableWidth);\n\n    // Then render foreground elements (nodes)\n    renderNodes(ctx, heapStructure, levelHeight, xPadding, availableWidth);\n\n    // Finally, render informational overlay elements\n    renderInformation(ctx);\n  }, [heapStructure, width, height, nodeRadius, highlightColor, nodeColor, leafColor, textColor, renderConstants]);\n\n  /**\n   * Renders the edges connecting nodes in the binary heap\n   * Implements precise geometric positioning based on complete binary tree properties\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {Object} heapStructure - Heap structure data\n   * @param {number} levelHeight - Vertical distance between levels\n   * @param {number} xPadding - Horizontal padding\n   * @param {number} availableWidth - Available width for rendering\n   */\n  const renderEdges = (ctx, heapStructure, levelHeight, xPadding, availableWidth) => {\n    ctx.strokeStyle = '#888888';\n    ctx.lineWidth = 2;\n\n    // For each edge in the heap structure\n    heapStructure.edges.forEach(edge => {\n      const fromNode = heapStructure.nodes.find(n => n.id === edge.from);\n      const toNode = heapStructure.nodes.find(n => n.id === edge.to);\n      if (!fromNode || !toNode) return;\n\n      // Calculate node positions using mathematical formula for complete binary tree\n      // This formula guarantees proper node distribution at each level using powers of 2\n      const fromX = xPadding + (fromNode.id + 1) * availableWidth / Math.pow(2, fromNode.level + 1);\n      const fromY = (fromNode.level + 1) * levelHeight;\n      const toX = xPadding + (toNode.id + 1) * availableWidth / Math.pow(2, toNode.level + 1);\n      const toY = (toNode.level + 1) * levelHeight;\n\n      // Draw edge with anti-aliasing for visual clarity\n      ctx.beginPath();\n      ctx.moveTo(fromX, fromY);\n      ctx.lineTo(toX, toY);\n      ctx.stroke();\n\n      // Draw edge type label (left/right) at midpoint\n      const midX = (fromX + toX) / 2;\n      const midY = (fromY + toY) / 2;\n      ctx.fillStyle = '#888888';\n      ctx.font = '10px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(edge.type, midX, midY - 8);\n    });\n  };\n\n  /**\n   * Renders the nodes of the binary heap with appropriate styling and information\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {Object} heapStructure - Heap structure data\n   * @param {number} levelHeight - Vertical distance between levels\n   * @param {number} xPadding - Horizontal padding\n   * @param {number} availableWidth - Available width for rendering\n   */\n  const renderNodes = (ctx, heapStructure, levelHeight, xPadding, availableWidth) => {\n    heapStructure.nodes.forEach(node => {\n      // Calculate node position with perfect binary tree spacing algorithm\n      const x = xPadding + (node.id + 1) * availableWidth / Math.pow(2, node.level + 1);\n      const y = (node.level + 1) * levelHeight;\n\n      // Determine node fill color based on node state and type\n      let fillColor = node.isLeaf ? leafColor : nodeColor;\n\n      // Apply highlight if this node is the current focus of operation\n      if (heapStructure.highlight !== undefined && node.id === heapStructure.highlight) {\n        fillColor = highlightColor;\n      }\n\n      // Draw node circle with high-quality anti-aliasing\n      ctx.beginPath();\n      ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n\n      // Draw node outline for visual definition\n      ctx.strokeStyle = '#000000';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      // Render node value with appropriate styling\n      ctx.fillStyle = textColor;\n\n      // Dynamically scale font size based on content length for readability\n      const valueText = String(node.value);\n      const fontSize = Math.max(10, Math.min(16, Math.floor(20 / Math.max(1, valueText.length))));\n      ctx.font = `bold ${fontSize}px Arial`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(valueText, x, y);\n\n      // Render array index below node for educational context\n      ctx.fillStyle = '#000000';\n      ctx.font = '12px Arial';\n      ctx.fillText(`idx: ${node.id}`, x, y + nodeRadius + 15);\n    });\n  };\n\n  /**\n   * Renders informational elements for educational context\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   */\n  const renderInformation = ctx => {\n    // Render heap property information\n    ctx.fillStyle = '#333333';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    ctx.fillText('Binary Max Heap: parent â‰¥ children', 10, 10);\n\n    // Draw legend for visual elements\n    const legendY = height - 40;\n\n    // Internal node representation\n    ctx.beginPath();\n    ctx.arc(30, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = nodeColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.textAlign = 'left';\n    ctx.fillText('Internal Node', 50, legendY - 5);\n\n    // Leaf node representation\n    ctx.beginPath();\n    ctx.arc(150, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = leafColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Leaf Node', 170, legendY - 5);\n\n    // Highlighted node representation\n    ctx.beginPath();\n    ctx.arc(270, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = highlightColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Current Node', 290, legendY - 5);\n  };\n\n  // Render component with accessible structure and fallback content\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"heap-visualizer\",\n    \"data-testid\": \"heap-visualizer\",\n    \"aria-label\": \"Binary heap visualization\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 235,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: canvasRef,\n    width: width,\n    height: height,\n    className: \"heap-canvas\",\n    style: {\n      border: '1px solid #ddd',\n      borderRadius: '4px',\n      display: 'block'\n    },\n    \"aria-hidden\": \"true\" // Canvas content described by surrounding elements\n    ,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 240,\n      columnNumber: 7\n    }\n  }), !heapStructure && /*#__PURE__*/React.createElement(\"div\", {\n    className: \"heap-placeholder\",\n    style: {\n      position: 'absolute',\n      top: '50%',\n      left: '50%',\n      transform: 'translate(-50%, -50%)',\n      color: '#888',\n      fontSize: '16px'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 253,\n      columnNumber: 9\n    }\n  }, \"Awaiting heap structure data...\"));\n};\n\n// Rigorous PropTypes definition for component interface documentation\nHeapVisualizer.propTypes = {\n  /** The binary heap structure data object containing nodes and edges */\n  heapStructure: PropTypes.shape({\n    /** Array of node objects representing heap elements */\n    nodes: PropTypes.arrayOf(PropTypes.shape({\n      /** Unique identifier corresponding to array index */\n      id: PropTypes.number.isRequired,\n      /** Node value (heap key) */\n      value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n      /** Tree level (depth) starting from 0 for root */\n      level: PropTypes.number.isRequired,\n      /** Whether this node is a leaf node (has no children) */\n      isLeaf: PropTypes.bool.isRequired\n    })).isRequired,\n    /** Array of edge objects representing parent-child relationships */\n    edges: PropTypes.arrayOf(PropTypes.shape({\n      /** Source node id (parent) */\n      from: PropTypes.number.isRequired,\n      /** Target node id (child) */\n      to: PropTypes.number.isRequired,\n      /** Edge type ('left' or 'right') */\n      type: PropTypes.oneOf(['left', 'right']).isRequired\n    })).isRequired,\n    /** Optional id of the currently highlighted node */\n    highlight: PropTypes.number\n  }),\n  /** Canvas width in pixels */\n  width: PropTypes.number,\n  /** Canvas height in pixels */\n  height: PropTypes.number,\n  /** Radius of tree nodes in pixels */\n  nodeRadius: PropTypes.number,\n  /** Color for highlighted nodes (active operation) */\n  highlightColor: PropTypes.string,\n  /** Color for regular internal nodes */\n  nodeColor: PropTypes.string,\n  /** Color for leaf nodes */\n  leafColor: PropTypes.string,\n  /** Text color for node values */\n  textColor: PropTypes.string\n};\nexport default HeapVisualizer;","map":{"version":3,"names":["React","useRef","useEffect","useMemo","PropTypes","HeapVisualizer","heapStructure","width","height","nodeRadius","highlightColor","nodeColor","leafColor","textColor","canvasRef","renderConstants","maxLevel","Math","max","nodes","map","node","level","levelHeight","xPadding","availableWidth","current","canvas","ctx","getContext","clearRect","renderEdges","renderNodes","renderInformation","strokeStyle","lineWidth","edges","forEach","edge","fromNode","find","n","id","from","toNode","to","fromX","pow","fromY","toX","toY","beginPath","moveTo","lineTo","stroke","midX","midY","fillStyle","font","textAlign","textBaseline","fillText","type","x","y","fillColor","isLeaf","highlight","undefined","arc","PI","fill","valueText","String","value","fontSize","min","floor","length","legendY","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","ref","style","border","borderRadius","display","position","top","left","transform","color","propTypes","shape","arrayOf","number","isRequired","oneOfType","string","bool","oneOf"],"sources":["/Users/mohammadatashi/Documents/GitHub/Advanced-Algorithms-Laboratory/sorting-visualizer/src/visualization/components/HeapVisualizer.js"],"sourcesContent":["// src/visualization/components/HeapVisualizer.js\n\nimport React, { useRef, useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * HeapVisualizer Component\n * \n * A specialized visualization component that renders the implicit binary tree\n * structure of a heap, enabling intuitive understanding of heap operations through\n * visual representation of parent-child relationships, node values, and heap property\n * enforcement.\n * \n * This implementation applies computational geometry principles to accurately position\n * nodes according to complete binary tree topology, with O(n) time complexity for\n * rendering and O(1) space complexity beyond the input structure.\n * \n * @author Advanced Sorting Visualization Platform\n * @version 1.0.0\n */\nconst HeapVisualizer = ({ \n  heapStructure, \n  width = 600, \n  height = 400, \n  nodeRadius = 25,\n  highlightColor = '#FF5722',\n  nodeColor = '#3F51B5',\n  leafColor = '#4CAF50',\n  textColor = '#FFFFFF'\n}) => {\n  // Reference to the canvas element for imperative rendering\n  const canvasRef = useRef(null);\n  \n  /**\n   * Pre-compute rendering constants for mathematical precision\n   * This optimization prevents recalculation during render operations\n   */\n  const renderConstants = useMemo(() => {\n    if (!heapStructure) return null;\n    \n    // Calculate max depth of the heap for level scaling\n    const maxLevel = Math.max(...(heapStructure?.nodes || []).map(node => node.level), 0);\n    \n    return {\n      // Vertical spacing between tree levels, accounting for node size and padding\n      levelHeight: height / (maxLevel + 2),\n      \n      // Horizontal padding to ensure tree is centered\n      xPadding: 20,\n      \n      // Available width for node positioning\n      availableWidth: width - 2 * 20, // 20px padding on each side\n      \n      // Maximum tree depth for scaling calculations\n      maxLevel\n    };\n  }, [heapStructure, width, height]);\n  \n  /**\n   * Canvas rendering effect that executes whenever the heap structure\n   * or rendering parameters change, implementing the visualization algorithm\n   */\n  useEffect(() => {\n    // Guard clause to prevent rendering without data or canvas\n    if (!heapStructure || !canvasRef.current || !renderConstants) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    // Clear canvas with optimal buffer clearing method\n    ctx.clearRect(0, 0, width, height);\n    \n    // Destructure rendering constants for clarity\n    const { levelHeight, xPadding, availableWidth, maxLevel } = renderConstants;\n    \n    // Scientific visualization principle: render background elements first\n    renderEdges(ctx, heapStructure, levelHeight, xPadding, availableWidth);\n    \n    // Then render foreground elements (nodes)\n    renderNodes(ctx, heapStructure, levelHeight, xPadding, availableWidth);\n    \n    // Finally, render informational overlay elements\n    renderInformation(ctx);\n    \n  }, [heapStructure, width, height, nodeRadius, highlightColor, nodeColor, \n      leafColor, textColor, renderConstants]);\n  \n  /**\n   * Renders the edges connecting nodes in the binary heap\n   * Implements precise geometric positioning based on complete binary tree properties\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {Object} heapStructure - Heap structure data\n   * @param {number} levelHeight - Vertical distance between levels\n   * @param {number} xPadding - Horizontal padding\n   * @param {number} availableWidth - Available width for rendering\n   */\n  const renderEdges = (ctx, heapStructure, levelHeight, xPadding, availableWidth) => {\n    ctx.strokeStyle = '#888888';\n    ctx.lineWidth = 2;\n    \n    // For each edge in the heap structure\n    heapStructure.edges.forEach(edge => {\n      const fromNode = heapStructure.nodes.find(n => n.id === edge.from);\n      const toNode = heapStructure.nodes.find(n => n.id === edge.to);\n      \n      if (!fromNode || !toNode) return;\n      \n      // Calculate node positions using mathematical formula for complete binary tree\n      // This formula guarantees proper node distribution at each level using powers of 2\n      const fromX = xPadding + (fromNode.id + 1) * availableWidth / Math.pow(2, fromNode.level + 1);\n      const fromY = (fromNode.level + 1) * levelHeight;\n      \n      const toX = xPadding + (toNode.id + 1) * availableWidth / Math.pow(2, toNode.level + 1);\n      const toY = (toNode.level + 1) * levelHeight;\n      \n      // Draw edge with anti-aliasing for visual clarity\n      ctx.beginPath();\n      ctx.moveTo(fromX, fromY);\n      ctx.lineTo(toX, toY);\n      ctx.stroke();\n      \n      // Draw edge type label (left/right) at midpoint\n      const midX = (fromX + toX) / 2;\n      const midY = (fromY + toY) / 2;\n      \n      ctx.fillStyle = '#888888';\n      ctx.font = '10px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(edge.type, midX, midY - 8);\n    });\n  };\n  \n  /**\n   * Renders the nodes of the binary heap with appropriate styling and information\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   * @param {Object} heapStructure - Heap structure data\n   * @param {number} levelHeight - Vertical distance between levels\n   * @param {number} xPadding - Horizontal padding\n   * @param {number} availableWidth - Available width for rendering\n   */\n  const renderNodes = (ctx, heapStructure, levelHeight, xPadding, availableWidth) => {\n    heapStructure.nodes.forEach(node => {\n      // Calculate node position with perfect binary tree spacing algorithm\n      const x = xPadding + (node.id + 1) * availableWidth / Math.pow(2, node.level + 1);\n      const y = (node.level + 1) * levelHeight;\n      \n      // Determine node fill color based on node state and type\n      let fillColor = node.isLeaf ? leafColor : nodeColor;\n      \n      // Apply highlight if this node is the current focus of operation\n      if (heapStructure.highlight !== undefined && node.id === heapStructure.highlight) {\n        fillColor = highlightColor;\n      }\n      \n      // Draw node circle with high-quality anti-aliasing\n      ctx.beginPath();\n      ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n      \n      // Draw node outline for visual definition\n      ctx.strokeStyle = '#000000';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      \n      // Render node value with appropriate styling\n      ctx.fillStyle = textColor;\n      \n      // Dynamically scale font size based on content length for readability\n      const valueText = String(node.value);\n      const fontSize = Math.max(10, Math.min(16, Math.floor(20 / Math.max(1, valueText.length))));\n      \n      ctx.font = `bold ${fontSize}px Arial`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(valueText, x, y);\n      \n      // Render array index below node for educational context\n      ctx.fillStyle = '#000000';\n      ctx.font = '12px Arial';\n      ctx.fillText(`idx: ${node.id}`, x, y + nodeRadius + 15);\n    });\n  };\n  \n  /**\n   * Renders informational elements for educational context\n   * \n   * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n   */\n  const renderInformation = (ctx) => {\n    // Render heap property information\n    ctx.fillStyle = '#333333';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    ctx.fillText('Binary Max Heap: parent â‰¥ children', 10, 10);\n    \n    // Draw legend for visual elements\n    const legendY = height - 40;\n    \n    // Internal node representation\n    ctx.beginPath();\n    ctx.arc(30, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = nodeColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.textAlign = 'left';\n    ctx.fillText('Internal Node', 50, legendY - 5);\n    \n    // Leaf node representation\n    ctx.beginPath();\n    ctx.arc(150, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = leafColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Leaf Node', 170, legendY - 5);\n    \n    // Highlighted node representation\n    ctx.beginPath();\n    ctx.arc(270, legendY, 10, 0, 2 * Math.PI);\n    ctx.fillStyle = highlightColor;\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = '#333333';\n    ctx.fillText('Current Node', 290, legendY - 5);\n  };\n  \n  // Render component with accessible structure and fallback content\n  return (\n    <div \n      className=\"heap-visualizer\" \n      data-testid=\"heap-visualizer\"\n      aria-label=\"Binary heap visualization\"\n    >\n      <canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        className=\"heap-canvas\"\n        style={{ \n          border: '1px solid #ddd', \n          borderRadius: '4px',\n          display: 'block'\n        }}\n        aria-hidden=\"true\" // Canvas content described by surrounding elements\n      />\n      {!heapStructure && (\n        <div \n          className=\"heap-placeholder\" \n          style={{ \n            position: 'absolute', \n            top: '50%', \n            left: '50%', \n            transform: 'translate(-50%, -50%)',\n            color: '#888',\n            fontSize: '16px'\n          }}\n        >\n          Awaiting heap structure data...\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Rigorous PropTypes definition for component interface documentation\nHeapVisualizer.propTypes = {\n  /** The binary heap structure data object containing nodes and edges */\n  heapStructure: PropTypes.shape({\n    /** Array of node objects representing heap elements */\n    nodes: PropTypes.arrayOf(PropTypes.shape({\n      /** Unique identifier corresponding to array index */\n      id: PropTypes.number.isRequired,\n      /** Node value (heap key) */\n      value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n      /** Tree level (depth) starting from 0 for root */\n      level: PropTypes.number.isRequired,\n      /** Whether this node is a leaf node (has no children) */\n      isLeaf: PropTypes.bool.isRequired\n    })).isRequired,\n    /** Array of edge objects representing parent-child relationships */\n    edges: PropTypes.arrayOf(PropTypes.shape({\n      /** Source node id (parent) */\n      from: PropTypes.number.isRequired,\n      /** Target node id (child) */\n      to: PropTypes.number.isRequired,\n      /** Edge type ('left' or 'right') */\n      type: PropTypes.oneOf(['left', 'right']).isRequired\n    })).isRequired,\n    /** Optional id of the currently highlighted node */\n    highlight: PropTypes.number\n  }),\n  /** Canvas width in pixels */\n  width: PropTypes.number,\n  /** Canvas height in pixels */\n  height: PropTypes.number,\n  /** Radius of tree nodes in pixels */\n  nodeRadius: PropTypes.number,\n  /** Color for highlighted nodes (active operation) */\n  highlightColor: PropTypes.string,\n  /** Color for regular internal nodes */\n  nodeColor: PropTypes.string,\n  /** Color for leaf nodes */\n  leafColor: PropTypes.string,\n  /** Text color for node values */\n  textColor: PropTypes.string\n};\n\nexport default HeapVisualizer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}